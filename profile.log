SCRIPT  /usr/share/nvim/runtime/syntax/rust.vim
Sourced 1 time
Total time:   0.003501
 Self time:   0.003501

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Rust
                            " Maintainer:   Patrick Walton <pcwalton@mozilla.com>
                            " Maintainer:   Ben Blum <bblum@cs.cmu.edu>
                            " Maintainer:   Chris Morgan <me@chrismorgan.info>
                            " Last Change:  Feb 24, 2016
                            " For bugs, patches and license go to https://github.com/rust-lang/rust.vim
                            
    1              0.000010 if version < 600
                            	syntax clear
                            elseif exists("b:current_syntax")
                            	finish
                            endif
                            
                            " Syntax definitions {{{1
                            " Basic keywords {{{2
    1              0.000038 syn keyword   rustConditional match if else
    1              0.000010 syn keyword   rustRepeat for loop while
    1              0.000070 syn keyword   rustTypedef type nextgroup=rustIdentifier skipwhite skipempty
    1              0.000049 syn keyword   rustStructure struct enum nextgroup=rustIdentifier skipwhite skipempty
    1              0.000033 syn keyword   rustUnion union nextgroup=rustIdentifier skipwhite skipempty contained
    1              0.000116 syn match rustUnionContextual /\<union\_s\+\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*/ transparent contains=rustUnion
    1              0.000048 syn keyword   rustOperator    as
                            
    1              0.000104 syn match     rustAssert      "\<assert\(\w\)*!" contained
    1              0.000021 syn match     rustPanic       "\<panic\(\w\)*!" contained
    1              0.000008 syn keyword   rustKeyword     break
    1              0.000017 syn keyword   rustKeyword     box nextgroup=rustBoxPlacement skipwhite skipempty
    1              0.000007 syn keyword   rustKeyword     continue
    1              0.000023 syn keyword   rustKeyword     extern nextgroup=rustExternCrate,rustObsoleteExternMod skipwhite skipempty
    1              0.000013 syn keyword   rustKeyword     fn nextgroup=rustFuncName skipwhite skipempty
    1              0.000007 syn keyword   rustKeyword     in impl let
    1              0.000012 syn keyword   rustKeyword     pub nextgroup=rustPubScope skipwhite skipempty
    1              0.000006 syn keyword   rustKeyword     return
    1              0.000006 syn keyword   rustSuper       super
    1              0.000006 syn keyword   rustKeyword     unsafe where
    1              0.000012 syn keyword   rustKeyword     use nextgroup=rustModPath skipwhite skipempty
                            " FIXME: Scoped impl's name is also fallen in this category
    1              0.000016 syn keyword   rustKeyword     mod trait nextgroup=rustIdentifier skipwhite skipempty
    1              0.000010 syn keyword   rustStorage     move mut ref static const
    1              0.000020 syn match rustDefault /\<default\ze\_s\+\(impl\|fn\|type\|const\)\>/
                            
    1              0.000007 syn keyword   rustInvalidBareKeyword crate
                            
    1              0.000013 syn keyword rustPubScopeCrate crate contained
    1              0.000014 syn match rustPubScopeDelim /[()]/ contained
    1              0.000048 syn match rustPubScope /([^()]*)/ contained contains=rustPubScopeDelim,rustPubScopeCrate,rustSuper,rustModPath,rustModPathSep,rustSelf transparent
                            
    1              0.000022 syn keyword   rustExternCrate crate contained nextgroup=rustIdentifier,rustExternCrateString skipwhite skipempty
                            " This is to get the `bar` part of `extern crate "foo" as bar;` highlighting.
    1              0.000032 syn match   rustExternCrateString /".*"\_s*as/ contained nextgroup=rustIdentifier skipwhite transparent skipempty contains=rustString,rustOperator
    1              0.000020 syn keyword   rustObsoleteExternMod mod contained nextgroup=rustIdentifier skipwhite skipempty
                            
    1              0.000073 syn match     rustIdentifier  contains=rustIdentifierPrime "\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*" display contained
    1              0.000034 syn match     rustFuncName    "\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*" display contained
                            
    1              0.000030 syn region    rustBoxPlacement matchgroup=rustBoxPlacementParens start="(" end=")" contains=TOP contained
                            " Ideally we'd have syntax rules set up to match arbitrary expressions. Since
                            " we don't, we'll just define temporary contained rules to handle balancing
                            " delimiters.
    1              0.000027 syn region    rustBoxPlacementBalance start="(" end=")" containedin=rustBoxPlacement transparent
    1              0.000022 syn region    rustBoxPlacementBalance start="\[" end="\]" containedin=rustBoxPlacement transparent
                            " {} are handled by rustFoldBraces
                            
    1              0.000026 syn region rustMacroRepeat matchgroup=rustMacroRepeatDelimiters start="$(" end=")" contains=TOP nextgroup=rustMacroRepeatCount
    1              0.000013 syn match rustMacroRepeatCount ".\?[*+]" contained
    1              0.000010 syn match rustMacroVariable "$\w\+"
                            
                            " Reserved (but not yet used) keywords {{{2
    1              0.000034 syn keyword   rustReservedKeyword alignof become do offsetof priv pure sizeof typeof unsized yield abstract virtual final override macro
                            
                            " Built-in types {{{2
    1              0.000018 syn keyword   rustType        isize usize char bool u8 u16 u32 u64 u128 f32
    1              0.000011 syn keyword   rustType        f64 i8 i16 i32 i64 i128 str Self
                            
                            " Things from the libstd v1 prelude (src/libstd/prelude/v1.rs) {{{2
                            " This section is just straight transformation of the contents of the prelude,
                            " to make it easy to update.
                            
                            " Reexported core operators {{{3
    1              0.000010 syn keyword   rustTrait       Copy Send Sized Sync
    1              0.000008 syn keyword   rustTrait       Drop Fn FnMut FnOnce
                            
                            " Reexported functions {{{3
                            " There’s no point in highlighting these; when one writes drop( or drop::< it
                            " gets the same highlighting anyway, and if someone writes `let drop = …;` we
                            " don’t really want *that* drop to be highlighted.
                            "syn keyword rustFunction drop
                            
                            " Reexported types and traits {{{3
    1              0.000006 syn keyword rustTrait Box
    1              0.000006 syn keyword rustTrait ToOwned
    1              0.000006 syn keyword rustTrait Clone
    1              0.000008 syn keyword rustTrait PartialEq PartialOrd Eq Ord
    1              0.000007 syn keyword rustTrait AsRef AsMut Into From
    1              0.000006 syn keyword rustTrait Default
    1              0.000007 syn keyword rustTrait Iterator Extend IntoIterator
    1              0.000007 syn keyword rustTrait DoubleEndedIterator ExactSizeIterator
    1              0.000006 syn keyword rustEnum Option
    1              0.000006 syn keyword rustEnumVariant Some None
    1              0.000006 syn keyword rustEnum Result
    1              0.000007 syn keyword rustEnumVariant Ok Err
    1              0.000006 syn keyword rustTrait SliceConcatExt
    1              0.000006 syn keyword rustTrait String ToString
    1              0.000005 syn keyword rustTrait Vec
                            
                            " Other syntax {{{2
    1              0.000006 syn keyword   rustSelf        self
    1              0.000010 syn keyword   rustBoolean     true false
                            
                            " If foo::bar changes to foo.bar, change this ("::" to "\.").
                            " If foo::bar changes to Foo::bar, change this (first "\w" to "\u").
    1              0.000018 syn match     rustModPath     "\w\(\w\)*::[^<]"he=e-3,me=e-3
    1              0.000010 syn match     rustModPathSep  "::"
                            
    1              0.000010 syn match     rustFuncCall    "\w\(\w\)*("he=e-1,me=e-1
    1              0.000010 syn match     rustFuncCall    "\w\(\w\)*::<"he=e-3,me=e-3 " foo::<T>();
                            
                            " This is merely a convention; note also the use of [A-Z], restricting it to
                            " latin identifiers rather than the full Unicode uppercase. I have not used
                            " [:upper:] as it depends upon 'noignorecase'
                            "syn match     rustCapsIdent    display "[A-Z]\w\(\w\)*"
                            
    1              0.000017 syn match     rustOperator     display "\%(+\|-\|/\|*\|=\|\^\|&\||\|!\|>\|<\|%\)=\?"
                            " This one isn't *quite* right, as we could have binary-& with a reference
    1              0.000015 syn match     rustSigil        display /&\s\+[&~@*][^)= \t\r\n]/he=e-1,me=e-1
    1              0.000012 syn match     rustSigil        display /[&~@*][^)= \t\r\n]/he=e-1,me=e-1
                            " This isn't actually correct; a closure with no arguments can be `|| { }`.
                            " Last, because the & in && isn't a sigil
    1              0.000011 syn match     rustOperator     display "&&\|||"
                            " This is rustArrowCharacter rather than rustArrow for the sake of matchparen,
                            " so it skips the ->; see http://stackoverflow.com/a/30309949 for details.
    1              0.000009 syn match     rustArrowCharacter display "->"
    1              0.000014 syn match     rustQuestionMark display "?\([a-zA-Z]\+\)\@!"
                            
    1              0.000024 syn match     rustMacro       '\w\(\w\)*!' contains=rustAssert,rustPanic
    1              0.000021 syn match     rustMacro       '#\w\(\w\)*' contains=rustAssert,rustPanic
                            
    1              0.000009 syn match     rustEscapeError   display contained /\\./
    1              0.000015 syn match     rustEscape        display contained /\\\([nrt0\\'"]\|x\x\{2}\)/
    1              0.000016 syn match     rustEscapeUnicode display contained /\\u{\x\{1,6}}/
    1              0.000010 syn match     rustStringContinuation display contained /\\\n\s*/
    1              0.000037 syn region    rustString      start=+b"+ skip=+\\\\\|\\"+ end=+"+ contains=rustEscape,rustEscapeError,rustStringContinuation
    1              0.000045 syn region    rustString      start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=rustEscape,rustEscapeUnicode,rustEscapeError,rustStringContinuation,@Spell
    1              0.000028 syn region    rustString      start='b\?r\z(#*\)"' end='"\z1' contains=@Spell
                            
    1              0.000060 syn region    rustAttribute   start="#!\?\[" end="\]" contains=rustString,rustDerive,rustCommentLine,rustCommentBlock,rustCommentLineDocError,rustCommentBlockDocError
    1              0.000025 syn region    rustDerive      start="derive(" end=")" contained contains=rustDeriveTrait
                            " This list comes from src/libsyntax/ext/deriving/mod.rs
                            " Some are deprecated (Encodable, Decodable) or to be removed after a new snapshot (Show).
    1              0.000024 syn keyword   rustDeriveTrait contained Clone Hash RustcEncodable RustcDecodable Encodable Decodable PartialEq Eq PartialOrd Ord Rand Show Debug Default FromPrimitive Send Sync Copy
                            
                            " Number literals
    1              0.000029 syn match     rustDecNumber   display "\<[0-9][0-9_]*\%([iu]\%(size\|8\|16\|32\|64\|128\)\)\="
    1              0.000028 syn match     rustHexNumber   display "\<0x[a-fA-F0-9_]\+\%([iu]\%(size\|8\|16\|32\|64\|128\)\)\="
    1              0.000017 syn match     rustOctNumber   display "\<0o[0-7_]\+\%([iu]\%(size\|8\|16\|32\|64\|128\)\)\="
    1              0.000015 syn match     rustBinNumber   display "\<0b[01_]\+\%([iu]\%(size\|8\|16\|32\|64\|128\)\)\="
                            
                            " Special case for numbers of the form "1." which are float literals, unless followed by
                            " an identifier, which makes them integer literals with a method call or field access,
                            " or by another ".", which makes them integer literals followed by the ".." token.
                            " (This must go first so the others take precedence.)
    1              0.000019 syn match     rustFloat       display "\<[0-9][0-9_]*\.\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\|\.\)\@!"
                            " To mark a number as a normal float, it must have at least one of the three things integral values don't have:
                            " a decimal point and more numbers; an exponent; and a type suffix.
    1              0.000020 syn match     rustFloat       display "\<[0-9][0-9_]*\%(\.[0-9][0-9_]*\)\%([eE][+-]\=[0-9_]\+\)\=\(f32\|f64\)\="
    1              0.000018 syn match     rustFloat       display "\<[0-9][0-9_]*\%(\.[0-9][0-9_]*\)\=\%([eE][+-]\=[0-9_]\+\)\(f32\|f64\)\="
    1              0.000015 syn match     rustFloat       display "\<[0-9][0-9_]*\%(\.[0-9][0-9_]*\)\=\%([eE][+-]\=[0-9_]\+\)\=\(f32\|f64\)"
                            
                            " For the benefit of delimitMate
    1              0.000044 syn region rustLifetimeCandidate display start=/&'\%(\([^'\\]\|\\\(['nrt0\\\"]\|x\x\{2}\|u{\x\{1,6}}\)\)'\)\@!/ end=/[[:cntrl:][:space:][:punct:]]\@=\|$/ contains=rustSigil,rustLifetime
    1              0.000041 syn region rustGenericRegion display start=/<\%('\|[^[cntrl:][:space:][:punct:]]\)\@=')\S\@=/ end=/>/ contains=rustGenericLifetimeCandidate
    1              0.000038 syn region rustGenericLifetimeCandidate display start=/\%(<\|,\s*\)\@<='/ end=/[[:cntrl:][:space:][:punct:]]\@=\|$/ contains=rustSigil,rustLifetime
                            
                            "rustLifetime must appear before rustCharacter, or chars will get the lifetime highlighting
    1              0.000023 syn match     rustLifetime    display "\'\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*"
    1              0.000019 syn match     rustLabel       display "\'\%([^[:cntrl:][:space:][:punct:][:digit:]]\|_\)\%([^[:cntrl:][:punct:][:space:]]\|_\)*:"
    1              0.000019 syn match   rustCharacterInvalid   display contained /b\?'\zs[\n\r\t']\ze'/
                            " The groups negated here add up to 0-255 but nothing else (they do not seem to go beyond ASCII).
    1              0.000016 syn match   rustCharacterInvalidUnicode   display contained /b'\zs[^[:cntrl:][:graph:][:alnum:][:space:]]\ze'/
    1              0.000038 syn match   rustCharacter   /b'\([^\\]\|\\\(.\|x\x\{2}\)\)'/ contains=rustEscape,rustEscapeError,rustCharacterInvalid,rustCharacterInvalidUnicode
    1              0.000036 syn match   rustCharacter   /'\([^\\]\|\\\(.\|x\x\{2}\|u{\x\{1,6}}\)\)'/ contains=rustEscape,rustEscapeUnicode,rustEscapeError,rustCharacterInvalid
                            
    1              0.000015 syn match rustShebang /\%^#![^[].*/
    1              0.000024 syn region rustCommentLine                                                  start="//"                      end="$"   contains=rustTodo,@Spell
    1              0.000027 syn region rustCommentLineDoc                                               start="//\%(//\@!\|!\)"         end="$"   contains=rustTodo,@Spell
    1              0.000026 syn region rustCommentLineDocError                                          start="//\%(//\@!\|!\)"         end="$"   contains=rustTodo,@Spell contained
    1              0.000038 syn region rustCommentBlock             matchgroup=rustCommentBlock         start="/\*\%(!\|\*[*/]\@!\)\@!" end="\*/" contains=rustTodo,rustCommentBlockNest,@Spell
    1              0.000044 syn region rustCommentBlockDoc          matchgroup=rustCommentBlockDoc      start="/\*\%(!\|\*[*/]\@!\)"    end="\*/" contains=rustTodo,rustCommentBlockDocNest,@Spell
    1              0.000033 syn region rustCommentBlockDocError     matchgroup=rustCommentBlockDocError start="/\*\%(!\|\*[*/]\@!\)"    end="\*/" contains=rustTodo,rustCommentBlockDocNestError,@Spell contained
    1              0.000029 syn region rustCommentBlockNest         matchgroup=rustCommentBlock         start="/\*"                     end="\*/" contains=rustTodo,rustCommentBlockNest,@Spell contained transparent
    1              0.000035 syn region rustCommentBlockDocNest      matchgroup=rustCommentBlockDoc      start="/\*"                     end="\*/" contains=rustTodo,rustCommentBlockDocNest,@Spell contained transparent
    1              0.000030 syn region rustCommentBlockDocNestError matchgroup=rustCommentBlockDocError start="/\*"                     end="\*/" contains=rustTodo,rustCommentBlockDocNestError,@Spell contained transparent
                            " FIXME: this is a really ugly and not fully correct implementation. Most
                            " importantly, a case like ``/* */*`` should have the final ``*`` not being in
                            " a comment, but in practice at present it leaves comments open two levels
                            " deep. But as long as you stay away from that particular case, I *believe*
                            " the highlighting is correct. Due to the way Vim's syntax engine works
                            " (greedy for start matches, unlike Rust's tokeniser which is searching for
                            " the earliest-starting match, start or end), I believe this cannot be solved.
                            " Oh you who would fix it, don't bother with things like duplicating the Block
                            " rules and putting ``\*\@<!`` at the start of them; it makes it worse, as
                            " then you must deal with cases like ``/*/**/*/``. And don't try making it
                            " worse with ``\%(/\@<!\*\)\@<!``, either...
                            
    1              0.000012 syn keyword rustTodo contained TODO FIXME XXX NB NOTE
                            
                            " Folding rules {{{2
                            " Trivial folding rules to begin with.
                            " FIXME: use the AST to make really good folding
    1              0.000021 syn region rustFoldBraces start="{" end="}" transparent fold
                            
                            " Default highlighting {{{1
    1              0.000009 hi def link rustDecNumber       rustNumber
    1              0.000007 hi def link rustHexNumber       rustNumber
    1              0.000006 hi def link rustOctNumber       rustNumber
    1              0.000006 hi def link rustBinNumber       rustNumber
    1              0.000008 hi def link rustIdentifierPrime rustIdentifier
    1              0.000007 hi def link rustTrait           rustType
    1              0.000008 hi def link rustDeriveTrait     rustTrait
                            
    1              0.000007 hi def link rustMacroRepeatCount   rustMacroRepeatDelimiters
    1              0.000018 hi def link rustMacroRepeatDelimiters   Macro
    1              0.000012 hi def link rustMacroVariable Define
    1              0.000012 hi def link rustSigil         StorageClass
    1              0.000012 hi def link rustEscape        Special
    1              0.000007 hi def link rustEscapeUnicode rustEscape
    1              0.000013 hi def link rustEscapeError   Error
    1              0.000012 hi def link rustStringContinuation Special
    1              0.000013 hi def link rustString        String
    1              0.000013 hi def link rustCharacterInvalid Error
    1              0.000007 hi def link rustCharacterInvalidUnicode rustCharacterInvalid
    1              0.000011 hi def link rustCharacter     Character
    1              0.000013 hi def link rustNumber        Number
    1              0.000012 hi def link rustBoolean       Boolean
    1              0.000007 hi def link rustEnum          rustType
    1              0.000009 hi def link rustEnumVariant   rustConstant
    1              0.000011 hi def link rustConstant      Constant
    1              0.000012 hi def link rustSelf          Constant
    1              0.000011 hi def link rustFloat         Float
    1              0.000007 hi def link rustArrowCharacter rustOperator
    1              0.000014 hi def link rustOperator      Operator
    1              0.000012 hi def link rustKeyword       Keyword
    1              0.000012 hi def link rustTypedef       Keyword " More precise is Typedef, but it doesn't feel right for Rust
    1              0.000012 hi def link rustStructure     Keyword " More precise is Structure
    1              0.000008 hi def link rustUnion         rustStructure
    1              0.000013 hi def link rustPubScopeDelim Delimiter
    1              0.000007 hi def link rustPubScopeCrate rustKeyword
    1              0.000007 hi def link rustSuper         rustKeyword
    1              0.000012 hi def link rustReservedKeyword Error
    1              0.000012 hi def link rustRepeat        Conditional
    1              0.000012 hi def link rustConditional   Conditional
    1              0.000014 hi def link rustIdentifier    Identifier
    1              0.000007 hi def link rustCapsIdent     rustIdentifier
    1              0.000011 hi def link rustModPath       Include
    1              0.000013 hi def link rustModPathSep    Delimiter
    1              0.000011 hi def link rustFunction      Function
    1              0.000012 hi def link rustFuncName      Function
    1              0.000011 hi def link rustFuncCall      Function
    1              0.000012 hi def link rustShebang       Comment
    1              0.000013 hi def link rustCommentLine   Comment
    1              0.000013 hi def link rustCommentLineDoc SpecialComment
    1              0.000014 hi def link rustCommentLineDocError Error
    1              0.000009 hi def link rustCommentBlock  rustCommentLine
    1              0.000009 hi def link rustCommentBlockDoc rustCommentLineDoc
    1              0.000013 hi def link rustCommentBlockDocError Error
    1              0.000012 hi def link rustAssert        PreCondit
    1              0.000012 hi def link rustPanic         PreCondit
    1              0.000014 hi def link rustMacro         Macro
    1              0.000013 hi def link rustType          Type
    1              0.000012 hi def link rustTodo          Todo
    1              0.000011 hi def link rustAttribute     PreProc
    1              0.000012 hi def link rustDerive        PreProc
    1              0.000012 hi def link rustDefault       StorageClass
    1              0.000012 hi def link rustStorage       StorageClass
    1              0.000012 hi def link rustObsoleteStorage Error
    1              0.000012 hi def link rustLifetime      Special
    1              0.000011 hi def link rustLabel         Label
    1              0.000013 hi def link rustInvalidBareKeyword Error
    1              0.000008 hi def link rustExternCrate   rustKeyword
    1              0.000013 hi def link rustObsoleteExternMod Error
    1              0.000014 hi def link rustBoxPlacementParens Delimiter
    1              0.000012 hi def link rustQuestionMark  Special
                            
                            " Other Suggestions:
                            " hi rustAttribute ctermfg=cyan
                            " hi rustDerive ctermfg=cyan
                            " hi rustAssert ctermfg=yellow
                            " hi rustPanic ctermfg=red
                            " hi rustMacro ctermfg=magenta
                            
    1              0.000006 syn sync minlines=200
    1              0.000004 syn sync maxlines=500
                            
    1              0.000013 let b:current_syntax = "rust"

SCRIPT  /usr/share/nvim/runtime/ftplugin/rust.vim
Sourced 1 time
Total time:   0.002430
 Self time:   0.002430

count  total (s)   self (s)
                            " Language:     Rust
                            " Description:  Vim ftplugin for Rust
                            " Maintainer:   Chris Morgan <me@chrismorgan.info>
                            " Maintainer:   Kevin Ballard <kevin@sb.org>
                            " Last Change:  June 08, 2016
                            " For bugs, patches and license go to https://github.com/rust-lang/rust.vim 
                            
    1              0.000065 if exists("b:did_ftplugin")
                            	finish
                            endif
    1              0.000034 let b:did_ftplugin = 1
                            
    1              0.000051 let s:save_cpo = &cpo
    1              0.000084 set cpo&vim
                            
    1              0.000056 augroup rust.vim
    1              0.001034 autocmd!
                            
                            " Variables {{{1
                            
                            " The rust source code at present seems to typically omit a leader on /*!
                            " comments, so we'll use that as our default, but make it easy to switch.
                            " This does not affect indentation at all (I tested it with and without
                            " leader), merely whether a leader is inserted by default or not.
    1              0.000065 if exists("g:rust_bang_comment_leader") && g:rust_bang_comment_leader != 0
                            	" Why is the `,s0:/*,mb:\ ,ex:*/` there, you ask? I don't understand why,
                            	" but without it, */ gets indented one space even if there were no
                            	" leaders. I'm fairly sure that's a Vim bug.
                            	setlocal comments=s1:/*,mb:*,ex:*/,s0:/*,mb:\ ,ex:*/,:///,://!,://
                            else
    1              0.000039 	setlocal comments=s0:/*!,m:\ ,ex:*/,s1:/*,mb:*,ex:*/,:///,://!,://
    1              0.000002 endif
    1              0.000007 setlocal commentstring=//%s
    1              0.000012 setlocal formatoptions-=t formatoptions+=croqnl
                            " j was only added in 7.3.541, so stop complaints about its nonexistence
    1              0.000007 silent! setlocal formatoptions+=j
                            
                            " smartindent will be overridden by indentexpr if filetype indent is on, but
                            " otherwise it's better than nothing.
    1              0.000017 setlocal smartindent nocindent
                            
    1              0.000010 if !exists("g:rust_recommended_style") || g:rust_recommended_style != 0
    1              0.000028 	setlocal tabstop=4 shiftwidth=4 softtabstop=4 expandtab
    1              0.000007 	setlocal textwidth=99
    1              0.000002 endif
                            
                            " This includeexpr isn't perfect, but it's a good start
    1              0.000007 setlocal includeexpr=substitute(v:fname,'::','/','g')
                            
    1              0.000006 setlocal suffixesadd=.rs
                            
    1              0.000007 if exists("g:ftplugin_rust_source_path")
                                let &l:path=g:ftplugin_rust_source_path . ',' . &l:path
                            endif
                            
    1              0.000006 if exists("g:loaded_delimitMate")
    1              0.000007 	if exists("b:delimitMate_excluded_regions")
                            		let b:rust_original_delimitMate_excluded_regions = b:delimitMate_excluded_regions
                            	endif
                            
    1              0.000013 	let s:delimitMate_extra_excluded_regions = ',rustLifetimeCandidate,rustGenericLifetimeCandidate'
                            
                            	" For this buffer, when delimitMate issues the `User delimitMate_map`
                            	" event in the autocommand system, add the above-defined extra excluded
                            	" regions to delimitMate's state, if they have not already been added.
    1              0.000037 	autocmd User <buffer>
                            		\ if expand('<afile>') ==# 'delimitMate_map' && match(
                            		\     delimitMate#Get("excluded_regions"),
                            		\     s:delimitMate_extra_excluded_regions) == -1
                            		\|  let b:delimitMate_excluded_regions =
                            		\       delimitMate#Get("excluded_regions")
                            		\       . s:delimitMate_extra_excluded_regions
                            		\|endif
                            
                            	" For this buffer, when delimitMate issues the `User delimitMate_unmap`
                            	" event in the autocommand system, delete the above-defined extra excluded
                            	" regions from delimitMate's state (the deletion being idempotent and
                            	" having no effect if the extra excluded regions are not present in the
                            	" targeted part of delimitMate's state).
    1              0.000027 	autocmd User <buffer>
                            		\ if expand('<afile>') ==# 'delimitMate_unmap'
                            		\|  let b:delimitMate_excluded_regions = substitute(
                            		\       delimitMate#Get("excluded_regions"),
                            		\       '\C\V' . s:delimitMate_extra_excluded_regions,
                            		\       '', 'g')
                            		\|endif
    1              0.000002 endif
                            
    1              0.000013 if has("folding") && exists('g:rust_fold') && g:rust_fold != 0
                            	let b:rust_set_foldmethod=1
                            	setlocal foldmethod=syntax
                            	if g:rust_fold == 2
                            		setlocal foldlevel<
                            	else
                            		setlocal foldlevel=99
                            	endif
                            endif
                            
    1              0.000008 if has('conceal') && exists('g:rust_conceal') && g:rust_conceal != 0
                            	let b:rust_set_conceallevel=1
                            	setlocal conceallevel=2
                            endif
                            
                            " Motion Commands {{{1
                            
                            " Bind motion commands to support hanging indents
    1              0.000054 nnoremap <silent> <buffer> [[ :call rust#Jump('n', 'Back')<CR>
    1              0.000027 nnoremap <silent> <buffer> ]] :call rust#Jump('n', 'Forward')<CR>
    1              0.000023 xnoremap <silent> <buffer> [[ :call rust#Jump('v', 'Back')<CR>
    1              0.000022 xnoremap <silent> <buffer> ]] :call rust#Jump('v', 'Forward')<CR>
    1              0.000022 onoremap <silent> <buffer> [[ :call rust#Jump('o', 'Back')<CR>
    1              0.000022 onoremap <silent> <buffer> ]] :call rust#Jump('o', 'Forward')<CR>
                            
                            " Commands {{{1
                            
                            " See |:RustRun| for docs
    1              0.000021 command! -nargs=* -complete=file -bang -buffer RustRun call rust#Run(<bang>0, <q-args>)
                            
                            " See |:RustExpand| for docs
    1              0.000017 command! -nargs=* -complete=customlist,rust#CompleteExpand -bang -buffer RustExpand call rust#Expand(<bang>0, <q-args>)
                            
                            " See |:RustEmitIr| for docs
    1              0.000011 command! -nargs=* -buffer RustEmitIr call rust#Emit("llvm-ir", <q-args>)
                            
                            " See |:RustEmitAsm| for docs
    1              0.000010 command! -nargs=* -buffer RustEmitAsm call rust#Emit("asm", <q-args>)
                            
                            " See |:RustPlay| for docs
    1              0.000026 command! -range=% RustPlay :call rust#Play(<count>, <line1>, <line2>, <f-args>)
                            
                            " See |:RustFmt| for docs
    1              0.000008 command! -buffer RustFmt call rustfmt#Format()
                            
                            " See |:RustFmtRange| for docs
    1              0.000015 command! -range -buffer RustFmtRange call rustfmt#FormatRange(<line1>, <line2>)
                            
                            " Mappings {{{1
                            
                            " Bind ⌘R in MacVim to :RustRun
    1              0.000024 nnoremap <silent> <buffer> <D-r> :RustRun<CR>
                            " Bind ⌘⇧R in MacVim to :RustRun! pre-filled with the last args
    1              0.000034 nnoremap <buffer> <D-R> :RustRun! <C-r>=join(b:rust_last_rustc_args)<CR><C-\>erust#AppendCmdLine(' -- ' . join(b:rust_last_args))<CR>
                            
    1              0.000011 if !exists("b:rust_last_rustc_args") || !exists("b:rust_last_args")
    1              0.000011 	let b:rust_last_rustc_args = []
    1              0.000005 	let b:rust_last_args = []
    1              0.000002 endif
                            
                            " Cleanup {{{1
                            
    1              0.000054 let b:undo_ftplugin = "
                            		\ setlocal formatoptions< comments< commentstring< includeexpr< suffixesadd<
                            		\|setlocal tabstop< shiftwidth< softtabstop< expandtab< textwidth<
                            		\|if exists('b:rust_original_delimitMate_excluded_regions')
                            		  \|let b:delimitMate_excluded_regions = b:rust_original_delimitMate_excluded_regions
                            		  \|unlet b:rust_original_delimitMate_excluded_regions
                            		\|else
                            		  \|unlet! b:delimitMate_excluded_regions
                            		\|endif
                            		\|if exists('b:rust_set_foldmethod')
                            		  \|setlocal foldmethod< foldlevel<
                            		  \|unlet b:rust_set_foldmethod
                            		\|endif
                            		\|if exists('b:rust_set_conceallevel')
                            		  \|setlocal conceallevel<
                            		  \|unlet b:rust_set_conceallevel
                            		\|endif
                            		\|unlet! b:rust_last_rustc_args b:rust_last_args
                            		\|delcommand RustRun
                            		\|delcommand RustExpand
                            		\|delcommand RustEmitIr
                            		\|delcommand RustEmitAsm
                            		\|delcommand RustPlay
                            		\|nunmap <buffer> <D-r>
                            		\|nunmap <buffer> <D-R>
                            		\|nunmap <buffer> [[
                            		\|nunmap <buffer> ]]
                            		\|xunmap <buffer> [[
                            		\|xunmap <buffer> ]]
                            		\|ounmap <buffer> [[
                            		\|ounmap <buffer> ]]
                            		\|set matchpairs-=<:>
                            		\"
                            
                            " }}}1
                            
                            " Code formatting on save
    1              0.000010 if get(g:, "rustfmt_autosave", 0)
                            	autocmd BufWritePre *.rs silent! call rustfmt#Format()
                            endif
                            
    1              0.000002 augroup END
                            
    1              0.000020 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: set noet sw=8 ts=8:

SCRIPT  /usr/share/nvim/runtime/indent/rust.vim
Sourced 1 time
Total time:   0.000218
 Self time:   0.000218

count  total (s)   self (s)
                            " Vim indent file
                            " Language:         Rust
                            " Author:           Chris Morgan <me@chrismorgan.info>
                            " Last Change:      2017 Jun 13
                            " For bugs, patches and license go to https://github.com/rust-lang/rust.vim
                            
                            " Only load this indent file when no other was loaded.
    1              0.000018 if exists("b:did_indent")
                            	finish
                            endif
    1              0.000009 let b:did_indent = 1
                            
    1              0.000019 setlocal cindent
    1              0.000015 setlocal cinoptions=L0,(0,Ws,J1,j1
    1              0.000024 setlocal cinkeys=0{,0},!^F,o,O,0[,0]
                            " Don't think cinwords will actually do anything at all... never mind
    1              0.000012 setlocal cinwords=for,if,else,while,loop,impl,mod,unsafe,trait,struct,enum,fn,extern
                            
                            " Some preliminary settings
    1              0.000038 setlocal nolisp		" Make sure lisp indenting doesn't supersede us
    1              0.000006 setlocal autoindent	" indentexpr isn't much help otherwise
                            " Also do indentkeys, otherwise # gets shoved to column 0 :-/
    1              0.000007 setlocal indentkeys=0{,0},!^F,o,O,0[,0]
                            
    1              0.000005 setlocal indentexpr=GetRustIndent(v:lnum)
                            
                            " Only define the function once.
    1              0.000010 if exists("*GetRustIndent")
    1              0.000003 	finish
                            endif
                            
                            let s:save_cpo = &cpo
                            set cpo&vim
                            
                            " Come here when loading the script the first time.
                            
                            function! s:get_line_trimmed(lnum)
                            	" Get the line and remove a trailing comment.
                            	" Use syntax highlighting attributes when possible.
                            	" NOTE: this is not accurate; /* */ or a line continuation could trick it
                            	let line = getline(a:lnum)
                            	let line_len = strlen(line)
                            	if has('syntax_items')
                            		" If the last character in the line is a comment, do a binary search for
                            		" the start of the comment.  synID() is slow, a linear search would take
                            		" too long on a long line.
                            		if synIDattr(synID(a:lnum, line_len, 1), "name") =~ 'Comment\|Todo'
                            			let min = 1
                            			let max = line_len
                            			while min < max
                            				let col = (min + max) / 2
                            				if synIDattr(synID(a:lnum, col, 1), "name") =~ 'Comment\|Todo'
                            					let max = col
                            				else
                            					let min = col + 1
                            				endif
                            			endwhile
                            			let line = strpart(line, 0, min - 1)
                            		endif
                            		return substitute(line, "\s*$", "", "")
                            	else
                            		" Sorry, this is not complete, nor fully correct (e.g. string "//").
                            		" Such is life.
                            		return substitute(line, "\s*//.*$", "", "")
                            	endif
                            endfunction
                            
                            function! s:is_string_comment(lnum, col)
                            	if has('syntax_items')
                            		for id in synstack(a:lnum, a:col)
                            			let synname = synIDattr(id, "name")
                            			if synname == "rustString" || synname =~ "^rustComment"
                            				return 1
                            			endif
                            		endfor
                            	else
                            		" without syntax, let's not even try
                            		return 0
                            	endif
                            endfunction
                            
                            function GetRustIndent(lnum)
                            
                            	" Starting assumption: cindent (called at the end) will do it right
                            	" normally. We just want to fix up a few cases.
                            
                            	let line = getline(a:lnum)
                            
                            	if has('syntax_items')
                            		let synname = synIDattr(synID(a:lnum, 1, 1), "name")
                            		if synname == "rustString"
                            			" If the start of the line is in a string, don't change the indent
                            			return -1
                            		elseif synname =~ '\(Comment\|Todo\)'
                            					\ && line !~ '^\s*/\*'  " not /* opening line
                            			if synname =~ "CommentML" " multi-line
                            				if line !~ '^\s*\*' && getline(a:lnum - 1) =~ '^\s*/\*'
                            					" This is (hopefully) the line after a /*, and it has no
                            					" leader, so the correct indentation is that of the
                            					" previous line.
                            					return GetRustIndent(a:lnum - 1)
                            				endif
                            			endif
                            			" If it's in a comment, let cindent take care of it now. This is
                            			" for cases like "/*" where the next line should start " * ", not
                            			" "* " as the code below would otherwise cause for module scope
                            			" Fun fact: "  /*\n*\n*/" takes two calls to get right!
                            			return cindent(a:lnum)
                            		endif
                            	endif
                            
                            	" cindent gets second and subsequent match patterns/struct members wrong,
                            	" as it treats the comma as indicating an unfinished statement::
                            	"
                            	" match a {
                            	"     b => c,
                            	"         d => e,
                            	"         f => g,
                            	" };
                            
                            	" Search backwards for the previous non-empty line.
                            	let prevlinenum = prevnonblank(a:lnum - 1)
                            	let prevline = s:get_line_trimmed(prevlinenum)
                            	while prevlinenum > 1 && prevline !~ '[^[:blank:]]'
                            		let prevlinenum = prevnonblank(prevlinenum - 1)
                            		let prevline = s:get_line_trimmed(prevlinenum)
                            	endwhile
                            
                            	" Handle where clauses nicely: subsequent values should line up nicely.
                            	if prevline[len(prevline) - 1] == ","
                            				\ && prevline =~# '^\s*where\s'
                            		return indent(prevlinenum) + 6
                            	endif
                            
                            	if prevline[len(prevline) - 1] == ","
                            				\ && s:get_line_trimmed(a:lnum) !~ '^\s*[\[\]{}]'
                            				\ && prevline !~ '^\s*fn\s'
                            				\ && prevline !~ '([^()]\+,$'
                            				\ && s:get_line_trimmed(a:lnum) !~ '^\s*\S\+\s*=>'
                            		" Oh ho! The previous line ended in a comma! I bet cindent will try to
                            		" take this too far... For now, let's normally use the previous line's
                            		" indent.
                            
                            		" One case where this doesn't work out is where *this* line contains
                            		" square or curly brackets; then we normally *do* want to be indenting
                            		" further.
                            		"
                            		" Another case where we don't want to is one like a function
                            		" definition with arguments spread over multiple lines:
                            		"
                            		" fn foo(baz: Baz,
                            		"        baz: Baz) // <-- cindent gets this right by itself
                            		"
                            		" Another case is similar to the previous, except calling a function
                            		" instead of defining it, or any conditional expression that leaves
                            		" an open paren:
                            		"
                            		" foo(baz,
                            		"     baz);
                            		"
                            		" if baz && (foo ||
                            		"            bar) {
                            		"
                            		" Another case is when the current line is a new match arm.
                            		"
                            		" There are probably other cases where we don't want to do this as
                            		" well. Add them as needed.
                            		return indent(prevlinenum)
                            	endif
                            
                            	if !has("patch-7.4.355")
                            		" cindent before 7.4.355 doesn't do the module scope well at all; e.g.::
                            		"
                            		" static FOO : &'static [bool] = [
                            		" true,
                            		"	 false,
                            		"	 false,
                            		"	 true,
                            		"	 ];
                            		"
                            		"	 uh oh, next statement is indented further!
                            
                            		" Note that this does *not* apply the line continuation pattern properly;
                            		" that's too hard to do correctly for my liking at present, so I'll just
                            		" start with these two main cases (square brackets and not returning to
                            		" column zero)
                            
                            		call cursor(a:lnum, 1)
                            		if searchpair('{\|(', '', '}\|)', 'nbW',
                            					\ 's:is_string_comment(line("."), col("."))') == 0
                            			if searchpair('\[', '', '\]', 'nbW',
                            						\ 's:is_string_comment(line("."), col("."))') == 0
                            				" Global scope, should be zero
                            				return 0
                            			else
                            				" At the module scope, inside square brackets only
                            				"if getline(a:lnum)[0] == ']' || search('\[', '', '\]', 'nW') == a:lnum
                            				if line =~ "^\\s*]"
                            					" It's the closing line, dedent it
                            					return 0
                            				else
                            					return shiftwidth()
                            				endif
                            			endif
                            		endif
                            	endif
                            
                            	" Fall back on cindent, which does it mostly right
                            	return cindent(a:lnum)
                            endfunction
                            
                            let &cpo = s:save_cpo
                            unlet s:save_cpo

FUNCTION  airline#extensions#languageclient#get_error()
Called 3068 times
Total time:  82.279873
 Self time:   0.038490

count  total (s)   self (s)
 3068  82.276673   0.035290   return airline#extensions#languageclient#get(s:severity_error)

FUNCTION  FugitiveExtractGitDir()
Called 1 time
Total time:   0.001121
 Self time:   0.000796

count  total (s)   self (s)
    1   0.000029   0.000019   let path = s:Slash(a:path)
    1              0.000011   if path =~# '^fugitive:'
                                return matchstr(path, '\C^fugitive:\%(//\)\=\zs.\{-\}\ze\%(//\|::\|$\)')
                              elseif isdirectory(path)
                                let path = fnamemodify(path, ':p:s?/$??')
                              else
    1              0.000088     let path = fnamemodify(path, ':p:h:s?/$??')
    1              0.000001   endif
    1              0.000022   let pre = substitute(matchstr(path, '^\a\a\+\ze:'), '^.', '\u&', '')
    1              0.000004   if len(pre) && exists('*' . pre . 'Real')
                                let path = s:Slash({pre}Real(path))
                              endif
    1              0.000042   let root = resolve(path)
    1              0.000002   if root !=# path
                                silent! exe haslocaldir() ? 'lcd .' : 'cd .'
                              endif
    1              0.000001   let previous = ""
    3              0.000008   while root !=# previous
    3              0.000027     if root =~# '\v^//%([^/]+/?)?$'
                                  break
                                endif
    3              0.000030     if index(split($GIT_CEILING_DIRECTORIES, ':'), root) >= 0
                                  break
                                endif
    3              0.000006     if root ==# $GIT_WORK_TREE && FugitiveIsGitDir($GIT_DIR)
                                  return simplify(fnamemodify($GIT_DIR, ':p:s?[\/]$??'))
                                endif
    3   0.000074   0.000031     if FugitiveIsGitDir($GIT_DIR)
                                  call FugitiveWorkTree(simplify(fnamemodify($GIT_DIR, ':p:s?[\/]$??')))
                                  if has_key(s:dir_for_worktree, root)
                                    return s:dir_for_worktree[root]
                                  endif
                                endif
    3              0.000023     let dir = substitute(root, '[\/]$', '', '') . '/.git'
    3              0.000259     let type = getftype(dir)
    3   0.000131   0.000013     if type ==# 'dir' && FugitiveIsGitDir(dir)
    1              0.000002       return dir
                                elseif type ==# 'link' && FugitiveIsGitDir(dir)
                                  return resolve(dir)
                                elseif type !=# '' && filereadable(dir)
                                  let line = get(readfile(dir, '', 1), 0, '')
                                  if line =~# '^gitdir: \.' && FugitiveIsGitDir(root.'/'.line[8:-1])
                                    return simplify(root.'/'.line[8:-1])
                                  elseif line =~# '^gitdir: ' && FugitiveIsGitDir(line[8:-1])
                                    return line[8:-1]
                                  endif
                                elseif FugitiveIsGitDir(root)
                                  return root
                                endif
    2              0.000004     let previous = root
    2              0.000005     let root = fnamemodify(root, ':h')
    2              0.000001   endwhile
                              return ''

FUNCTION  <SNR>134_obsolete_gitgutter_signs_to_remove()
Called 18 times
Total time:   0.006031
 Self time:   0.005713

count  total (s)   self (s)
   18              0.000079   let signs_to_remove = []  " list of [<id (number)>, ...]
   18              0.000044   let remove_all_signs = 1
   18   0.000485   0.000167   let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
  447              0.000850   for line_number in keys(old_gitgutter_signs)
  429              0.001543     if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
  136              0.000395       call add(signs_to_remove, old_gitgutter_signs[line_number].id)
  136              0.000078     else
  293              0.000468       let remove_all_signs = 0
  293              0.000203     endif
  429              0.000299   endfor
   18              0.000072   let s:remove_all_old_signs = remove_all_signs
   18              0.000044   return signs_to_remove

FUNCTION  deoplete#util#get_prev_event()
Called 226 times
Total time:   0.001986
 Self time:   0.001986

count  total (s)   self (s)
  226              0.001769   return get(g:deoplete#_context, 'event', '')

FUNCTION  <SNR>47_filename()
Called 1 time
Total time:   0.000058
 Self time:   0.000003

count  total (s)   self (s)
    1   0.000058   0.000003   return fnamemodify(s:abs_path(a:bufnr, 0), ':t')

FUNCTION  airline#extensions#languageclient#get_warning()
Called 3068 times
Total time:  86.916006
 Self time:   0.040027

count  total (s)   self (s)
 3068  86.912578   0.036599   return airline#extensions#languageclient#get(s:severity_warning)

FUNCTION  1()
Called 41 times
Total time:   0.122161
 Self time:   0.002956

count  total (s)   self (s)
                                " Append file?  (defaults to jobinfo.file_mode, project/global makers should set it to 0)
   41   0.051653   0.000830     let append_file = neomake#utils#GetSetting('append_file', self, a:jobinfo.file_mode, a:jobinfo.ft, a:jobinfo.bufnr)
                                " Use/generate a filename?  (defaults to 1 if tempfile_name is set)
   41   0.069638   0.001256     let uses_filename = append_file || neomake#utils#GetSetting('uses_filename', self, has_key(self, 'tempfile_name'), a:jobinfo.ft, a:jobinfo.bufnr)
   41              0.000154     if append_file || uses_filename
                                    let filename = self._get_fname_for_buffer(a:jobinfo)
                                    if append_file
                                        return filename
                                    endif
                                endif
   41              0.000083     return ''

FUNCTION  <SNR>17_LoadFTPlugin()
Called 1 time
Total time:   0.005810
 Self time:   0.003290

count  total (s)   self (s)
    1              0.000008     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
                                endif
                            
    1              0.000008     let s = expand("<amatch>")
    1              0.000003     if s != ""
    1              0.000018       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    2              0.000019       for name in split(s, '\.')
    1   0.005710   0.003189 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
    1              0.000008       endfor
    1              0.000002     endif

FUNCTION  <SNR>93_check_mixed_indent_file()
Called 6 times
Total time:   0.000609
 Self time:   0.000609

count  total (s)   self (s)
    6              0.000079   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'arduino', 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
    6              0.000062   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
                                let head_spc = '\v(^ +\*@!)'
                              else
    6              0.000021     let head_spc = '\v(^ +)'
    6              0.000008   endif
    6              0.000156   let indent_tabs = search('\v(^\t+)', 'nw')
    6              0.000155   let indent_spc  = search(head_spc, 'nw')
    6              0.000025   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
                              else
    6              0.000009     return ''
                              endif

FUNCTION  deoplete#handler#_async_timer_start()
Called 112 times
Total time:   0.027063
 Self time:   0.014367

count  total (s)   self (s)
  112              0.002443   if exists('s:async_timer')
   42   0.002009   0.000830     call deoplete#handler#_async_timer_stop()
   42              0.000048   endif
                            
  112   0.014879   0.003363   let delay = deoplete#custom#_get_option('auto_refresh_delay')
  112              0.000524   if delay <= 0
                                return
                              endif
                            
  112              0.001273   let s:async_timer = { 'event': 'Async', 'changedtick': b:changedtick }
  112              0.003810   let s:async_timer.id = timer_start( max([20, delay]), function('s:completion_async'), {'repeat': -1})

FUNCTION  <SNR>90_update_git_branch()
Called 3068 times
Total time: 213.336901
 Self time:   0.182067

count  total (s)   self (s)
 3068   0.053232   0.025974   if !airline#util#has_fugitive()
                                let s:vcs_config['git'].branch = ''
                                return
                              endif
                            
 3068 213.200872   0.073295   let s:vcs_config['git'].branch = exists("*FugitiveHead") ? FugitiveHead(s:sha1size) : fugitive#head(s:sha1size)
 3068              0.029930   if s:vcs_config['git'].branch is# 'master' && winwidth(0) < 81
                                " Shorten default a bit
                                let s:vcs_config['git'].branch='mas'
                              endif

FUNCTION  <SNR>118_OnInsertChar()
Called 323 times
Total time:   0.053625
 Self time:   0.010894

count  total (s)   self (s)
  323   0.042180   0.003757   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
  323              0.002315   call timer_stop( s:pollers.completion.id )
  323   0.007503   0.003195   call s:CloseCompletionMenu()

FUNCTION  <SNR>82_MakeJob()
Called 41 times
Total time:   0.384397
 Self time:   0.154756

count  total (s)   self (s)
   41              0.000218     let job_id = s:job_id
   41              0.000414     let s:job_id += 1
                            
                                " Optional:
                                "  - serialize (default: 0 for async (and get_list_entries),
                                "                        1 for non-async)
                                "  - serialize_abort_on_error (default: 0)
                                "  - exit_callback (string/function, default: 0)
   41              0.002968     let jobinfo = extend(copy(g:neomake#jobinfo#base), extend({ 'id': job_id, 'name': empty(get(a:options.maker, 'name', '')) ? 'neomake_'.job_id : a:options.maker.name, 'maker': a:options.maker, 'bufnr': a:options.bufnr, 'file_mode': a:options.file_mode, 'ft': a:options.ft, 'cwd': s:make_info[a:options.make_id].cwd, }, a:options))
                            
   41              0.000180     let maker = jobinfo.maker
                            
   41              0.000219     if has_key(maker, 'get_list_entries')
                                    call neomake#log#info(printf( '%s: getting entries via get_list_entries.', maker.name), jobinfo)
                                    let s:jobs[jobinfo.id] = jobinfo
                                    let s:make_info[a:make_id].active_jobs += [jobinfo]
                                    call s:handle_get_list_entries(jobinfo)
                                    return jobinfo
                                endif
                            
   41              0.000696     call extend(jobinfo, { 'output_stream': a:options.maker.output_stream, 'buffer_output': a:options.maker.buffer_output, }, 'keep')
                            
   41              0.000136     let error = ''
   41              0.000110     try
                                    " Change to job's cwd (before args, for relative filename).
   41   0.081209   0.000662         let cd_error = jobinfo.cd()
   41              0.000173         if !empty(cd_error)
                                        throw printf("Neomake: %s: could not change to maker's cwd (%s): %s.", maker.name, jobinfo.cd_from_setting, cd_error)
                                    endif
   41   0.134989   0.000800         let jobinfo.argv = maker._get_argv(jobinfo)
                            
   41   0.002016   0.000696         call neomake#utils#hook('NeomakeJobInit', {'jobinfo': jobinfo})
                            
   41              0.000252         let start_msg = s:async ? 'Starting async job' : 'Starting'
   41              0.000240         if type(jobinfo.argv) == type('')
                                        let start_msg .= ' [string]: '.jobinfo.argv
                                    else
   41   0.005006   0.002055             let start_msg .= ': '.join(map(copy(jobinfo.argv), 'neomake#utils#shellescape(v:val)'))
   41              0.000071         endif
   41   0.004718   0.000546         call neomake#log#info(start_msg.'.', jobinfo)
                            
   41              0.000161         let cwd = jobinfo.cwd
   41              0.000226         let changed = !empty(jobinfo.cd_back_cmd)
   41              0.000077         if changed
                                        call neomake#log#debug('cwd: '.cwd.' (changed).', jobinfo)
                                    else
   41   0.004093   0.000512             call neomake#log#debug('cwd: '.cwd.'.', jobinfo)
   41              0.000056         endif
                            
   41              0.000153         let base_job_opts = {}
   41              0.000168         if has_key(jobinfo, 'filename')
                                        if s:can_use_env_in_job_opts
                                            let base_job_opts = { 'env': {   'NEOMAKE_FILE': jobinfo.filename }}
                                        else
                                            let save_env_file = exists('$NEOMAKE_FILE') ? $NEOMAKE_FILE : s:unset
                                            let $NEOMAKE_FILE = jobinfo.filename
                                        endif
                                    endif
                            
                                    " Lock maker to make sure it does not get changed accidentally, but
                                    " only with depth=1, so that a postprocess object can change itself.
   41              0.000216         lockvar 1 maker
   41              0.000087         if s:async
   41              0.000357             if has('nvim')
   41              0.000109                 if jobinfo.buffer_output
   41              0.000741                     let opts = extend(base_job_opts, { 'stdout_buffered': 1, 'stderr_buffered': 1, })
   41              0.000160                     if s:nvim_can_buffer_output == 1
   41              0.000508                         let opts.on_exit = function('s:nvim_exit_handler_buffered')
   41              0.000067                     else
                                                    call extend(opts, { 'on_stdout': function('s:nvim_output_handler'), 'on_stderr': function('s:nvim_output_handler'), })
                                                    let opts.on_exit = function('s:nvim_exit_handler')
                                                endif
   41              0.000238                     let jobinfo.jobstart_opts = opts
   41              0.000053                 else
                                                let opts = { 'on_stdout': function('s:nvim_output_handler'), 'on_stderr': function('s:nvim_output_handler'), 'on_exit': function('s:nvim_exit_handler'), }
                                            endif
   41              0.000176                 if has_key(maker, 'nvim_job_opts')
                                                call extend(opts, maker.nvim_job_opts)
                                            endif
   41              0.000517                 if !has('nvim-0.3.0') && !neomake#utils#IsRunningWindows() && !has_key(opts, 'detach') && !has_key(opts, 'pty')
                                                " Always use detach to trigger setsid() with older Neovim.
                                                let opts.detach = 1
                                            endif
   41              0.000118                 try
   41              0.117564                     let job = jobstart(jobinfo.argv, opts)
   41              0.000306                 catch
                                                let error = printf('Failed to start Neovim job: %s: %s.', string(jobinfo.argv), v:exception)
                                            endtry
   41              0.000235                 if empty(error)
   41              0.000131                     if job == 0
                                                    let error = printf('Failed to start Neovim job: %s: %s.', 'Job table is full or invalid arguments given', string(jobinfo.argv))
                                                elseif job == -1
                                                    let error = printf('Failed to start Neovim job: %s: %s.', 'Executable not found', string(jobinfo.argv))
                                                else
   41              0.000743                         let s:map_job_ids[job] = jobinfo.id
   41              0.000282                         let jobinfo.nvim_job = job
   41              0.000331                         let s:jobs[jobinfo.id] = jobinfo
                            
   41              0.000507                         if get(jobinfo, 'uses_stdin', 0)
                                                        call jobsend(job, s:make_info[a:make_id].buffer_lines)
                                                        call jobclose(job, 'stdin')
                                                    endif
   41              0.000051                     endif
   41              0.000048                 endif
   41              0.000045             else
                                            " vim-async.
                                            let opts = extend(base_job_opts, { 'out_cb': function('s:vim_output_handler_stdout'), 'err_cb': function('s:vim_output_handler_stderr'), 'close_cb': function('s:vim_exit_handler'), 'mode': 'raw', })
                                            if has_key(maker, 'vim_job_opts')
                                                call extend(opts, maker.vim_job_opts)
                                            endif
                                            try
                                                let job = job_start(jobinfo.argv, opts)
                                                " Get this as early as possible!
                                                let channel_id = ch_info(job)['id']
                                            catch
                                                " NOTE: not covered in tests. Vim seems to always return
                                                " a job. Might be able to trigger this using custom opts?!
                                                let error = printf('Failed to start Vim job: %s: %s.', jobinfo.argv, v:exception)
                                            endtry
                                            if empty(error)
                                                let jobinfo.vim_job = job
                                                let s:map_job_ids[channel_id] = jobinfo.id
                                                let s:jobs[jobinfo.id] = jobinfo
                                                call neomake#log#debug(printf('Vim job: %s.', string(job_info(job))), jobinfo)
                                                call neomake#log#debug(printf('Vim channel: %s.', string(ch_info(job))), jobinfo)
                            
                                                if get(jobinfo, 'uses_stdin', 0)
                                                    call ch_sendraw(job, join(s:make_info[a:make_id].buffer_lines, "\n"))
                                                    call ch_close_in(job)
                                                endif
                                            endif
                                        endif
                            
                                        " Bail out on errors.
   41              0.000156             if !empty(error)
                                            throw 'Neomake: '.error
                                        endif
                            
   41   0.004078   0.001859             call neomake#utils#hook('NeomakeJobStarted', {'jobinfo': jobinfo})
   41              0.000061         else
                                        " vim-sync.
                                        " Use a temporary file to capture stderr.
                                        let stderr_file = tempname()
                                        let argv = jobinfo.argv . ' 2>'.stderr_file
                            
                                        try
                                            if get(jobinfo, 'uses_stdin', 0)
                                                " Pass stdin to system(), but only if non-empty.
                                                " Otherwise it might cause E677 (vim74-trusty at least).
                                                let stdin = join(s:make_info[a:make_id].buffer_lines, "\n")
                                                if !empty(stdin)
                                                    let output = system(argv, stdin)
                                                else
                                                    let output = system(argv)
                                                endif
                                            else
                                                let output = system(argv)
                                            endif
                                        catch /^Vim(let):E484:/
                                            throw printf('Neomake: Could not run %s: %s.', argv, v:exception)
                                        endtry
                            
                                        let jobinfo.id = job_id
                                        let s:jobs[job_id] = jobinfo
                                        let s:make_info[a:make_id].active_jobs += [jobinfo]
                            
                                        call s:output_handler(jobinfo, split(output, '\r\?\n', 1), 'stdout', 0)
                                        let stderr_output = readfile(stderr_file)
                                        if !empty(stderr_output)
                                            call s:output_handler(jobinfo, stderr_output, 'stderr', 1)
                                        endif
                                        call delete(stderr_file)
                            
                                        call s:exit_handler(jobinfo, v:shell_error)
                                        return jobinfo
                                    endif
   41              0.000099     finally
   41   0.001372   0.000711         call jobinfo.cd_back()
   41              0.000179         if exists('save_env_file')
                                        call s:restore_env('NEOMAKE_FILE', save_env_file)
                                    endif
   41              0.000069     endtry
   41              0.000687     let s:make_info[a:make_id].active_jobs += [jobinfo]
   41              0.000219     return jobinfo

FUNCTION  neomake#CancelJob()
Called 31 times
Total time:   0.008045
 Self time:   0.004388

count  total (s)   self (s)
   31              0.000207     let job_id = type(a:job_id) == type({}) ? a:job_id.id : +a:job_id
   31              0.000079     let remove_always = a:0 ? a:1 : 0
   31              0.000105     let jobinfo = get(s:jobs, job_id, {})
   31   0.001597   0.000179     call neomake#log#debug('Cancelling job.', jobinfo)
                            
   31   0.001045   0.000297     call neomake#action_queue#clean(empty(jobinfo) ? {'id': job_id} : jobinfo)
                            
   31              0.000053     if empty(jobinfo)
                                    call neomake#log#error('CancelJob: job not found: '.job_id.'.')
                                    return 0
                                endif
                            
   31              0.000073     if get(jobinfo, 'canceled', 0)
    1   0.000140   0.000020         call neomake#log#info('Job was canceled already.', jobinfo)
    1              0.000004         if remove_always
                                        call s:CleanJobinfo(jobinfo)
                                    endif
    1              0.000002         return 0
                                endif
                            
   30              0.000045     let ret = 0
   30              0.000057     if get(jobinfo, 'finished')
                                    call neomake#log#debug('Removing already finished job.', jobinfo)
                                elseif has_key(jobinfo, 'exit_code')
                                    call neomake#log#debug('Job exited already.', jobinfo)
                                elseif s:async
   30              0.000235         let job = has('nvim') ? jobinfo.nvim_job : jobinfo.vim_job
   30   0.001597   0.000224         call neomake#log#debug(printf('Stopping job: %s.', job), jobinfo)
   30              0.000094         if has('nvim')
   30              0.000049             try
   30              0.000812                 call jobstop(job)
   30              0.000073                 let ret = 1
   30              0.000059             catch /^Vim\%((\a\+)\)\=:\(E474\|E900\):/
                                            call neomake#log#info(printf( 'jobstop failed: %s.', v:exception), jobinfo)
                                        endtry
   30              0.000022         else
                                        " Use ch_status here, since job_status might be 'dead' already,
                                        " without the exit handler being called yet.
                                        if job_status(job) !=# 'run'
                                            call neomake#log#info( 'job_stop: job was not running anymore.', jobinfo)
                                        else
                                            " NOTE: might be "dead" already, but that is fine.
                                            call job_stop(job)
                                            let ret = 1
                                            if job_status(job) ==# 'run'
                                                let timer = timer_start(1000, function('s:kill_vimjob_cb'))
                                                let s:kill_vim_timers[timer] = jobinfo
                                            endif
                                        endif
                                    endif
   30              0.000021     endif
   30              0.000069     let jobinfo.canceled = 1
                            
   30              0.000068     if ret == 0 || remove_always
                                    call s:CleanJobinfo(jobinfo)
                                endif
   30              0.000038     return ret

FUNCTION  <SNR>118_CloseCompletionMenu()
Called 518 times
Total time:   0.006757
 Self time:   0.005949

count  total (s)   self (s)
  518              0.001844   if pumvisible()
   51   0.001410   0.000602     call s:SendKeys( "\<C-e>" )
   51              0.000111   endif

FUNCTION  <SNR>68_init()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000001   if s:airline_initialized
    1              0.000001     return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:theme_in_vimrc = exists('g:airline_theme')
                              if s:theme_in_vimrc
                                try
                                  let palette = g:airline#themes#{g:airline_theme}#palette
                                catch
                                  call airline#util#warning(printf('Could not resolve airline theme "%s". Themes have been migrated to github.com/vim-airline/vim-airline-themes.', g:airline_theme))
                                  let g:airline_theme = 'dark'
                                endtry
                                silent call airline#switch_theme(g:airline_theme)
                              else
                                let g:airline_theme = 'dark'
                                silent call s:on_colorscheme_changed()
                              endif
                            
                              call airline#util#doautocmd('AirlineAfterInit')

FUNCTION  gitgutter#process_buffer()
Called 45 times
Total time:   2.701159
 Self time:   0.006172

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
   45   0.642692   0.000797   if gitgutter#utility#is_active(a:bufnr)
   45   0.002901   0.000833     if a:force || s:has_fresh_changes(a:bufnr)
                            
   19              0.000087       let diff = ''
   19              0.000077       try
   19   2.052253   0.001228         let diff = gitgutter#diff#run_diff(a:bufnr, 0)
   19              0.000137       catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
                                  endtry
                            
   19              0.000112       if diff != 'async'
                                    call gitgutter#diff#handler(a:bufnr, diff)
                                  endif
                            
   19              0.000026     endif
   45              0.000073   endif

FUNCTION  <SNR>31_get()
Called 68 times
Total time:   0.001651
 Self time:   0.000354

count  total (s)   self (s)
   68   0.001629   0.000332   return call('delimitMate#Get', a:000)

FUNCTION  <SNR>106_get_accented_line()
Called 224 times
Total time:   0.015222
 Self time:   0.015222

count  total (s)   self (s)
  224              0.000445   if a:self._context.active
                                " active window
  224              0.000497     let contents = []
  224              0.002654     let content_parts = split(a:contents, '__accent')
  536              0.000861     for cpart in content_parts
  312              0.004140       let accent = matchstr(cpart, '_\zs[^#]*\ze')
  312              0.000892       call add(contents, cpart)
  312              0.000343     endfor
  224              0.001081     let line = join(contents, a:group)
  224              0.001534     let line = substitute(line, '__restore__', a:group, 'g')
  224              0.000171   else
                                " inactive window
                                let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
                                let line = substitute(line, '%#__restore__#', '', 'g')
                              endif
  224              0.000273   return line

FUNCTION  <SNR>137_InitBufHighlights()
Called 1 time
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000003         if !bufexists(a:buf)
                                        " The buffer might be wiped by now: prevent 'Invalid buffer id'.
                                        return
                                    endif
    1              0.000002         if has_key(s:highlights[a:type], a:buf)
                                        call nvim_buf_clear_highlight(a:buf, s:highlights[a:type][a:buf], 0, -1)
                                    else
    1              0.000008             let s:highlights[a:type][a:buf] = nvim_buf_add_highlight(a:buf, 0, '', 0, 0, -1)
    1              0.000001         endif

FUNCTION  airline#extensions#neomake#get_errors()
Called 3068 times
Total time:   0.229553
 Self time:   0.063639

count  total (s)   self (s)
 3068   0.197334   0.031419   let counts = s:get_counts()
 3068              0.016977   let errors = get(counts, 'E', 0)
 3068              0.011192   return errors ? s:error_symbol.errors : ''

FUNCTION  neomake#utils#redir()
Called 2 times
Total time:   0.000168
 Self time:   0.000168

count  total (s)   self (s)
                                " @vimlint(EVL108, 1)
    2              0.000035     if exists('*execute') && has('nvim-0.2.0')
                                " @vimlint(EVL108, 0)
                                    " NOTE: require Neovim, since Vim has at least an issue when using
                                    "       this in a :command-completion function.
                                    "       Ref: https://github.com/neomake/neomake/issues/650.
                                    "       Neovim 0.1.7 also parses 'highlight' wrongly.
    2              0.000121         return execute(a:cmd)
                                endif
                                if type(a:cmd) == type([])
                                    let r = ''
                                    for cmd in a:cmd
                                        let r .= neomake#utils#redir(cmd)
                                    endfor
                                    return r
                                endif
                                try
                                    redir => neomake_redir
                                    silent exe a:cmd
                                catch /^Vim(redir):E121:/
                                    throw printf('Neomake: neomake#utils#redir: called with outer :redir (error: %s).', v:exception)
                                finally
                                    redir END
                                endtry
                                return neomake_redir

FUNCTION  <SNR>32_get_syn_name()
Called 30 times
Total time:   0.006079
 Self time:   0.006079

count  total (s)   self (s)
   30              0.000279   let col = col('.')
   30              0.000169   if  col == col('$')
   13              0.000064     let col = col - 1
   13              0.000030   endif
   30              0.005373   return synIDattr(synIDtrans(synID(line('.'), col, 1)), 'name')

FUNCTION  deoplete#handler#_async_timer_stop()
Called 150 times
Total time:   0.004285
 Self time:   0.004285

count  total (s)   self (s)
  150              0.001254   if exists('s:async_timer')
  112              0.001184     call timer_stop(s:async_timer.id)
  112              0.000769     unlet s:async_timer
  112              0.000246   endif

FUNCTION  <SNR>110_PlatformSlash()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000002   if exists('+shellslash') && !&shellslash
                                return tr(a:path, '/', '\')
                              else
    1              0.000001     return a:path
                              endif

FUNCTION  <SNR>82_output_handler()
Called 82 times
Total time:   0.013438
 Self time:   0.006691

count  total (s)   self (s)
   82              0.000163     let jobinfo = a:jobinfo
   82   0.007067   0.003056     call neomake#log#debug(printf('%s: %s: %s.', a:event_type, jobinfo.maker.name, string(a:data)), jobinfo)
   82              0.000452     let data = copy(a:data)
   82              0.000162     if a:trim_CR && !empty(a:data)
   82              0.001575         call map(data, "substitute(v:val, '\\r$', '', '')")
   82              0.000072     endif
   82              0.000169     if get(jobinfo, 'canceled')
   60   0.003080   0.000343         call neomake#log#debug('Ignoring output (job was canceled).', jobinfo)
   60              0.000040         return
                                endif
   22              0.000052     let last_event_type = get(jobinfo, 'event_type', a:event_type)
                            
                                " data is a list of 'lines' read. Each element *after* the first
                                " element represents a newline.
   22              0.000031     if has_key(jobinfo, a:event_type)
                                    let jobinfo[a:event_type][-1] .= data[0]
                                    call extend(jobinfo[a:event_type], data[1:])
                                else
   22              0.000043         let jobinfo[a:event_type] = data
   22              0.000009     endif
                            
   22              0.000037     if !jobinfo.buffer_output || last_event_type !=# a:event_type
                                    let lines = jobinfo[a:event_type][:-2]
                                    let jobinfo[a:event_type] = jobinfo[a:event_type][-1:]
                            
                                    if !empty(lines)
                                        call s:RegisterJobOutput(jobinfo, lines, a:event_type)
                                    endif
                                endif

FUNCTION  <SNR>118_SetCompleteFunc()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000005   let &completefunc = 'youcompleteme#CompleteFunc'

FUNCTION  <SNR>103_group_not_done()
Called 1308 times
Total time:   0.017960
 Self time:   0.017960

count  total (s)   self (s)
 1308              0.007956   if index(a:list, a:name) == -1
 1188              0.005198     call add(a:list, a:name)
 1188              0.001901     return 1
                              else
  120              0.000251     if &vbs
                                  echomsg printf("airline: group: %s already done, skipping", a:name)
                                endif
  120              0.000108     return 0
                              endif

FUNCTION  <SNR>31_TriggerAbb()
Called 30 times
Total time:   0.000827
 Self time:   0.000827

count  total (s)   self (s)
   30              0.000480   if v:version < 703 || ( v:version == 703 && !has('patch489') ) || pumvisible()
    3              0.000012     return ''
                              endif
   27              0.000124   return "\<C-]>"

FUNCTION  airline#check_mode()
Called 3068 times
Total time:   1.237755
 Self time:   0.731223

count  total (s)   self (s)
 3068              0.018425   if !has_key(s:contexts, a:winnr)
                                return ''
                              endif
 3068              0.019887   let context = s:contexts[a:winnr]
                            
 3068              0.020058   if get(w:, 'airline_active', 1)
 3068              0.020097     let l:m = mode(1)
 3068              0.011388     if l:m ==# "i"
 1526              0.007591       let l:mode = ['insert']
 1526              0.004572     elseif l:m[0] ==# "i"
   92              0.000456       let l:mode = ['insert']
   92              0.000177     elseif l:m ==# "Rv"
                                  let l:mode =['replace']
                                elseif l:m[0] ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m[0] =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                elseif l:m[0] ==# "c"
   10              0.000081       let l:mode = ['commandline']
   10              0.000034     elseif l:m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let l:mode = ['normal']
                                elseif l:m[0:1] ==# 'ni'
                                  let l:mode = ['normal']
                                  let l:m = 'ni'
                                else
 1440              0.007365       let l:mode = ['normal']
 1440              0.002068     endif
 3068              0.036551     if index(['Rv', 'no', 'ni', 'ix', 'ic'], l:m) == -1
 2976              0.013278       let l:m = l:m[0]
 2976              0.004173     endif
 3068              0.027973     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
 3068              0.004416   else
                                let l:mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
                              endif
                            
 3068              0.023085   if g:airline_detect_modified && &modified
 1691              0.012841     call add(l:mode, 'modified')
 1691              0.002474   endif
                            
 3068              0.012068   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
 3068              0.060870   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
 3068              0.012941   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
                              endif
                            
 3068              0.010348   if &readonly || ! &modifiable
                                call add(l:mode, 'readonly')
                              endif
                            
 3068              0.029871   let mode_string = join(l:mode)
 3068              0.022109   if get(w:, 'airline_lastmode', '') != mode_string
   30   0.020312   0.000573     call airline#highlighter#highlight_modified_inactive(context.bufnr)
   30   0.483362   0.000835     call airline#highlighter#highlight(l:mode, context.bufnr)
   30   0.004724   0.000458     call airline#util#doautocmd('AirlineModeChanged')
   30              0.000133     let w:airline_lastmode = mode_string
   30              0.000032   endif
                            
 3068              0.006734   return ''

FUNCTION  <SNR>134_upsert_new_gitgutter_signs()
Called 18 times
Total time:   0.028988
 Self time:   0.025175

count  total (s)   self (s)
   18   0.000519   0.000176   let other_signs         = gitgutter#utility#getbufvar(a:bufnr, 'other_signs')
   18   0.000340   0.000143   let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
                            
  477              0.000721   for line in a:modified_lines
  459              0.000947     let line_number = line[0]  " <number>
  459              0.001186     if index(other_signs, line_number) == -1  " don't clobber others' signs
  440   0.005264   0.002857       let name = s:highlight_name_for_change(line[1])
  440              0.001243       if !has_key(old_gitgutter_signs, line_number)  " insert
  157   0.001449   0.000584         let id = s:next_sign_id()
  157              0.010320         execute "sign place" id "line=" . line_number "name=" . name "buffer=" . a:bufnr
  157              0.000169       else  " update if sign has changed
  283              0.000757         let old_sign = old_gitgutter_signs[line_number]
  283              0.000565         if old_sign.name !=# name
   28              0.000874           execute "sign place" old_sign.id "name=" . name "buffer=" . a:bufnr
   28              0.000021         end
  283              0.000147       endif
  440              0.000210     endif
  459              0.000368   endfor
                              " At this point b:gitgutter_gitgutter_signs is out of date.

FUNCTION  deoplete#util#get_input()
Called 822 times
Total time:   0.127594
 Self time:   0.127594

count  total (s)   self (s)
  822              0.006104   let mode = mode()
  822              0.003683   if a:event ==# 'InsertEnter'
   20              0.000049     let mode = 'i'
   20              0.000030   endif
  822              0.035266   let input = (mode ==# 'i' ? (col('.')-1) : col('.')) >= len(getline('.')) ?      getline('.') :      matchstr(getline('.'),         '^.*\%' . (mode ==# 'i' ? col('.') : col('.') - 1)         . 'c' . (mode ==# 'i' ? '' : '.'))
                            
  822              0.025884   if input =~# '^.\{-}\ze\S\+$'
  644              0.015173     let complete_str = matchstr(input, '\S\+$')
  644              0.013455     let input = matchstr(input, '^.\{-}\ze\S\+$')
  644              0.001463   else
  178              0.000715     let complete_str = ''
  178              0.000286   endif
                            
  822              0.003002   if a:event ==# 'InsertCharPre'
                                let complete_str .= v:char
                              endif
                            
  822              0.004208   return input . complete_str

FUNCTION  deoplete#handler#_skip_next_completion()
Called 52 times
Total time:   0.011030
 Self time:   0.002708

count  total (s)   self (s)
   52              0.000345   if !exists('g:deoplete#_context')
                                return
                              endif
                            
   52   0.008175   0.000739   let input = deoplete#util#get_input('CompleteDone')
   52              0.000230   if input[-1:] !=# '/'
   52              0.000290     let g:deoplete#_context.input = input
   52              0.000069   endif
   52   0.001551   0.000665   call deoplete#init#_prev_completion()

FUNCTION  airline#util#append()
Called 21476 times
Total time:   0.438004
 Self time:   0.438004

count  total (s)   self (s)
21476              0.093533   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
21476              0.140483   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
21476              0.119922   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  neomake#Make()
Called 41 times
Total time:   0.531359
 Self time:   0.002792

count  total (s)   self (s)
   41              0.000495     if type(a:file_mode_or_options) == type({})
   41   0.530710   0.002143         return s:Make(a:file_mode_or_options)
                                endif
                            
                                let file_mode = a:file_mode_or_options
                                let options = {'file_mode': file_mode}
                                if file_mode
                                    let options.ft = &filetype
                                endif
                                if a:0
                                    if !empty(a:1)
                                        let maker_names = a:1
                                        " Split names on non-breaking space (annotation from completion).
                                        call map(maker_names, "type(v:val) == 1 ? split(v:val, ' (')[0] : v:val")
                                        let options.enabled_makers = a:1
                                    endif
                                    if a:0 > 1
                                        let options.exit_callback = a:2
                                    endif
                                endif
                                return map(copy(s:Make(options)), 'v:val.id')

FUNCTION  AutoSave()
Called 154 times
Total time:   0.005679
 Self time:   0.005679

count  total (s)   self (s)
  154              0.000985   if g:auto_save >= 1
                                let was_modified = &modified
                                silent! wa
                                if was_modified && !&modified
                                  if exists("g:auto_save_postsave_hook")
                                    execute "" . g:auto_save_postsave_hook
                                  endif
                                  if g:auto_save_silent == 0
                                    echo "(AutoSaved at " . strftime("%H:%M:%S") . ")"
                                  endif
                                endif
                              endif

FUNCTION  delimitMate#Get()
Called 73 times
Total time:   0.001426
 Self time:   0.000317

count  total (s)   self (s)
   73   0.001405   0.000296   return call('s:get', a:000)

FUNCTION  airline#extensions#branch#update_untracked_config()
Called 3060 times
Total time:   0.097798
 Self time:   0.097798

count  total (s)   self (s)
 3060              0.026399   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
    1              0.000000     return
                              elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
                              endif

FUNCTION  <SNR>115_incCount()
Called 8 times
Total time:   0.000425
 Self time:   0.000321

count  total (s)   self (s)
    8              0.000061     if !empty(a:item.type) && (!a:buf || a:item.bufnr ==# a:buf)
    8              0.000043         let type = toupper(a:item.type)
    8              0.000047         let a:counts[type] = get(a:counts, type, 0) + 1
    8              0.000014         if a:buf
    8   0.000189   0.000084             call s:clear_cache(a:buf)
    8              0.000010         else
                                        let s:cache = {}
                                    endif
    8              0.000013         return 1
                                endif
                                return 0

FUNCTION  airline#themes#get_highlight()
Called 1638 times
Total time:   0.226165
 Self time:   0.015702

count  total (s)   self (s)
 1638   0.225271   0.014808   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  <SNR>118_UpdateMatches()
Called 1 time
Total time:   0.001049
 Self time:   0.001049

count  total (s)   self (s)
    1              0.001049   exec s:python_command "ycm_state.UpdateMatches()"

FUNCTION  neomake#log#info()
Called 42 times
Total time:   0.004292
 Self time:   0.000760

count  total (s)   self (s)
   42   0.004259   0.000727     call call('s:log', [2] + a:000)

FUNCTION  <SNR>110_buffer_getline()
Called 6 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    6              0.000023   return get(getbufline(self['#'], a:lnum), 0, '')

FUNCTION  neomake#GetCurrentErrorMsg()
Called 49 times
Total time:   0.007060
 Self time:   0.001195

count  total (s)   self (s)
   49   0.006602   0.000737     let entry = neomake#get_nearest_error()
   49              0.000223     if empty(entry)
   49              0.000103         return ''
                                endif
                                let r = entry.maker_name . ': ' . entry.text
                                let suffix = entry.type . (entry.nr != -1 ? entry.nr : '')
                                if !empty(suffix)
                                    let r .= ' ('.suffix.')'
                                endif
                                return r

FUNCTION  <SNR>118_SetUpCompleteopt()
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
                              " Some plugins (I'm looking at you, vim-notes) change completeopt by for
                              " instance adding 'longest'. This breaks YCM. So we force our settings.
                              " There's no two ways about this: if you want to use YCM then you have to
                              " have these completeopt settings, otherwise YCM won't work at all.
                            
                              " We need menuone in completeopt, otherwise when there's only one candidate
                              " for completion, the menu doesn't show up.
    1              0.000006   set completeopt-=menu
    1              0.000002   set completeopt+=menuone
                            
                              " This is unnecessary with our features. People use this option to insert
                              " the common prefix of all the matches and then add more differentiating chars
                              " so that they can select a more specific match. With our features, they
                              " don't need to insert the prefix; they just type the differentiating chars.
                              " Also, having this option set breaks the plugin.
    1              0.000001   set completeopt-=longest
                            
    1              0.000002   if g:ycm_add_preview_to_completeopt
                                set completeopt+=preview
                              endif

FUNCTION  <SNR>114_write_buffer()
Called 19 times
Total time:   0.003692
 Self time:   0.003692

count  total (s)   self (s)
   19              0.000887   let bufcontents = getbufline(a:bufnr, 1, '$')
                            
   19              0.000197   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
                              endif
                            
   19              0.000128   let fenc = getbufvar(a:bufnr, '&fileencoding')
   19              0.000076   if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
                              endif
                            
   19              0.000093   if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]='﻿'.bufcontents[0]
                              endif
                            
   19              0.001746   call writefile(bufcontents, a:file)

FUNCTION  neomake#action_queue#get_queued_actions()
Called 41 times
Total time:   0.000672
 Self time:   0.000672

count  total (s)   self (s)
                                " Check if there are any queued actions for this job.
   41              0.000163     let queued_actions = []
   41              0.000128     for [events, v] in s:action_queue
                                    if v[1][0] == a:jobinfo
                                        let queued_actions += [[s:actionname(v[0]), events]]
                                    endif
                                endfor
   41              0.000056     return queued_actions

FUNCTION  158()
Called 3 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    3              0.000008   return len(self._sections)

FUNCTION  159()
Called 31 times
Total time:   0.181852
 Self time:   0.025278

count  total (s)   self (s)
   31              0.000060   let side = 1
   31              0.000037   let line = ''
   31              0.000029   let i = 0
   31              0.000091   let length = len(self._sections)
   31              0.000037   let split = 0
   31              0.000038   let is_empty = 0
   31              0.000051   let prev_group = ''
                            
  298              0.000544   while i < length
  267              0.000768     let section = self._sections[i]
  267              0.000487     let group = section[0]
  267              0.000483     let contents = section[1]
  267              0.000392     let pgroup = prev_group
  267   0.005492   0.002037     let prev_group = airline#builder#get_prev_group(self._sections, i)
  267              0.000693     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
                                elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let group = 'airline_c'. self._context.bufnr
                                elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let prev_group = 'airline_c'. self._context.bufnr
                                endif
  267              0.000249     if is_empty
                                  let prev_group = pgroup
                                endif
  267   0.004687   0.001553     let is_empty = s:section_is_empty(self, contents)
                            
  267              0.000232     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
                                endif
                            
  267              0.000275     if group == ''
   12              0.000059       let line .= contents
   12              0.000024     elseif group == '|'
   31              0.000037       let side = 0
   31              0.000128       let line .= contents
   31              0.000042       let split = 1
   31              0.000018     else
  224              0.000221       if prev_group == ''
   31              0.000097         let line .= '%#'.group.'#'
   31              0.000025       elseif split
   31              0.000024         if !is_empty
   31   0.016250   0.000312           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
   31              0.000024         endif
   31              0.000047         let split = 0
   31              0.000018       else
  162              0.000133         if !is_empty
  162   0.120515   0.001690           let line .= s:get_seperator(self, prev_group, group, side)
  162              0.000164         endif
  162              0.000070       endif
  224   0.018313   0.003091       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
  224              0.000177     endif
                            
  267              0.000485     let i = i + 1
  267              0.000283   endwhile
                            
   31              0.000062   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
                                let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
                              endif
   31              0.000102   return line

FUNCTION  <SNR>19_automake_delayed_cb()
Called 59 times
Total time:   0.611203
 Self time:   0.026313

count  total (s)   self (s)
   59              0.002140     let timer_info = s:timer_info[a:timer]
   59              0.000496     unlet s:timer_info[a:timer]
   59              0.000381     unlet s:timer_by_bufnr[timer_info.bufnr]
                            
   59              0.000623     if !bufexists(timer_info.bufnr)
                                    call s:debug_log(printf('buffer does not exist anymore for timer %d', a:timer), {'bufnr': timer_info.bufnr})
                                    return
                                endif
                            
   59   0.013551   0.002657     call s:debug_log(printf('callback for timer %d (via %s)', string(a:timer), timer_info.event), {'bufnr': timer_info.bufnr})
                            
   59              0.000431     let bufnr = bufnr('%')
   59              0.000294     if timer_info.bufnr != bufnr
                                    call s:debug_log(printf('buffer changed: %d => %d', timer_info.bufnr, bufnr))
                                    return
                                endif
                            
                                " Check disabled ft here for BufWinEnter, since &ft might not be defined
                                " before (startify).
   59   0.002220   0.000555     if timer_info.event ==# 'BufWinEnter' && s:disabled_for_ft(timer_info.bufnr)
                                    return
                                endif
                            
   59   0.003427   0.000930     if neomake#compat#in_completion()
   16   0.002307   0.000292         call s:debug_log('postponing automake during completion')
   16              0.000100         if has_key(timer_info, 'pos')
   16              0.000124             unlet timer_info.pos
   16              0.000032         endif
   16              0.000233         let b:_neomake_postponed_automake_context = [0, timer_info]
                            
   16              0.000180         augroup neomake_automake_retry
   16              0.006612           au! * <buffer>
   16              0.000220           autocmd CompleteDone <buffer> call s:do_postponed_automake(1)
   16              0.000201           autocmd InsertLeave <buffer> call s:do_postponed_automake(2)
   16              0.000039         augroup END
   16              0.000034         return
                                endif
                            
                                " Verify context/position is the same.
                                " TODO: only makes sense for some events, e.g. not for
                                "       BufWritePost/BufWinEnter?!
                                " if timer_info.event !=# 'BufWritePost'
   43              0.000304     if !empty(timer_info.pos)
   42   0.003018   0.000646         let current_context = s:get_position_context()
   42              0.000314         if current_context != timer_info.pos
    3   0.000452   0.000088             call s:debug_log(printf('context/position changed: %s => %s', string(timer_info.pos), string(current_context)))
    3              0.000005             return
                                    endif
   39              0.000065     endif
                                " endif
                            
   40              0.000428     let context = copy(timer_info)
   40              0.000241     let context.delay = 0
   40   0.566773   0.001692     call s:neomake_do_automake(context)

FUNCTION  neomake#core#create_jobs()
Called 1 time
Total time:   0.034346
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000003     let args = [a:options, a:makers]
    1   0.034340   0.000022     let jobs = call('s:bind_makers_for_job', args)
    1              0.000002     return jobs

FUNCTION  gitgutter#utility#set_repo_path()
Called 1 time
Total time:   0.001309
 Self time:   0.000065

count  total (s)   self (s)
                              " Values of path:
                              " * non-empty string - path
                              " *               -1 - pending
                              " *               -2 - not tracked by git
                            
    1   0.000013   0.000004   call gitgutter#utility#setbufvar(a:bufnr, 'path', -1)
    1   0.000236   0.000011   let cmd = gitgutter#utility#cd_cmd(a:bufnr, g:gitgutter_git_executable.' ls-files --error-unmatch --full-name -- '.gitgutter#utility#shellescape(s:filename(a:bufnr)))
                            
    1   0.000005   0.000004   if g:gitgutter_async && gitgutter#async#available()
    1              0.000001     if has('lambda')
    1   0.001032   0.000024       call gitgutter#async#execute(cmd, a:bufnr, {   'out': {bufnr, path -> gitgutter#utility#setbufvar(bufnr, 'path', s:strip_trailing_new_line(path))},   'err': {bufnr       -> gitgutter#utility#setbufvar(bufnr, 'path', -2)}, })
    1              0.000000     else
                                  if has('nvim') && !has('nvim-0.2.0')
                                    call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('s:set_path'),   'err': function('s:not_tracked_by_git') })
                                  else
                                    call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('s:set_path'),   'err': function('s:set_path', [-2]) })
                                  endif
                                endif
    1              0.000000   else
                                let path = gitgutter#utility#system(cmd)
                                if v:shell_error
                                  call gitgutter#utility#setbufvar(a:bufnr, 'path', -2)
                                else
                                  call gitgutter#utility#setbufvar(a:bufnr, 'path', s:strip_trailing_new_line(path))
                                endif
                              endif

FUNCTION  <SNR>124_is_skip_text()
Called 291 times
Total time:   0.114768
 Self time:   0.040571

count  total (s)   self (s)
  291              0.002904   let context = g:deoplete#_context
  291   0.054137   0.004932   let input = deoplete#util#get_input(a:event)
                            
  291              0.004017   if has_key(context, 'input') && a:event !=# 'Manual' && a:event !=# 'Async' && input ==# context.input
   31              0.000061     return 1
                              endif
                            
  260              0.002542   let displaywidth = strdisplaywidth(input) + 1
  260              0.006275   if &l:formatoptions =~# '[tca]' && &l:textwidth > 0     && displaywidth >= &l:textwidth
                                if &l:formatoptions =~# '[ta]' || !empty(filter(deoplete#util#get_syn_names(),                  "v:val ==# 'Comment'"))
                                  return 1
                                endif
                              endif
                            
  260   0.031752   0.006759   let skip_chars = deoplete#custom#_get_option('skip_chars')
                            
  260              0.005622   return (!pumvisible() && virtcol('.') != displaywidth) || (a:event !=# 'Manual' && input !=# ''     && index(skip_chars, input[-1:]) >= 0)

FUNCTION  <SNR>110_DirCommitFile()
Called 1 time
Total time:   0.000031
 Self time:   0.000024

count  total (s)   self (s)
    1   0.000028   0.000021   let vals = matchlist(s:Slash(a:path), '\c^fugitive:\%(//\)\=\(.\{-\}\)\%(//\|::\)\(\x\{40\}\|[0-3]\)\(/.*\)\=$')
    1              0.000001   if empty(vals)
    1              0.000001     return ['', '', '']
                              endif
                              return vals[1:3]

FUNCTION  airline#util#exec_funcrefs()
Called 37 times
Total time:   0.063123
 Self time:   0.002265

count  total (s)   self (s)
  199              0.000305     for Fn in a:list
  187   0.062169   0.001311       let code = call(Fn, a:000)
  187              0.000180       if code != 0
   25              0.000026         return code
                                  endif
  162              0.000114     endfor
   12              0.000013     return 0

FUNCTION  <SNR>45_Slash()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000005   if exists('+shellslash')
                                return tr(a:path, '\', '/')
                              else
    1              0.000001     return a:path
                              endif

FUNCTION  <SNR>118_Complete()
Called 292 times
Total time:   0.014592
 Self time:   0.010793

count  total (s)   self (s)
                              " Do not call user's completion function if the start column is after the
                              " current column or if there are no candidates. Close the completion menu
                              " instead. This avoids keeping the user in completion mode.
  292              0.003346   if s:completion.completion_start_column > s:completion.column || empty( s:completion.completions )
  195   0.004227   0.001778     call s:CloseCompletionMenu()
  195              0.000264   else
                                " <c-x><c-u> invokes the user's completion function (which we have set to
                                " youcompleteme#CompleteFunc), and <c-p> tells Vim to select the previous
                                " completion candidate. This is necessary because by default, Vim selects
                                " the first candidate when completion is invoked, and selecting a candidate
                                " automatically replaces the current text with it. Calling <c-p> forces Vim
                                " to deselect the first candidate and in turn preserve the user's current
                                " text until he explicitly chooses to replace it with a completion.
   97   0.002632   0.001283     call s:SendKeys( "\<C-X>\<C-U>\<C-P>" )
   97              0.000156   endif

FUNCTION  <SNR>82_do_clean_make_info()
Called 41 times
Total time:   0.006993
 Self time:   0.003887

count  total (s)   self (s)
   41   0.002050   0.000222     call neomake#log#debug('Cleaning make info.', a:make_info.options)
   41              0.000072     let make_id = a:make_info.options.make_id
                            
                                " Remove make_id from its window.
   41   0.001478   0.000304     let [t, w] = s:GetTabWinForMakeId(make_id)
   41   0.000314   0.000210     let make_ids = neomake#compat#gettabwinvar(t, w, 'neomake_make_ids', [])
   41              0.000091     let idx = index(make_ids, make_id)
   41              0.000038     if idx != -1
   41              0.000108         call remove(make_ids, idx)
   41              0.000122         call settabwinvar(t, w, 'neomake_make_ids', make_ids)
   41              0.000030     endif
                            
                                " Clean up temporary files and buffers.
   41              0.000126     let wipe_unlisted_buffers = get(a:make_info, '_wipe_unlisted_buffers', [])
   41              0.000088     let tempfiles = get(a:make_info, 'tempfiles')
   41              0.000057     if !empty(tempfiles)
                                    for tempfile in tempfiles
                                        let delete_ret = delete(tempfile)
                                        if delete_ret == 0
                                            call neomake#log#debug(printf('Removing temporary file: "%s".', tempfile))
                                        else
                                            call neomake#log#warning(printf('Failed to remove temporary file: "%s" (%d).', tempfile, delete_ret))
                                        endif
                                        let bufnr_tempfile = bufnr(tempfile)
                                        if bufnr_tempfile != -1 && !buflisted(bufnr_tempfile)
                                            let wipe_unlisted_buffers += [bufnr_tempfile]
                                        endif
                                    endfor
                            
                                    " Only delete the dir, if Vim supports it.
                                    if v:version >= 705 || (v:version == 704 && has('patch1107'))
                                        for dir in reverse(copy(get(a:make_info, 'created_dirs')))
                                            call delete(dir, 'd')
                                        endfor
                                    endif
                                endif
   41              0.000085     if !empty(wipe_unlisted_buffers)
                                    if !empty(wipe_unlisted_buffers)
                                        call neomake#compat#uniq(sort(wipe_unlisted_buffers))
                                    endif
                                    call neomake#log#debug(printf('Wiping out %d unlisted/remapped buffers: %s.', len(wipe_unlisted_buffers), string(wipe_unlisted_buffers)))
                                    exe (&report < 2 ? 'silent ' : '').'bwipeout '.join(wipe_unlisted_buffers)
                                endif
                            
   41              0.000212     let buf_prev_makes = getbufvar(a:make_info.options.bufnr, 'neomake_automake_make_ids')
   41              0.000063     if !empty(buf_prev_makes)
   41              0.000169         call filter(buf_prev_makes, 'v:val != make_id')
   41              0.000143         call setbufvar(a:make_info.options.bufnr, 'neomake_automake_make_ids', buf_prev_makes)
   41              0.000023     endif
                            
   41              0.000127     unlet s:make_info[make_id]

FUNCTION  <SNR>90_update_untracked()
Called 3068 times
Total time: 113.358902
 Self time: 113.254931

count  total (s)   self (s)
 3068            100.772241   let file = expand("%:p")
 3068             12.037142   if empty(file) || isdirectory(file)
                                return
                              endif
                            
 3068              0.016460   let needs_update = 1
 9204              0.053457   for vcs in keys(s:vcs_config)
 6136              0.081140     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
                                endif
 6136              0.040903     if has_key(s:vcs_config[vcs].untracked, file)
 3058              0.010059       let needs_update = 0
 3058   0.159328   0.061563       call airline#extensions#branch#update_untracked_config(file, vcs)
 3058              0.004052     endif
 6136              0.010744   endfor
                            
 3068              0.008286   if !needs_update
 3058              0.005912     return
                              endif
                            
   30              0.000089   for vcs in keys(s:vcs_config)
   20              0.000075     let config = s:vcs_config[vcs]
   20              0.000045     if g:airline#init#vim_async
                                  " Note that asynchronous update updates s:vcs_config only, and only
                                  " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                  " invalidated again before s:update_untracked is called, then we lose the
                                  " result of the previous call, i.e. the head string is not updated. It
                                  " doesn't happen often in practice, so we let it be.
                                  noa call airline#async#vim_vcs_untracked(config, file)
                                else
                                  " nvim async or vim without job-feature
   20   0.006640   0.000434       noa call airline#async#nvim_vcs_untracked(config, file, vcs)
   20              0.000022     endif
   20              0.000027   endfor

FUNCTION  <SNR>82_handle_locqf_list_for_finished_jobs()
Called 11 times
Total time:   0.002248
 Self time:   0.000706

count  total (s)   self (s)
   11              0.000017     let file_mode = a:make_info.options.file_mode
   11              0.000022     let create_list = !get(a:make_info, 'created_locqf_list', 0)
                            
   11              0.000036     let open_val = get(g:, 'neomake_open_list', 0)
   11              0.000018     let height = open_val ? get(g:, 'neomake_list_height', 10) : 0
   11              0.000006     if height
                                    let close_list = create_list || empty(file_mode ? getloclist(0) : getqflist())
                                else
   11              0.000010         let close_list = 0
   11              0.000004     endif
                            
   11              0.000006     if file_mode
   11              0.000016         if create_list && !bufexists(a:make_info.options.bufnr)
                                        call neomake#log#info('No buffer found for location list!', a:make_info.options)
                                        let create_list = 0
                                        let close_list = 0
                                    elseif (create_list || close_list)
                                        if index(get(w:, 'neomake_make_ids', []), a:make_info.options.make_id) == -1
                                            call neomake#log#debug( 'Postponing final location list handling (in another window).', {'make_id': a:make_info.options.make_id, 'winnr': winnr()})
                                            return neomake#action_queue#add(['WinEnter'], [s:function('s:handle_locqf_list_for_finished_jobs'), [a:make_info] + a:000])
                                        endif
                            
                                        " TODO: merge with s:need_to_postpone_output_processing.
                                        if neomake#compat#in_completion()
                                            call neomake#log#debug( 'Postponing final location list handling during completion.', a:make_info.options)
                                            return neomake#action_queue#add(['CompleteDone'], [s:function('s:handle_locqf_list_for_finished_jobs'), [a:make_info] + a:000])
                                        endif
                                        let mode = neomake#compat#get_mode()
                                        if index(['n', 'i'], mode) == -1
                                            call neomake#log#debug(printf( 'Postponing final location list handling for mode "%s".', mode), a:make_info.options)
                                            return neomake#action_queue#add(['Timer'], [s:function('s:handle_locqf_list_for_finished_jobs'), [a:make_info] + a:000])
                                        endif
                                    endif
   11              0.000004     endif
                            
                                " Close empty list.
   11              0.000006     if close_list
                                    if file_mode
                                        call neomake#log#debug('Handling location list: executing lclose.', {'winnr': winnr()})
                                        lclose
                                    else
                                        call neomake#log#debug('Handling quickfix list: executing cclose.')
                                        cclose
                                    endif
                                endif
                            
   11              0.000007     if create_list
                                    if file_mode
                                        call neomake#log#debug('Cleaning location list.', {'make_id': a:make_info.options.make_id})
                                        call setloclist(0, [])
                                    else
                                        call neomake#log#debug('Cleaning quickfix list.', {'make_id': a:make_info.options.make_id})
                                        call setqflist([])
                                    endif
                                endif
                            
   11              0.000038     let hook_context = { 'make_id': a:make_info.options.make_id, 'options': a:make_info.options, 'finished_jobs': a:make_info.finished_jobs, }
   11   0.000152   0.000040     call neomake#utils#hook('NeomakeFinished', hook_context)
   11   0.001475   0.000045     call s:do_clean_make_info(a:make_info)
   11              0.000014     return g:neomake#action_queue#processed

FUNCTION  airline#extensions#neomake#get_warnings()
Called 3068 times
Total time:   0.244204
 Self time:   0.070523

count  total (s)   self (s)
 3068   0.210071   0.036390   let counts = s:get_counts()
 3068              0.017583   let warnings = get(counts, 'W', 0)
 3068              0.011521   return warnings ? s:warning_symbol.warnings : ''

FUNCTION  airline#extensions#branch#head()
Called 3068 times
Total time: 327.610224
 Self time:   0.164094

count  total (s)   self (s)
 3068              0.020604   if !exists('b:buffer_vcs_config')
    1   0.000111   0.000034     call s:init_buffer()
    1              0.000001   endif
                            
 3068 214.117534   0.031343   call s:update_branch()
 3068 113.401972   0.043070   call s:update_untracked()
                            
 3068              0.028739   if exists('b:airline_head') && !empty(b:airline_head)
 3066              0.008738     return b:airline_head
                              endif
                            
    2              0.000004   let b:airline_head = ''
    2              0.000008   let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
    2              0.000002   let heads = []
    6              0.000005   for vcs in vcs_priority
    4              0.000012     if !empty(b:buffer_vcs_config[vcs].branch)
    2              0.000004       let heads += [vcs]
    2              0.000001     endif
    4              0.000003   endfor
                            
    4              0.000006   for vcs in heads
    2              0.000002     if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
                                endif
    2              0.000003     if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
                                endif
    2   0.001030   0.000102     let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
    2              0.000009     let b:airline_head .= b:buffer_vcs_config[vcs].untracked
    2              0.000003   endfor
                            
    2              0.000004   if empty(heads)
                                if airline#util#has_vcscommand()
                                  noa call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
                              endif
                            
    2              0.000002   if empty(heads)
                                if airline#util#has_custom_scm()
                                  try
                                    let Fn = function(g:airline#extensions#branch#custom_head)
                                    let b:airline_head = Fn()
                                  endtry
                                endif
                              endif
                            
    2              0.000006   if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if len(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = b:airline_head[0:(w:displayed_head_limit - 1)].(&encoding ==? 'utf-8' ?  '…' : '.')
                                endif
                              endif
                            
    2              0.000012   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
    2   0.000052   0.000020   let b:airline_head = airline#util#shorten(b:airline_head, 120, minwidth)
    2              0.000005   return b:airline_head

FUNCTION  airline#util#has_fugitive()
Called 3068 times
Total time:   0.027258
 Self time:   0.027258

count  total (s)   self (s)
 3068              0.024078   return exists('*fugitive#head') || exists('*FugitiveHead')

FUNCTION  neomake#makers#ft#rust#cargo()
Called 1 time
Total time:   0.000190
 Self time:   0.000190

count  total (s)   self (s)
    1              0.000057     let maker_command = get(b:, 'neomake_rust_cargo_command', get(g:, 'neomake_rust_cargo_command', ['check']))
    1              0.000046     let maker = { 'args': maker_command + ['--message-format=json', '--quiet'], 'append_file': 0, 'process_output': function('neomake#makers#ft#rust#CargoProcessOutput'), }
                            
    1              0.000025     function! maker.InitForJob(jobinfo) abort
                                    if !has_key(self, 'cwd')
                                        let self.cwd = s:get_cargo_maker_cwd('%:p:h')
                                        return self
                                    endif
                                endfunction
    1              0.000006     return maker

FUNCTION  <SNR>118_OnFileReadyToParse()
Called 6 times
Total time:   0.040456
 Self time:   0.033394

count  total (s)   self (s)
                              " Accepts an optional parameter that is either 0 or 1. If 1, send a
                              " FileReadyToParse event notification, whether the buffer has changed or not;
                              " effectively forcing a parse of the buffer. Default is 0.
    6              0.000059   let force_parsing = a:0 > 0 && a:1
                            
                              " We only want to send a new FileReadyToParse event notification if the buffer
                              " has changed since the last time we sent one, or if forced.
    6   0.007167   0.000105   if force_parsing || s:Pyeval( "ycm_state.NeedsReparse()" )
    5              0.032779     exec s:python_command "ycm_state.OnFileReadyToParse()"
                            
    5              0.000161     call timer_stop( s:pollers.file_parse_response.id )
    5              0.000163     let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
    5              0.000015   endif

FUNCTION  <SNR>139_make_cache()
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000008   let ft = &filetype
    1              0.000014   if ft == '' || ft ==# 'vim' || has_key(s:syntax_list, ft)
    1              0.000002     return
                              endif
                            
                              " Make cache from syntax list.
                              let s:syntax_list[ft] = s:make_cache_from_syntax(ft)

FUNCTION  <SNR>20_get()
Called 923 times
Total time:   0.180133
 Self time:   0.083023

count  total (s)   self (s)
 2847              0.008708     for prefix in a:prefixes
 2354   0.138240   0.041131         let [c, k] = s:resolve_name(a:dict, prefix + a:parts[0:-1], 0)
 2354              0.008413         if has_key(c, k)
  430              0.002104             return [prefix, get(c, k)]
                                    endif
 1924              0.002787     endfor
  493              0.001740     return [[], g:neomake#config#undefined]

FUNCTION  deoplete#util#rpcnotify()
Called 226 times
Total time:   0.071665
 Self time:   0.045124

count  total (s)   self (s)
  226   0.004882   0.002586   if !deoplete#init#_channel_initialized()
                                return ''
                              endif
                            
  226              0.001792   let a:context['rpc'] = a:event
                            
  226   0.026191   0.001946   if deoplete#util#has_yarp()
                                if g:deoplete#_yarp.job_is_dead
                                  return ''
                                endif
                                call g:deoplete#_yarp.notify(a:event, a:context)
                              else
  226              0.032084     call rpcnotify(g:deoplete#_channel_id, a:event, a:context)
  226              0.000724   endif
                            
  226              0.000657   return ''

FUNCTION  <SNR>103_exec_separator()
Called 801 times
Total time:   0.417331
 Self time:   0.035888

count  total (s)   self (s)
  801              0.002277   if pumvisible()
                                return
                              endif
  801              0.002934   let group = a:from.'_to_'.a:to.a:suffix
  801   0.114630   0.005414   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  801   0.105960   0.005328   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  801              0.001033   if a:inverse
  286              0.001297     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
  286              0.000208   else
  515              0.002246     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
  515              0.000334   endif
  801              0.002903   let a:dict[group] = colors
  801   0.178199   0.006602   call airline#highlighter#exec(group, colors)

FUNCTION  airline#parts#filetype()
Called 3068 times
Total time:   0.040067
 Self time:   0.040067

count  total (s)   self (s)
 3068              0.036494   return winwidth(0) < 90 && strlen(&filetype) > 3 ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype

FUNCTION  <SNR>118_SendKeys()
Called 148 times
Total time:   0.002158
 Self time:   0.002158

count  total (s)   self (s)
                              " By default keys are added to the end of the typeahead buffer. If there are
                              " already keys in the buffer, they will be processed first and may change the
                              " state that our keys combination was sent for (e.g. <C-X><C-U><C-P> in normal
                              " mode instead of insert mode or <C-e> outside of completion mode). We avoid
                              " that by inserting the keys at the start of the typeahead buffer with the 'i'
                              " option. Also, we don't want the keys to be remapped to something else so we
                              " add the 'n' option.
  148              0.001338   call feedkeys( a:keys, 'in' )

FUNCTION  airline#extensions#netrw#apply()
Called 25 times
Total time:   0.000554
 Self time:   0.000554

count  total (s)   self (s)
   25              0.000234   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
                              endif

FUNCTION  <SNR>32_get_char()
Called 25 times
Total time:   0.001701
 Self time:   0.001701

count  total (s)   self (s)
   25              0.000176   let idx = col('.') - 1
   25              0.000139   if !a:0 || (a:0 && a:1 >= 0)
                                " Get char from cursor.
   17              0.000139     let line = getline('.')[idx :]
   17              0.000075     let pos = a:0 ? a:1 : 0
   17              0.000515     return matchstr(line, '^'.repeat('.', pos).'\zs.')
                              endif
                              " Get char behind cursor.
    8              0.000077   let line = getline('.')[: idx - 1]
    8              0.000044   let pos = 0 - (1 + a:1)
    8              0.000262   return matchstr(line, '.\ze'.repeat('.', pos).'$')

FUNCTION  airline#parts#iminsert()
Called 3068 times
Total time:   0.039648
 Self time:   0.039648

count  total (s)   self (s)
 3068              0.017279   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
 3068              0.004489   return ''

FUNCTION  gitgutter#hunk#summary()
Called 3146 times
Total time:   0.146604
 Self time:   0.060559

count  total (s)   self (s)
 3146   0.142595   0.056550   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  airline#extensions#term#apply()
Called 25 times
Total time:   0.000387
 Self time:   0.000387

count  total (s)   self (s)
   25              0.000049   if &buftype == 'terminal'
                                let spc = g:airline_symbols.space
                            
                                let name=get(g:airline_mode_map, 't', 't')
                                call a:1.add_section('airline_a', spc.name.spc)
                                call a:1.add_section('airline_b', '')
                                call a:1.add_section('airline_term', spc.s:termname())
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section('airline_z', spc.airline#section#create_right(['linenr', 'maxlinenr']))
                                return 1
                              endif

FUNCTION  neomake#GetEnabledMakers()
Called 1 time
Total time:   0.014654
 Self time:   0.000307

count  total (s)   self (s)
    1              0.000009     let file_mode = a:0
    1              0.000004     if !file_mode
                                    " If we have no filetype, use the global default makers.
                                    " This variable is also used for project jobs, so it has no
                                    " buffer local ('b:') counterpart for now.
                                    let enabled_makers = copy(get(g:, 'neomake_enabled_makers', []))
                                    if empty(enabled_makers)
                                        let makeprg_maker = s:get_makeprg_maker()
                                        if !empty(makeprg_maker)
                                            let makeprg_maker = neomake#GetMaker(makeprg_maker)
                                            let makeprg_maker.auto_enabled = 1
                                            let enabled_makers = [makeprg_maker]
                                        endif
                                    else
                                        call map(enabled_makers, "extend(neomake#GetMaker(v:val), {'auto_enabled': 0}, 'error')")
                                    endif
                                else
    1              0.000008         let enabled_makers = []
    1   0.002209   0.000052         let makers = neomake#utils#GetSetting('enabled_makers', {}, s:unset_list, a:1, bufnr('%'))
    1              0.000006         if makers is# s:unset_list
    1              0.000005             let auto_enabled = 1
    1   0.000088   0.000018             for config_ft in neomake#utils#get_config_fts(a:1)
    1   0.000075   0.000048                 call neomake#utils#load_ft_makers(config_ft)
    1              0.000007                 let fnname = 'neomake#makers#ft#'.config_ft.'#EnabledMakers'
    1              0.000008                 if exists('*'.fnname)
    1   0.000034   0.000029                     let makers = call(fnname, [])
    1              0.000002                     break
                                            endif
                                        endfor
    1              0.000001         else
                                        let auto_enabled = 0
                                    endif
                            
    1   0.012114   0.000026         let makers = neomake#map_makers(makers, a:1, auto_enabled)
    2              0.000004         for maker in makers
    1              0.000003             let maker.auto_enabled = auto_enabled
    1              0.000003             let enabled_makers += [maker]
    1              0.000001         endfor
    1              0.000001     endif
    1              0.000001     return enabled_makers

FUNCTION  <SNR>134_add_dummy_sign()
Called 1 time
Total time:   0.001554
 Self time:   0.001529

count  total (s)   self (s)
    1   0.000012   0.000004   if !gitgutter#utility#getbufvar(a:bufnr, 'dummy_sign')
    1              0.001510     execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . a:bufnr
    1   0.000031   0.000014     call gitgutter#utility#setbufvar(a:bufnr, 'dummy_sign', 1)
    1              0.000000   endif

FUNCTION  <SNR>47_exists_file()
Called 58 times
Total time:   0.710583
 Self time:   0.111403

count  total (s)   self (s)
   58   0.710357   0.111177   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  <SNR>94_get_counts()
Called 6136 times
Total time:   0.339596
 Self time:   0.151740

count  total (s)   self (s)
 6136   0.231465   0.067006   let l:counts = neomake#statusline#LoclistCounts()
                            
 6136              0.025026   if empty(l:counts)
 3522   0.050185   0.026788     return neomake#statusline#QflistCounts()
                              else
 2614              0.005678     return l:counts
                              endif

FUNCTION  <SNR>82_need_to_postpone_output_processing()
Called 11 times
Total time:   0.000563
 Self time:   0.000286

count  total (s)   self (s)
                                " We can only process output (change the location/quickfix list) in
                                " certain modes, otherwise e.g. the visual selection gets lost.
   11   0.000261   0.000075     if neomake#compat#in_completion()
                                    call neomake#log#debug('Not processing output during completion.', a:jobinfo)
                                    return ['CompleteDone']
                                endif
   11   0.000131   0.000040     let mode = neomake#compat#get_mode()
   11              0.000028     if index(['n', 'i'], mode) == -1
                                    call neomake#log#debug('Not processing output for mode "'.mode.'".', a:jobinfo)
                                    return ['BufEnter', 'WinEnter', 'InsertLeave', 'CursorHold', 'CursorHoldI']
                                endif
   11              0.000027     if s:has_getcmdwintype && !empty(getcmdwintype())
                                    call neomake#log#debug('Not processing output from command-line window "'.getcmdwintype().'".', a:jobinfo)
                                    return ['InsertLeave', 'CursorHold', 'CursorHoldI']
                                endif
   11              0.000006     return []

FUNCTION  <SNR>139_get_context_filetypes()
Called 6 times
Total time:   0.000149
 Self time:   0.000149

count  total (s)   self (s)
    6              0.000027   if !exists('s:exists_context_filetype')
                                try
                                  call context_filetype#version()
                                  let s:exists_context_filetype = 1
                                catch
                                  let s:exists_context_filetype = 0
                                endtry
                              endif
                            
    6              0.000026   return s:exists_context_filetype && exists('*context_filetype#get_filetypes') ? context_filetype#get_filetypes(a:filetype) : [a:filetype]

FUNCTION  <SNR>68_on_window_changed()
Called 120 times
Total time:   0.017919
 Self time:   0.010619

count  total (s)   self (s)
  120              0.000877   let s:active_winnr = winnr()
                            
  120              0.000671   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                return
                              endif
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
  120              0.003102   let l:key = [bufnr('%'), s:active_winnr, winnr('$'), tabpagenr(), &ft]
  120              0.004494   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.s:active_winnr.')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
  119              0.000226     return
                              endif
    1              0.000015   let g:airline_last_window_changed = l:key
    1   0.000011   0.000008   call s:init()
    1   0.007303   0.000005   call airline#update_statusline()

FUNCTION  <SNR>82_ProcessJobOutput()
Called 22 times
Total time:   0.073557
 Self time:   0.001684

count  total (s)   self (s)
   22   0.000225   0.000089     if s:need_to_postpone_loclist(a:jobinfo)
                                    return neomake#action_queue#add(['BufEnter', 'WinEnter'], [s:function('s:ProcessJobOutput'), [a:jobinfo, a:lines, a:source]])
                                endif
   22              0.000014     if !a:0
   11              0.000154         return s:pcall('s:ProcessJobOutput', [a:jobinfo, a:lines, a:source])
                                endif
                            
   11              0.000014     let maker = a:jobinfo.maker
   11              0.000014     let file_mode = a:jobinfo.file_mode
   11   0.000464   0.000068     call neomake#log#debug(printf( '%s: processing %d lines of output.', maker.name, len(a:lines)), a:jobinfo)
   11   0.006364   0.000081     let cd_error = a:jobinfo.cd()
   11              0.000013     if !empty(cd_error)
                                    call neomake#log#debug(printf( "Could not change to job's cwd (%s): %s.", a:jobinfo.cd_from_setting, cd_error), a:jobinfo)
                                endif
   11              0.000012     try
   11              0.000026         if has_key(maker, 'process_json') || has_key(maker, 'process_output')
   11              0.000012             if has_key(maker, 'process_json')
                                            let method = 'process_json'
                                            let output = join(a:lines, "\n")
                                            try
                                                let json = neomake#compat#json_decode(output)
                                            catch
                                                let error = printf( 'Failed to decode JSON: %s (output: %s).', substitute(v:exception, '^Neomake: ', '', ''), string(output))
                                                call neomake#log#exception(error, a:jobinfo)
                                                return g:neomake#action_queue#not_processed
                                            endtry
                                            call neomake#log#debug(printf( "Calling maker's process_json method with %d JSON entries.", len(json)), a:jobinfo)
                                            let entries = call(maker.process_json, [{ 'json': json, 'source': a:source, 'jobinfo': a:jobinfo}], maker)
                                        else
   11   0.000440   0.000084                 call neomake#log#debug(printf( "Calling maker's process_output method with %d lines of output on %s.", len(a:lines), a:source), a:jobinfo)
   11              0.000013                 let method = 'process_output'
   11   0.012287   0.000176                 let entries = call(maker.process_output, [{ 'output': a:lines, 'source': a:source, 'jobinfo': a:jobinfo}], maker)
   11              0.000007             endif
   11              0.000024             if type(entries) != type([])
                                            call neomake#log#error(printf('The %s method for maker %s did not return a list, but: %s.', method, maker.name, string(entries)[:100]), a:jobinfo)
                                            return g:neomake#action_queue#not_processed
                                        elseif !empty(entries) && type(entries[0]) != type({})
                                            call neomake#log#error(printf('The %s method for maker %s did not return a list of dicts, but: %s.', method, maker.name, string(entries)[:100]), a:jobinfo)
                                            return g:neomake#action_queue#not_processed
                                        endif
   11   0.015749   0.000131             return s:ProcessEntries(a:jobinfo, entries)
                                    endif
                            
                                    " Old-school handling through errorformat.
                                    if has_key(maker, 'mapexpr')
                                        let l:neomake_bufname = fnamemodify(bufname(a:jobinfo.bufnr), ':p')
                                        " @vimlint(EVL102, 1, l:neomake_bufdir)
                                        let l:neomake_bufdir = fnamemodify(neomake_bufname, ':h')
                                        " @vimlint(EVL102, 1, l:neomake_output_source)
                                        let l:neomake_output_source = a:source
                                        call map(a:lines, maker.mapexpr)
                                    endif
                            
                                    let cd_error = a:jobinfo.cd()
                                    if !empty(cd_error)
                                        call neomake#log#debug(printf( "Could not change to job's cwd (%s): %s.", a:jobinfo.cd_from_setting, cd_error), a:jobinfo)
                                    endif
                            
                                    let prev_list = s:create_locqf_list(a:jobinfo)
                            
                                    if exists('g:loaded_qf')
                                        let vimqf_var = file_mode ? 'qf_auto_open_loclist' : 'qf_auto_open_quickfix'
                                        let vimqf_val = get(g:, vimqf_var, s:unset_dict)
                                        if vimqf_val isnot# 0
                                            let restore_vimqf = [vimqf_var, vimqf_val]
                                            let g:[vimqf_var] = 0
                                        endif
                                    endif
                                    let olderrformat = &errorformat
                                    let &errorformat = maker.errorformat
                                    try
                                        if file_mode
                                            laddexpr a:lines
                                        else
                                            caddexpr a:lines
                                        endif
                                    finally
                                        let &errorformat = olderrformat
                                        call a:jobinfo.cd_back()
                                        if exists('restore_vimqf')
                                            if restore_vimqf[1] is# s:unset_dict
                                                unlet g:[restore_vimqf[0]]
                                            else
                                                let g:[restore_vimqf[0]] = restore_vimqf[1]
                                            endif
                                        endif
                                    endtry
                            
                                    call s:AddExprCallback(a:jobinfo, prev_list)
                                catch /^\%(Vim\%((\a\+)\)\=:\%(E48\|E523\)\)\@!/  " everything, but E48/E523 (sandbox / not allowed here)
                                    if v:exception ==# 'NeomakeTestsException'
                                        throw v:exception
                                    endif
                                    call neomake#log#exception(printf( 'Error during output processing for %s: %s.', a:jobinfo.maker.name, v:exception), a:jobinfo)
                                    return
                                finally
   11   0.000118   0.000067         call a:jobinfo.cd_back()
   11              0.000007     endtry
                                return g:neomake#action_queue#processed

FUNCTION  <SNR>31_Map()
Called 2 times
Total time:   0.002811
 Self time:   0.000285

count  total (s)   self (s)
                              " Set mappings:
    2              0.000005   try
    2              0.000006     let save_keymap = &keymap
    2              0.000005     let save_iminsert = &iminsert
    2              0.000002     let save_imsearch = &imsearch
    2              0.000026     let save_cpo = &cpo
    2              0.000035     set keymap=
    2              0.000011     set cpo&vim
    2   0.000263   0.000044     silent! doautocmd <nomodeline> User delimitMate_map
    2   0.000044   0.000007     if s:get('autoclose')
    2   0.001756   0.000020       call s:AutoClose()
    2              0.000001     else
                                  call s:NoAutoClose()
                                endif
    2   0.000553   0.000022     call s:ExtraMappings()
    2              0.000004   finally
    2              0.000040     let &cpo = save_cpo
    2              0.000017     let &keymap = save_keymap
    2              0.000015     let &iminsert = save_iminsert
    2              0.000004     let &imsearch = save_imsearch
    2              0.000003   endtry
                            
    2              0.000004   let b:delimitMate_enabled = 1

FUNCTION  <SNR>82_create_locqf_list()
Called 11 times
Total time:   0.000582
 Self time:   0.000250

count  total (s)   self (s)
   11              0.000028     let make_info = s:make_info[a:jobinfo.make_id]
   11              0.000018     if get(make_info, 'created_locqf_list', 0)
                                    return a:jobinfo.file_mode ? getloclist(0) : getqflist()
                                endif
   11              0.000014     let make_info.created_locqf_list = 1
                            
   11              0.000015     let file_mode = make_info.options.file_mode
   11              0.000007     if file_mode
   11   0.000369   0.000037         call neomake#log#debug('Creating location list.', a:jobinfo)
   11              0.000053         call setloclist(0, [])
   11              0.000006     else
                                    call neomake#log#debug('Creating quickfix list.', a:jobinfo)
                                    call setqflist([])
                                endif
   11              0.000006     return []

FUNCTION  <SNR>7_SynSet()
Called 1 time
Total time:   0.005344
 Self time:   0.001731

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    1              0.000010   syn clear
    1              0.000009   if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
    1              0.000009   let s = expand("<amatch>")
    1              0.000004   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
    1              0.000002   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
    2              0.000027     for name in split(s, '\.')
    1   0.005227   0.001615       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    1              0.000004     endfor
    1              0.000002   endif

FUNCTION  167()
Called 3 times
Total time:   0.000069
 Self time:   0.000058

count  total (s)   self (s)
    3              0.000009   let self._first_title = a:first " lowest index
    3              0.000006   let self._last_title = a:last " highest index
    3              0.000005   let self._left_title = a:current " next index to add on the left
    3              0.000007   let self._right_title = a:current + 1 " next index to add on the right
    3   0.000030   0.000019   let self._left_position = self.get_position() " left end of titles
    3              0.000007   let self._right_position = self._left_position " right end of the titles

FUNCTION  <SNR>128_tabline_evaluated_length()
Called 18 times
Total time:   0.040737
 Self time:   0.000332

count  total (s)   self (s)
   18   0.040724   0.000320   return airline#util#strchars(s:evaluate_tabline(a:tabline))

FUNCTION  provider#python3#Call()
Called 1571 times
Total time:   3.420591
 Self time:   3.420591

count  total (s)   self (s)
 1571              0.006759   if s:err != ''
                                return
                              endif
 1571              0.007070   if !exists('s:host')
                                let s:rpcrequest = function('rpcrequest')
                            
                                " Ensure that we can load the Python3 host before bootstrapping
                                try
                                  let s:host = remote#host#Require('legacy-python3-provider')
                                catch
                                  let s:err = v:exception
                                  echohl WarningMsg
                                  echomsg v:exception
                                  echohl None
                                  return
                                endtry
                              endif
 1571              3.354951   return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))

FUNCTION  <SNR>132_nvim_output_handler()
Called 4 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
    4              0.000018     if a:event == 'stdout' || a:event == 'stderr'
    4              0.000029       let self.buf .=  join(a:data)
    4              0.000005     endif

FUNCTION  airline#extensions#tabline#buflist#list()
Called 333 times
Total time:   0.003705
 Self time:   0.003645

count  total (s)   self (s)
  333              0.002208   if exists('s:current_buffer_list')
  332              0.000900     return s:current_buffer_list
                              endif
                            
    1              0.000002   let exclude_buffers = get(g:, 'airline#extensions#tabline#exclude_buffers', [])
    1              0.000002   let exclude_paths = get(g:, 'airline#extensions#tabline#excludes', [])
    1              0.000002   let exclude_preview = get(g:, 'airline#extensions#tabline#exclude_preview', 1)
                            
    1              0.000004   let list = (exists('g:did_bufmru') && g:did_bufmru) ? BufMRUList() : range(1, bufnr("$"))
                            
    1              0.000001   let buffers = []
                              " If this is too slow, we can switch to a different algorithm.
                              " Basically branch 535 already does it, but since it relies on
                              " BufAdd autocommand, I'd like to avoid this if possible.
    3              0.000003   for nr in list
    2              0.000002     if buflisted(nr)
                                  " Do not add to the bufferlist, if either
                                  " 1) bufnr is exclude_buffers list
                                  " 2) buffername matches one of exclude_paths patterns
                                  " 3) buffer is a quickfix buffer
                                  " 4) when excluding preview windows:
                                  "     'bufhidden' == wipe
                                  "     'buftype' == nofile
                                  " 5) ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                            
                                  " check buffer numbers first
    2              0.000003       if index(exclude_buffers, nr) >= 0
                                    continue
                                  " check paths second
                                  elseif !empty(exclude_paths) && s:ExcludePaths(nr, exclude_paths)
                                    continue
                                  " ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                                  elseif airline#util#ignore_buf(bufname(nr))
                                    continue
                                  " check other types last
                                  elseif s:ExcludeOther(nr, exclude_preview)
                                    continue
                                  endif
                            
    2              0.000003       call add(buffers, nr)
    2              0.000001     endif
    2              0.000001   endfor
                            
    1              0.000002   let s:current_buffer_list = buffers
    1              0.000001   return buffers

FUNCTION  deoplete#init#_context()
Called 226 times
Total time:   0.968761
 Self time:   0.727311

count  total (s)   self (s)
  226   0.034609   0.003119   let input = deoplete#util#get_input(a:event)
                            
  226   0.062300   0.005503   let [filetype, filetypes, same_filetypes] = deoplete#util#get_context_filetype(input, a:event)
                            
  226   0.006786   0.003960   let sources = deoplete#util#convert2list(a:sources)
  226              0.001554   if a:event !=# 'Manual' && empty(sources)
                                " Use default sources
  226   0.040384   0.003973     let sources = deoplete#custom#_get_filetype_option( 'sources', filetype, [])
  226              0.000410   endif
                            
  226   0.005940   0.003953   let event = (deoplete#util#get_prev_event() ==# 'Refresh') ? 'Manual' : a:event
                            
  226              0.008357   let width = winwidth(0) - col('.') + len(matchstr(input, '\w*$'))
  226              0.001499   let max_width = (width * 2 / 3)
                            
  226              0.003535   let bufnr = expand('<abuf>') !=# '' ? expand('<abuf>') : bufnr('%')
  226              0.003319   let bufname = bufname(bufnr)
  226              0.121665   let bufpath = fnamemodify(bufname, ':p')
  226              0.060496   if !filereadable(bufpath) || getbufvar(bufnr, '&buftype') =~# 'nofile'
    6              0.000047     let bufpath = ''
    6              0.000014   endif
                            
  226   0.612328   0.500389   return { 'changedtick': b:changedtick, 'event': event, 'input': input, 'is_windows': s:is_windows, 'next_input': deoplete#util#get_next_input(a:event), 'complete_str': '', 'encoding': &encoding, 'position': getpos('.'), 'filetype': filetype, 'filetypes': filetypes, 'same_filetypes': same_filetypes, 'ignorecase': deoplete#custom#_get_option('ignore_case'), 'smartcase': deoplete#custom#_get_option('smart_case'), 'camelcase': deoplete#custom#_get_option('camel_case'), 'delay': deoplete#custom#_get_option('auto_complete_delay'), 'sources': sources, 'max_abbr_width': max_width, 'max_kind_width': max_width, 'max_menu_width': max_width, 'bufnr': bufnr, 'bufname': bufname, 'bufpath': bufpath, 'cwd': getcwd(), 'vars': filter(copy(g:),       "stridx(v:key, 'deoplete#') == 0        && v:key !=# 'deoplete#_yarp'"), 'bufvars': filter(copy(b:), "stridx(v:key, 'deoplete_') == 0"), 'custom': deoplete#custom#_get(), 'omni__omnifunc': &l:omnifunc, 'dict__dictionary': &l:dictionary, }

FUNCTION  deoplete#util#convert2list()
Called 749 times
Total time:   0.008189
 Self time:   0.008189

count  total (s)   self (s)
  749              0.007379   return type(a:expr) ==# v:t_list ? a:expr : [a:expr]

FUNCTION  <SNR>124_completion_timer_start()
Called 485 times
Total time:   0.073631
 Self time:   0.029615

count  total (s)   self (s)
  485              0.002926   if exists('s:completion_timer')
  481   0.013437   0.004171     call s:completion_timer_stop()
  481              0.000646   endif
                            
  485   0.046056   0.011305   let delay = max([20, deoplete#custom#_get_option('auto_complete_delay')])
  485              0.008957   let s:completion_timer = timer_start( delay, {-> s:completion_begin(a:event)})

FUNCTION  neomake#quickfix#is_enabled()
Called 11 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
   11              0.000018     return s:is_enabled

FUNCTION  <SNR>21_log()
Called 1906 times
Total time:   0.102879
 Self time:   0.058408

count  total (s)   self (s)
 1906              0.009306     let context = a:0 ? a:1 : {}
 1906   0.063908   0.019436     let verbosity = neomake#utils#get_verbosity(context)
 1906              0.010118     let logfile = get(g:, 'neomake_logfile', '')
                            
 1906              0.012008     if !s:is_testing && verbosity < a:level && empty(logfile)
 1906              0.002825         return
                                endif
                            
                                if a:0
                                    let msg = printf('[%s.%s:%s:%d] %s', get(context, 'make_id', '-'), get(context, 'id', '-'), get(context, 'bufnr', get(context, 'file_mode', 0) ? '?' : '-'), winnr(), a:msg)
                                else
                                    let msg = a:msg
                                endif
                            
                                " Use Vader's log for messages during tests.
                                " @vimlint(EVL104, 1, l:timediff)
                                if s:is_testing && (verbosity >= a:level || get(g:, 'neomake_test_log_all_messages', 0))
                                    let timediff = s:reltime_lastmsg()
                                    if timediff !=# '     '
                                        let test_msg = '['.s:short_level_to_name[a:level].' '.timediff.']: '.msg
                                    else
                                        let test_msg = '['.s:level_to_name[a:level].']: '.msg
                                    endif
                            
                                    call vader#log(test_msg)
                                    " Only keep context entries that are relevant for / used in the message.
                                    let context = a:0 ? filter(copy(context), "index(['id', 'make_id', 'bufnr'], v:key) != -1") : {}
                                    call add(g:neomake_test_messages, [a:level, a:msg, context])
                                    if index(['.', '!', ')', ']'], a:msg[-1:-1]) == -1
                                        let g:neomake_test_errors += ['Log msg does not end with punctuation: "'.a:msg.'".']
                                    endif
                                elseif verbosity >= a:level
                                    redraw
                                    if a:level ==# 0
                                        echohl ErrorMsg
                                    elseif a:level ==# 1
                                        echohl WarningMsg
                                    endif
                                    if verbosity > 2
                                        echom 'Neomake: '.msg
                                    else
                                        " Use message without context for non-debug msgs.
                                        echom 'Neomake: '.a:msg
                                    endif
                                    if a:level ==# 0 || a:level ==# 1
                                        echohl None
                                    endif
                                endif
                                if !empty(logfile) && type(logfile) ==# type('')
                                    if !exists('s:logfile_writefile_opts')
                                        " Use 'append' with writefile, but only if it is available.  Otherwise, just
                                        " overwrite the file.  'S' is used to disable fsync in Neovim
                                        " (https://github.com/neovim/neovim/pull/6427).
                                        let s:can_append_to_logfile = v:version > 704 || (v:version == 704 && has('patch503'))
                                        if !s:can_append_to_logfile
                                            redraw
                                            echohl WarningMsg
                                            echom 'Neomake: appending to the logfile is not supported in your Vim version.'
                                            echohl NONE
                                        endif
                                        let s:logfile_writefile_opts = s:can_append_to_logfile ? 'aS' : ''
                                    endif
                            
                                    let date = strftime('%H:%M:%S')
                                    if !exists('timediff')
                                        let timediff = s:reltime_lastmsg()
                                    endif
                                    try
                                        call writefile([printf('%s [%s %s] %s', date, s:short_level_to_name[a:level], timediff, msg)], logfile, s:logfile_writefile_opts)
                                    catch
                                        unlet g:neomake_logfile
                                        call neomake#log#error(printf('Error when trying to write to logfile %s: %s.  Unsetting g:neomake_logfile.', logfile, v:exception))
                                    endtry
                                endif
                                " @vimlint(EVL104, 0, l:timediff)

FUNCTION  deoplete#util#uniq()
Called 596 times
Total time:   0.097221
 Self time:   0.097221

count  total (s)   self (s)
  596              0.013341   let list = map(copy(a:list), '[v:val, v:val]')
  596              0.001954   let i = 0
  596              0.001745   let seen = {}
 2882              0.010764   while i < len(list)
 2286              0.013658     let key = string(list[i][1])
 2286              0.008168     if has_key(seen, key)
   73              0.000573       call remove(list, i)
   73              0.000104     else
 2213              0.007906       let seen[key] = 1
 2213              0.004808       let i += 1
 2213              0.002120     endif
 2286              0.003234   endwhile
  596              0.007363   return map(list, 'v:val[0]')

FUNCTION  <SNR>19_disabled_for_ft()
Called 163 times
Total time:   0.141348
 Self time:   0.008659

count  total (s)   self (s)
  163              0.000704     let bufnr = +a:bufnr
  163              0.001170     let ft = getbufvar(bufnr, '&filetype')
  163   0.135236   0.002547     if index(neomake#config#get('automake.ignore_filetypes', []), ft) != -1
                                    if a:0
                                        call s:debug_log(printf('%s: skipping setup for filetype=%s', a:1, ft), {'bufnr': bufnr})
                                    else
                                        call s:debug_log(printf('skipping callback for filetype=%s', ft), {'bufnr': bufnr})
                                    endif
                                    return 1
                                endif
  163              0.000328     return 0

FUNCTION  airline#extensions#po#apply()
Called 25 times
Total time:   0.000232
 Self time:   0.000232

count  total (s)   self (s)
   25              0.000110   if &ft ==# 'po'
                                call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                " Also reset the cache variable, if a window has been split, e.g. the winwidth changed
                                autocmd airline BufWritePost * unlet! b:airline_po_stats
                                autocmd airline WinEnter * call airline#extensions#po#on_winenter()
                              endif

FUNCTION  <SNR>32_joinUndo()
Called 19 times
Total time:   0.000384
 Self time:   0.000384

count  total (s)   self (s)
   19              0.000169   if v:version < 704 || ( v:version == 704 && !has('patch849') )
                                return ''
                              endif
   19              0.000082   return "\<C-G>U"

FUNCTION  <SNR>121_vimoption2python()
Called 527 times
Total time:   0.236877
 Self time:   0.150927

count  total (s)   self (s)
  527              0.002092   let has_dash = 0
  527              0.001521   let patterns = []
 2675              0.014076   for pattern in split(a:option, ',')
 2148              0.019161     if pattern =~# '\d\+'
 1050              0.026695       let pattern = substitute(pattern, '\d\+', '\=nr2char(submatch(0))', 'g')
 1050              0.001569     endif
                            
 2148              0.004874     if pattern ==# ''
                                  " ,
    8              0.000007       call add(patterns, ',')
    8              0.000004     elseif pattern ==# '\'
                                  call add(patterns, '\\')
                                elseif pattern ==# '-'
    4              0.000003       let has_dash = 1
    4              0.000001     else
 2136              0.009801       call add(patterns, pattern)
 2136              0.002208     endif
 2148              0.003581   endfor
                            
                              " Dash must be last.
  527              0.001139   if has_dash
    4              0.000005     call add(patterns, '-')
    4              0.000002   endif
                            
  527   0.098453   0.012504   return join(deoplete#util#uniq(patterns), '')

FUNCTION  gitgutter#utility#cd_cmd()
Called 20 times
Total time:   0.126579
 Self time:   0.000996

count  total (s)   self (s)
   20   0.019202   0.000591   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() ? 'cd /d' : 'cd')
   20   0.107341   0.000368   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  LanguageClient#Notify()
Called 578 times
Total time:   0.085402
 Self time:   0.052553

count  total (s)   self (s)
  578              0.005355     let l:params = a:params
  578              0.004868     if type(params) == s:TYPE.dict
  578              0.013511         let l:params = extend({ 'buftype': &buftype, 'languageId': &filetype, }, l:params)
  578              0.001473     endif
  578   0.058327   0.025478     return LanguageClient#Write(json_encode({ 'jsonrpc': '2.0', 'method': a:method, 'params': l:params, }))

FUNCTION  delimitMate#ParenDelim()
Called 14 times
Total time:   0.011615
 Self time:   0.003386

count  total (s)   self (s)
   14   0.001863   0.000456   let left = s:get('left_delims')[index(s:get('right_delims'),a:right)]
   14   0.004893   0.000224   if s:is_forbidden(a:right)
                                return left
                              endif
                              " Try to balance matchpairs
   14   0.000623   0.000189   if s:get('balance_matchpairs') && s:balance_matchpairs(a:right) < 0
                                return left
                              endif
   14              0.000078   let line = getline('.')
   14              0.000069   let col = col('.')-2
   14   0.000531   0.000125   if s:get('smart_matchpairs') != ''
   14   0.000808   0.000404     let smart_matchpairs = substitute(s:get('smart_matchpairs'), '\\!', left, 'g')
   14              0.000169     let smart_matchpairs = substitute(smart_matchpairs, '\\#', a:right, 'g')
   14              0.000587     if line[col+1:] =~ smart_matchpairs
                                  return left
                                endif
   14              0.000018   endif
   14   0.000515   0.000175   if len(line) == (col + 1) && s:get('insert_eol_marker') == 1
   11   0.000410   0.000095     let tail = s:get('eol_marker')
   11              0.000015   else
    3              0.000009     let tail = ''
    3              0.000004   endif
   14   0.000677   0.000424   return left . a:right . tail . repeat(s:joinUndo() . "\<Left>", len(split(tail, '\zs')) + 1)

FUNCTION  <SNR>107_build_sections()
Called 50 times
Total time:   0.015260
 Self time:   0.002574

count  total (s)   self (s)
  250              0.000384   for key in a:keys
  200              0.000403     if (key == 'warning' || key == 'error') && !a:context.active
                                  continue
                                endif
  200   0.013642   0.000956     call s:add_section(a:builder, a:context, key)
  200              0.000161   endfor

FUNCTION  airline#util#doautocmd()
Called 43 times
Total time:   0.007606
 Self time:   0.001923

count  total (s)   self (s)
   43   0.007488   0.001805   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  <SNR>19_get_setting()
Called 162 times
Total time:   0.003311
 Self time:   0.003311

count  total (s)   self (s)
  162              0.003087     return get(get(b:, 'neomake', {}), a:name, get(get(t:, 'neomake', {}), a:name, get(get(g:, 'neomake', {}), a:name, a:default)))

FUNCTION  <SNR>110_can_diffoff()
Called 2 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    2              0.000028   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  neomake#makers#ft#rust#FillErrorFromSpan()
Called 7 times
Total time:   0.000089
 Self time:   0.000089

count  total (s)   self (s)
    7              0.000029     let a:error.filename = a:span.file_name
    7              0.000015     let a:error.col = a:span.column_start
    7              0.000012     let a:error.lnum = a:span.line_start
    7              0.000020     let a:error.length = a:span.byte_end - a:span.byte_start

FUNCTION  <SNR>90_update_hg_branch()
Called 3068 times
Total time:   0.383285
 Self time:   0.353275

count  total (s)   self (s)
 3068   0.058479   0.028468   if airline#util#has_lawrencium()
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    noa call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    noa call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    noa call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
                              else
 3068              0.019184     let s:vcs_config['mercurial'].branch = ''
 3068              0.004544   endif

FUNCTION  FugitiveIsGitDir()
Called 6 times
Total time:   0.000316
 Self time:   0.000316

count  total (s)   self (s)
    6              0.000051   let path = substitute(a:path, '[\/]$', '', '') . '/'
    6              0.000260   return getfsize(path.'HEAD') > 10 && ( isdirectory(path.'objects') && isdirectory(path.'refs') || getftype(path.'commondir') ==# 'file')

FUNCTION  <SNR>31_ExtraMappings()
Called 2 times
Total time:   0.000531
 Self time:   0.000399

count  total (s)   self (s)
                              " If pair is empty, delete both delimiters:
    2              0.000022   inoremap <silent> <Plug>delimitMateBS <C-R>=delimitMate#BS()<CR>
    2              0.000030   if !hasmapto('<Plug>delimitMateBS','i')
    2              0.000019     if empty(maparg('<BS>', 'i'))
                                  silent! imap <unique> <buffer> <BS> <Plug>delimitMateBS
                                endif
    2              0.000018     if empty(maparg('<C-H>', 'i'))
                                  silent! imap <unique> <buffer> <C-h> <Plug>delimitMateBS
                                endif
    2              0.000001   endif
                              " If pair is empty, delete closing delimiter:
    2              0.000022   inoremap <silent> <expr> <Plug>delimitMateS-BS delimitMate#WithinEmptyPair() ? "\<Del>" : "\<S-BS>"
    2              0.000027   if !hasmapto('<Plug>delimitMateS-BS','i') && maparg('<S-BS>', 'i') == ''
    2              0.000016     silent! imap <unique> <buffer> <S-BS> <Plug>delimitMateS-BS
    2              0.000001   endif
                              " Expand return if inside an empty pair:
    2              0.000022   inoremap <expr><silent> <Plug>delimitMateCR <SID>TriggerAbb()."\<C-R>=delimitMate#ExpandReturn()\<CR>"
    2   0.000061   0.000012   if s:get('expand_cr') && !hasmapto('<Plug>delimitMateCR', 'i') && maparg('<CR>', 'i') == ''
                                silent! imap <unique> <buffer> <CR> <Plug>delimitMateCR
                              endif
                              " Expand space if inside an empty pair:
    2              0.000032   inoremap <expr><silent> <Plug>delimitMateSpace <SID>TriggerAbb()."\<C-R>=delimitMate#ExpandSpace()\<CR>"
    2   0.000056   0.000015   if s:get('expand_space') && !hasmapto('<Plug>delimitMateSpace', 'i') && maparg('<Space>', 'i') == ''
                                silent! imap <unique> <buffer> <Space> <Plug>delimitMateSpace
                              endif
                              " Jump over any delimiter:
    2              0.000024   inoremap <expr><silent> <Plug>delimitMateS-Tab <SID>TriggerAbb()."\<C-R>=delimitMate#JumpAny()\<CR>"
    2   0.000084   0.000042   if s:get('tab2exit') && !hasmapto('<Plug>delimitMateS-Tab', 'i') && maparg('<S-Tab>', 'i') == ''
                                silent! imap <unique> <buffer> <S-Tab> <Plug>delimitMateS-Tab
                              endif
                              " Jump over next delimiters
    2              0.000023   inoremap <expr><buffer> <Plug>delimitMateJumpMany <SID>TriggerAbb()."\<C-R>=delimitMate#JumpMany()\<CR>"
    2              0.000026   if !hasmapto('<Plug>delimitMateJumpMany', 'i') && maparg("<C-G>g", 'i') == ''
    2              0.000017     imap <silent> <buffer> <C-G>g <Plug>delimitMateJumpMany
    2              0.000001   endif

FUNCTION  neomake#highlights#AddHighlight()
Called 8 times
Total time:   0.000440
 Self time:   0.000419

count  total (s)   self (s)
                                " Some makers use line 0 for file warnings (which cannot be highlighted,
                                " e.g. cpplint with "no copyright" warnings).
    8              0.000016     if a:entry.lnum == 0
                                    return
                                endif
                            
    8              0.000030     if !has_key(s:highlights[a:type], a:entry.bufnr)
    1   0.000042   0.000021         call s:InitBufHighlights(a:type, a:entry.bufnr)
    1              0.000001     endif
    8              0.000042     let l:hi = get(s:highlight_types, toupper(a:entry.type), 'NeomakeError')
    8              0.000017     if get(g:, 'neomake_highlight_lines', 0)
                                    if s:nvim_api
                                        call nvim_buf_add_highlight(a:entry.bufnr, s:highlights[a:type][a:entry.bufnr], l:hi, a:entry.lnum - 1, 0, -1)
                                    else
                                        call add(s:highlights[a:type][a:entry.bufnr][l:hi], a:entry.lnum)
                                    endif
                                elseif a:entry.col > 0
    8              0.000023         let l:length = get(a:entry, 'length', 1)
    8              0.000009         if s:nvim_api
    8              0.000079             call nvim_buf_add_highlight(a:entry.bufnr, s:highlights[a:type][a:entry.bufnr], l:hi, a:entry.lnum - 1, a:entry.col - 1, a:entry.col + l:length - 1)
    8              0.000006         else
                                        call add(s:highlights[a:type][a:entry.bufnr][l:hi], [a:entry.lnum, a:entry.col, l:length])
                                    endif
    8              0.000005     endif

FUNCTION  <SNR>82_process_pending_output()
Called 11 times
Total time:   0.038117
 Self time:   0.000174

count  total (s)   self (s)
   11   0.000629   0.000066     let retry_events = s:need_to_postpone_output_processing(a:jobinfo)
   11              0.000013     if empty(retry_events)
   11   0.037446   0.000066         if s:ProcessPendingOutput(a:jobinfo, a:lines, a:source)
   11              0.000013             return g:neomake#action_queue#processed
                                    endif
                                    if a:0
                                        let retry_events = a:1
                                    else
                                        let retry_events = ['BufEnter', 'WinEnter']
                                    endif
                                endif
                                let a:jobinfo.pending_output = 1
                                return neomake#action_queue#add(retry_events, [s:function('s:process_pending_output'), [a:jobinfo, a:lines, a:source, retry_events]])

FUNCTION  <SNR>82_need_to_postpone_loclist()
Called 44 times
Total time:   0.000277
 Self time:   0.000277

count  total (s)   self (s)
   44              0.000053     if !a:jobinfo.file_mode
                                    return 0
                                endif
   44              0.000128     if index(get(w:, 'neomake_make_ids', []), a:jobinfo.make_id) != -1
   44              0.000024         return 0
                                endif
                                call neomake#log#debug('Postponing location list processing.', a:jobinfo)
                                return 1

FUNCTION  <SNR>82_exit_handler()
Called 41 times
Total time:   0.162868
 Self time:   0.002889

count  total (s)   self (s)
   41              0.000125     let jobinfo = a:jobinfo
   41              0.000102     let jobinfo.exit_code = a:data
   41              0.000084     if get(jobinfo, 'canceled')
   30   0.001477   0.000154         call neomake#log#debug('exit: job was canceled.', jobinfo)
   30   0.081363   0.000394         call s:CleanJobinfo(jobinfo)
   30              0.000020         return
                                endif
   11              0.000016     let maker = jobinfo.maker
                            
   11              0.000031     if exists('jobinfo._output_while_in_handler') || exists('jobinfo._nvim_in_handler')
                                    let jobinfo._exited_while_in_handler = a:data
                                    call neomake#log#debug(printf('exit (delayed): %s: %s.', maker.name, string(a:data)), jobinfo)
                                    return
                                endif
   11   0.000403   0.000074     call neomake#log#debug(printf('exit: %s: %s.', maker.name, string(a:data)), jobinfo)
                            
                                " Handle any unfinished lines from stdout/stderr callbacks.
   33              0.000046     for event_type in ['stdout', 'stderr']
   22              0.000034         if has_key(jobinfo, event_type)
   22              0.000083             let lines = jobinfo[event_type]
   22              0.000024             if !empty(lines)
   22              0.000029                 if lines[-1] ==# ''
   22              0.000039                     call remove(lines, -1)
   22              0.000010                 endif
   22              0.000018                 if !empty(lines)
   11   0.045217   0.000072                     call s:RegisterJobOutput(jobinfo, lines, event_type)
   11              0.000007                 endif
   22              0.000038                 unlet jobinfo[event_type]
   22              0.000008             endif
   22              0.000007         endif
   22              0.000011     endfor
                            
   11              0.000015     if !get(jobinfo, 'failed_to_start')
   11   0.006110   0.000391         let l:ExitCallback = neomake#utils#GetSetting('exit_callback', extend(copy(jobinfo), maker), 0, jobinfo.ft, jobinfo.bufnr)
   11              0.000017         if l:ExitCallback isnot# 0
                                        let callback_dict = { 'status': jobinfo.exit_code, 'name': maker.name, 'has_next': !empty(s:make_info[jobinfo.make_id].jobs_queue) }
                                        try
                                            if type(l:ExitCallback) == type('')
                                                let l:ExitCallback = function(l:ExitCallback)
                                            endif
                                            call call(l:ExitCallback, [callback_dict], jobinfo)
                                        catch
                                            call neomake#log#error(printf( 'Error during exit_callback: %s.', v:exception), jobinfo)
                                        endtry
                                    endif
   11              0.000006     endif
                            
   11              0.000010     if s:async
   11              0.000061         if has('nvim') || jobinfo.exit_code != 122
   11   0.000549   0.000131             call neomake#log#debug(printf( '%s: completed with exit code %d.', maker.name, jobinfo.exit_code), jobinfo)
   11              0.000005         endif
   11              0.000025         let jobinfo.finished = 1
   11              0.000005     endif
                            
   11              0.000017     if has_key(jobinfo, 'unexpected_output')
                                    redraw
                                    for [source, output] in items(jobinfo.unexpected_output)
                                        let msg = printf('%s: unexpected output on %s: ', maker.name, source)
                                        call neomake#log#debug(msg . join(output, '\n') . '.', jobinfo)
                            
                                        echohl WarningMsg
                                        echom printf('Neomake: %s%s', msg, output[0])
                                        for line in output[1:-1]
                                            echom line
                                        endfor
                                        echohl None
                                    endfor
                                    call neomake#log#error(printf( '%s: unexpected output. See :messages for more information.', maker.name), jobinfo)
                                endif
   11   0.026171   0.000095     call s:handle_next_job(jobinfo)

FUNCTION  <SNR>19_getbufvar()
Called 1 time
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    1              0.000007     let b_dict = getbufvar(+a:bufnr, '')
    1              0.000022     if empty(b_dict)
                                    " NOTE: it is an empty string for non-existing buffers.
                                    return a:default
                                endif
    1              0.000006     return get(b_dict, a:name, a:default)

FUNCTION  <SNR>32_set()
Called 46 times
Total time:   0.001035
 Self time:   0.001035

count  total (s)   self (s)
   46              0.000103   let scope = a:0 ? a:1 : 's'
   46              0.000101   let bufnr = bufnr('%')
   46              0.000121   if !exists('s:options[bufnr]')
    1              0.000004     let s:options[bufnr] = {}
    1              0.000002   endif
   46              0.000049   if scope == 's'
   46              0.000113     let name = 's:options.' . bufnr . '.' . a:name
   46              0.000022   else
                                let name = scope . ':delimitMate_' . a:name
                                if exists('name')
                                  exec 'unlet! ' . name
                                endif
                              endif
   46              0.000208   exec 'let ' . name . ' = a:value'

FUNCTION  <SNR>118_ReceiveMessages()
Called 2 times
Total time:   0.002769
 Self time:   0.000096

count  total (s)   self (s)
    2   0.002710   0.000037   let poll_again = s:Pyeval( 'ycm_state.OnPeriodicTick()' )
                            
    2              0.000009   if poll_again
    1              0.000018     let s:pollers.receive_messages.id = timer_start( s:pollers.receive_messages.wait_milliseconds, function( 's:ReceiveMessages' ) )
    1              0.000001   else
                                " Don't poll again until we open another buffer
    1              0.000006     let s:pollers.receive_messages.id = -1
    1              0.000002   endif

FUNCTION  neomake#log#debug_obj()
Called 1 time
Total time:   0.000012
 Self time:   0.000007

count  total (s)   self (s)
    1   0.000010   0.000004     if s:is_testing || neomake#utils#get_verbosity() >= 3 || !empty(get(g:, 'neomake_logfile', ''))
                                    call neomake#log#debug(a:msg.': '.neomake#utils#Stringify(a:obj).'.')
                                endif

FUNCTION  <SNR>132_valid_dir()
Called 20 times
Total time:   0.001135
 Self time:   0.001135

count  total (s)   self (s)
   20              0.000970   if empty(a:dir) || !isdirectory(a:dir)
                                return getcwd()
                              endif
   20              0.000034   return a:dir

FUNCTION  gitgutter#diff#parse_diff()
Called 18 times
Total time:   0.005303
 Self time:   0.002035

count  total (s)   self (s)
   18              0.000082   let hunks = []
   81              0.000476   for line in split(a:diff, '\n')
   63   0.003944   0.000676     let hunk_info = gitgutter#diff#parse_hunk(line)
   63              0.000161     if len(hunk_info) == 4
   63              0.000219       call add(hunks, hunk_info)
   63              0.000065     endif
   63              0.000064   endfor
   18              0.000044   return hunks

FUNCTION  neomake#statusline#LoclistCounts()
Called 6136 times
Total time:   0.164459
 Self time:   0.164459

count  total (s)   self (s)
 6136              0.064498     let buf = a:0 ? a:1 : bufnr('%')
 6136              0.019607     if buf is# 'all'
                                    return s:counts
                                endif
 6136              0.046101     return get(s:counts, buf, {})

FUNCTION  145()
Called 1 time
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
                                " Resolve args, which might be a function or dictionary.
    1              0.000007     if type(self.args) == type(function('tr'))
                                    " Deprecated: use InitForJob
                                    call neomake#log#warn_once(printf("Please use 'InitForJob' instead of 'args' for maker %s.", self.name), printf('deprecated-args-%s', self.name))
                                    let args = call(self.args, [])
                                elseif type(self.args) == type({})
                                    " Deprecated: use InitForJob
                                    call neomake#log#warn_once(printf("Please use 'InitForJob' instead of 'args.fn' for maker %s.", self.name), printf('deprecated-args-fn-%s', self.name))
                                    let args = call(self.args.fn, [], self.args)
                                else
    1              0.000002         let args = copy(self.args)
    1              0.000001     endif
    1              0.000004     let self.args = args
    1              0.000001     return self

FUNCTION  146()
Called 41 times
Total time:   0.134189
 Self time:   0.003992

count  total (s)   self (s)
   41   0.122745   0.000584     let filename = self._get_fname_for_args(a:jobinfo)
   41              0.000369     let args_is_list = type(self.args) == type([])
   41              0.000092     if args_is_list
   41   0.008470   0.000910         let args = neomake#utils#ExpandArgs(self.args)
   41              0.000191         if !empty(filename)
                                        call add(args, filename)
                                    endif
   41              0.000129     elseif !empty(filename)
                                    let args = copy(self.args)
                                    let args .= (empty(args) ? '' : ' ').neomake#utils#shellescape(filename)
                                else
                                    let args = self.args
                                endif
   41   0.001277   0.000800     return neomake#compat#get_argv(self.exe, args, args_is_list)

FUNCTION  gitgutter#diff#process_hunks()
Called 18 times
Total time:   0.022067
 Self time:   0.001720

count  total (s)   self (s)
   18              0.000056   let modified_lines = []
   81              0.000235   for hunk in a:hunks
   63   0.021442   0.001095     call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
   63              0.000107   endfor
   18              0.000039   return modified_lines

FUNCTION  neomake#makers#ft#rust#EnabledMakers()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004     return ['cargo']

FUNCTION  neomake#signs#CleanOldSigns()
Called 11 times
Total time:   0.000385
 Self time:   0.000336

count  total (s)   self (s)
   11              0.000050     if !has_key(s:last_placed_signs[a:type], a:bufnr)
   10              0.000006         return
                                endif
    1              0.000003     let placed_signs = s:last_placed_signs[a:type][a:bufnr]
    1              0.000002     unlet s:last_placed_signs[a:type][a:bufnr]
    1              0.000001     if bufexists(+a:bufnr)
    1   0.000019   0.000007         call neomake#log#debug_obj('Cleaning old signs in buffer '.a:bufnr, placed_signs)
    3              0.000004         for sign_id in keys(placed_signs)
    2              0.000005             let cmd = 'sign unplace '.sign_id.' buffer='.a:bufnr
    2   0.000043   0.000006             call neomake#log#debug('Unplacing sign: '.cmd.'.')
    2              0.000219             exe cmd
    2              0.000008             if has_key(s:placed_signs[a:type], a:bufnr)
                                            if has_key(s:placed_signs[a:type][a:bufnr], sign_id)
                                                unlet s:placed_signs[a:type][a:bufnr][sign_id]
                                            endif
                                        endif
    2              0.000001         endfor
    1              0.000000     else
                                    call neomake#log#debug_obj('Skipped cleaning of old signs in non-existing buffer '.a:bufnr, placed_signs)
                                endif

FUNCTION  <SNR>103_CheckDefined()
Called 2175 times
Total time:   0.063955
 Self time:   0.063955

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
 2175              0.009831   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
                              endif
 2175              0.008204   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
                              endif
                            
 2175              0.008852   for val in a:colors
 2175              0.007084     if !empty(val) && val !=# 'NONE'
 2175              0.003254       return a:colors
                                endif
                              endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  <SNR>128_get_separator_change_with_end()
Called 12 times
Total time:   0.006859
 Self time:   0.000727

count  total (s)   self (s)
   12              0.000063   let sep_change = 0
   12              0.000064   if !empty(a:new_end_group) " Separator between title and the end
    6   0.003133   0.000147     let sep_change += airline#builder#should_change_group(a:new_group, a:new_end_group) ? a:sep_size : a:alt_sep_size
    6              0.000009   endif
   12              0.000045   if !empty(a:old_group) " Separator between the title and the one adjacent
    3   0.001867   0.000064     let sep_change += airline#builder#should_change_group(a:new_group, a:old_group) ? a:sep_size : a:alt_sep_size
    3              0.000016     if !empty(a:old_end_group) " Remove mis-predicted separator
    3   0.001396   0.000052       let sep_change -= airline#builder#should_change_group(a:old_group, a:old_end_group) ? a:sep_size : a:alt_sep_size
    3              0.000004     endif
    3              0.000003   endif
   12              0.000026   return sep_change

FUNCTION  airline#extensions#tabline#new_builder()
Called 3 times
Total time:   0.000321
 Self time:   0.000140

count  total (s)   self (s)
    3              0.000041   let builder_context = { 'active'        : 1, 'tabline'       : 1, 'right_sep'     : get(g:, 'airline#extensions#tabline#right_sep'    , g:airline_right_sep), 'right_alt_sep' : get(g:, 'airline#extensions#tabline#right_alt_sep', g:airline_right_alt_sep), }
    3              0.000008   if get(g:, 'airline_powerline_fonts', 0)
                                let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , g:airline_left_sep)
                                let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , g:airline_left_alt_sep)
                              else
    3              0.000013     let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , ' ')
    3              0.000013     let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , '|')
    3              0.000003   endif
                            
    3   0.000215   0.000034   return airline#extensions#tabline#builder#new(builder_context)

FUNCTION  deoplete#init#_channel_initialized()
Called 226 times
Total time:   0.002296
 Self time:   0.002296

count  total (s)   self (s)
  226              0.002029   return get(g:, 'deoplete#_initialized', v:false)

FUNCTION  <SNR>108_AddHighlights()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000002     for hl in a:highlights
                                    call nvim_buf_add_highlight(0, a:source, hl.group, hl.line, hl.character_start, hl.character_end)
                                endfor

FUNCTION  airline#extensions#tabline#add_label()
Called 3 times
Total time:   0.000102
 Self time:   0.000043

count  total (s)   self (s)
    3              0.000009   if get(g:, 'airline#extensions#tabline#show_tab_type', 1)
    3   0.000088   0.000029     call a:dict.add_section_spaced('airline_tablabel', get(g:, 'airline#extensions#tabline#'.a:type.'_label', a:type))
    3              0.000002   endif

FUNCTION  <SNR>118_OnCompleteDone()
Called 118 times
Total time:   0.236842
 Self time:   0.223185

count  total (s)   self (s)
  118   0.015082   0.001425   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
  118              0.221219   exec s:python_command "ycm_state.OnCompleteDone()"

FUNCTION  152()
Called 28 times
Total time:   0.000122
 Self time:   0.000122

count  total (s)   self (s)
   28              0.000104   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  153()
Called 3 times
Total time:   0.000059
 Self time:   0.000046

count  total (s)   self (s)
    3              0.000017   let spc = empty(a:contents) ? '' : g:airline_symbols.space
    3   0.000040   0.000027   call self.add_section(a:group, spc.a:contents.spc)

FUNCTION  154()
Called 209 times
Total time:   0.000789
 Self time:   0.000789

count  total (s)   self (s)
  209              0.000707   call add(self._sections, [a:group, a:contents])

FUNCTION  156()
Called 6 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    6              0.000058   call insert(self._sections, [a:group, a:contents], a:position)

FUNCTION  157()
Called 12 times
Total time:   0.000130
 Self time:   0.000130

count  total (s)   self (s)
   12              0.000119   call insert(self._sections, ['', a:text], a:position)

FUNCTION  neomake#postprocess#compress_whitespace()
Called 3 times
Total time:   0.000229
 Self time:   0.000229

count  total (s)   self (s)
    3              0.000013     let text = a:entry.text
    3              0.000027     let text = substitute(text, "\001", '', 'g')
    3              0.000061     let text = substitute(text, '\r\?\n', ' ', 'g')
    3              0.000054     let text = substitute(text, '\m\s\{2,}', ' ', 'g')
    3              0.000031     let text = substitute(text, '\m^\s\+', '', '')
    3              0.000026     let text = substitute(text, '\m\s\+$', '', '')
    3              0.000006     let a:entry.text = text

FUNCTION  airline#extensions#default#apply()
Called 25 times
Total time:   0.017513
 Self time:   0.001275

count  total (s)   self (s)
   25              0.000071   let winnr = a:context.winnr
   25              0.000037   let active = a:context.active
                            
   25   0.000250   0.000144   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
   25   0.006076   0.000242     call s:build_sections(a:builder, a:context, s:layout[0])
   25              0.000021   else
                                let text = s:get_section(winnr, 'c')
                                if empty(text)
                                  let text = ' %f%m '
                                endif
                                call a:builder.add_section('airline_c'.(a:context.bufnr), text)
                              endif
                            
   25   0.001027   0.000210   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
   25   0.000137   0.000082   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
   25   0.009599   0.000172     call s:build_sections(a:builder, a:context, s:layout[1])
   25              0.000014   endif
                            
   25              0.000023   return 1

FUNCTION  <SNR>124_is_exiting()
Called 374 times
Total time:   0.005011
 Self time:   0.005011

count  total (s)   self (s)
  374              0.004350   return exists('v:exiting') && v:exiting != v:null

FUNCTION  neomake#utils#get_verbosity()
Called 1918 times
Total time:   0.044629
 Self time:   0.035040

count  total (s)   self (s)
 1918              0.010575     if a:0 && has_key(a:1, 'make_id')
  589   0.013613   0.004024         return neomake#GetMakeOptions(a:1.make_id).verbosity
                                endif
 1329              0.009008     return get(g:, 'neomake_verbose', 1) + &verbose

FUNCTION  airline#highlighter#get_highlight()
Called 4161 times
Total time:   0.566939
 Self time:   0.270416

count  total (s)   self (s)
 4161              0.063235   let reverse = get(g:, 'airline_gui_mode', '') ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
 4161              0.017395   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                let res = s:hl_groups[a:group]
                                return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
                              else
 4161   0.163550   0.030786     let fg = s:get_syn(a:group, 'fg')
 4161   0.142261   0.024446     let bg = s:get_syn(a:group, 'bg')
 4161              0.022670     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
 4161              0.007512     let opts = a:000
 4161              0.004299     if bold
  396              0.001215       let opts = ['bold']
  396              0.000360     endif
 4161   0.081065   0.035122     let res = reverse ? s:get_array(bg, fg, opts) : s:get_array(fg, bg, opts)
 4161              0.003621   endif
 4161              0.015977   let s:hl_groups[a:group] = res
 4161              0.004580   return res

FUNCTION  <SNR>118_InsideCommentOrStringAndShouldStop()
Called 158 times
Total time:   0.036973
 Self time:   0.004896

count  total (s)   self (s)
  158   0.033863   0.001785   let retval = s:InsideCommentOrString()
  158              0.000653   let inside_comment = retval == 1
  158              0.000439   let inside_string = retval == 2
                            
  158              0.000911   if inside_comment && g:ycm_complete_in_comments || inside_string && g:ycm_complete_in_strings
   27              0.000039     return 0
                              endif
                            
  131              0.000227   return retval

FUNCTION  deoplete#mapping#_restore_completeopt()
Called 81 times
Total time:   0.001913
 Self time:   0.001826

count  total (s)   self (s)
   81              0.000667   if exists('g:deoplete#_saved_completeopt')
   13   0.000303   0.000216     let &completeopt = g:deoplete#_saved_completeopt
   13              0.000053     unlet g:deoplete#_saved_completeopt
   13              0.000020   endif

FUNCTION  <SNR>80_get_line_trimmed()
Called 70 times
Total time:   0.012280
 Self time:   0.012280

count  total (s)   self (s)
                            	" Get the line and remove a trailing comment.
                            	" Use syntax highlighting attributes when possible.
                            	" NOTE: this is not accurate; /* */ or a line continuation could trick it
   70              0.000322 	let line = getline(a:lnum)
   70              0.000265 	let line_len = strlen(line)
   70              0.000375 	if has('syntax_items')
                            		" If the last character in the line is a comment, do a binary search for
                            		" the start of the comment.  synID() is slow, a linear search would take
                            		" too long on a long line.
   70              0.008138 		if synIDattr(synID(a:lnum, line_len, 1), "name") =~ 'Comment\|Todo'
                            			let min = 1
                            			let max = line_len
                            			while min < max
                            				let col = (min + max) / 2
                            				if synIDattr(synID(a:lnum, col, 1), "name") =~ 'Comment\|Todo'
                            					let max = col
                            				else
                            					let min = col + 1
                            				endif
                            			endwhile
                            			let line = strpart(line, 0, min - 1)
                            		endif
   70              0.001143 		return substitute(line, "\s*$", "", "")
                            	else
                            		" Sorry, this is not complete, nor fully correct (e.g. string "//").
                            		" Such is life.
                            		return substitute(line, "\s*//.*$", "", "")
                            	endif

FUNCTION  airline#highlighter#get_highlight2()
Called 96 times
Total time:   0.021524
 Self time:   0.003781

count  total (s)   self (s)
   96   0.009544   0.001275   let fg = s:get_syn(a:fg[0], a:fg[1])
   96   0.008598   0.001310   let bg = s:get_syn(a:bg[0], a:bg[1])
   96   0.003248   0.001063   return s:get_array(fg, bg, a:000)

FUNCTION  <SNR>23_bind_makers_for_job()
Called 1 time
Total time:   0.034319
 Self time:   0.000075

count  total (s)   self (s)
    1              0.000002     let r = []
    2              0.000003     for maker in a:makers
    1              0.000004         let options = copy(a:options)
    1              0.000001         try
    1   0.034267   0.000024             let maker = neomake#core#instantiate_maker(maker, options, 1)
    1              0.000003         catch /^Neomake: /
                                        let error = substitute(v:exception, '^Neomake: ', '', '').'.'
                                        call neomake#log#error(error, options)
                                        continue
                                    endtry
    1              0.000002         if !empty(maker)
    1              0.000004             let options.maker = maker
    1              0.000002             let r += [options]
    1              0.000000         endif
    1              0.000002     endfor
    1              0.000002     return r

FUNCTION  164()
Called 31 times
Total time:   0.001269
 Self time:   0.001269

count  total (s)   self (s)
   31              0.000074     let extra = []
   93              0.000182     for k in ['canceled', 'finished']
   62              0.000176         if get(self, k, 0)
   31              0.000103             let extra += [k]
   31              0.000029         endif
   62              0.000049     endfor
   31              0.000335     return printf('Job %d: %s%s', self.id, self.name, empty(extra) ? '' : ' ['.join(extra, ', ').']')

FUNCTION  165()
Called 63 times
Total time:   0.000759
 Self time:   0.000759

count  total (s)   self (s)
   63              0.000361     if !empty(self.cd_back_cmd)
                                    exe self.cd_back_cmd
                                    let self.cd_back_cmd = ''
                                endif

FUNCTION  166()
Called 63 times
Total time:   0.092224
 Self time:   0.035302

count  total (s)   self (s)
   63              0.000185     if a:0
                                    if has_key(self, 'cd_from_setting')
                                        call neomake#log#debug(printf( 'jobinfo.cd(): keeping cwd from setting: %s.', string(self.cd_from_setting)), self)
                                        return ''
                                    endif
                                    let dir = a:1
                                else
   63              0.000203         let maker = self.maker
   63   0.057176   0.000951         let dir = neomake#utils#GetSetting('cwd', maker, '', self.ft, self.bufnr, 1)
   63              0.000157         if !empty(dir)
   63              0.000237             let self.cd_from_setting = dir
   63              0.000066         endif
   63              0.000054     endif
                            
   63              0.000114     if dir !=# ''
   63              0.000164         if dir[0:1] ==# '%:'
                                        let dir = neomake#utils#fnamemodify(self.bufnr, dir[1:])
                                    else
   63              0.019370             let dir = expand(dir, 1)
   63              0.000239         endif
   63              0.006859         let dir = fnamemodify(dir, ':p')
                                    " NOTE: need to keep trailing backslash with "/" and "X:\" on Windows.
   63   0.002901   0.002203         if dir !=# '/' && dir[-1:] ==# neomake#utils#Slash() && dir[-2] !=# ':'
   63              0.000211             let dir = dir[:-2]
   63              0.000084         endif
   63              0.000059     else
                                    let dir = get(self, 'cwd', $HOME)
                                endif
                            
   63              0.000617     let cur_wd = getcwd()
   63              0.000154     if dir !=# cur_wd
                                    let [cd_error, cd_back_cmd] = neomake#utils#temp_cd(dir, cur_wd)
                                    if !empty(cd_error)
                                        return cd_error
                                    endif
                                    let self.cwd = dir
                                    let self.cd_back_cmd = cd_back_cmd
                                else
   63              0.000190         let self.cwd = cur_wd
   63              0.000058     endif
   63              0.000089     return ''

FUNCTION  airline#extensions#fugitiveline#bufname()
Called 3068 times
Total time:  86.144278
 Self time:  86.143174

count  total (s)   self (s)
 3068              0.019566   if !exists('b:fugitive_name')
    2              0.000005     let b:fugitive_name = ''
    2              0.000004     try
    2              0.000037       if bufname('%') =~? '^fugitive:' && exists('*FugitiveReal')
                                    let b:fugitive_name = FugitiveReal(bufname('%'))
                                  elseif exists('b:git_dir')
    2   0.000107   0.000018         let buffer = fugitive#buffer()
    2   0.001051   0.000035         if buffer.type('blob')
                                      let b:fugitive_name = buffer.repo().translate(buffer.path('/'))
                                    endif
    2              0.000001       endif
    2              0.000003     catch
                                endtry
    2              0.000001   endif
                            
 3068              0.011993   if empty(b:fugitive_name)
 3068             85.984921     return fnamemodify(bufname('%'), s:fmod)
                              else
                                return fnamemodify(b:fugitive_name, s:fmod)
                              endif

FUNCTION  168()
Called 6 times
Total time:   0.041973
 Self time:   0.000985

count  total (s)   self (s)
    6   0.001198   0.000095   let title = self.get_title(a:index)
    6   0.039643   0.000087   let title_size = s:tabline_evaluated_length(title) + a:sep_size
    6              0.000037   if a:force || self._remaining_space >= title_size
    6              0.000023     let pos = a:pos
    6              0.000040     if has_key(self, "get_pretitle")
    6   0.000373   0.000182       call self.insert_raw(self.get_pretitle(a:index), pos)
    6              0.000084       let self._right_position += 1
    6              0.000028       let pos += 1
    6              0.000011     endif
                            
    6   0.000163   0.000098     call self.insert_section(a:group, title, pos)
    6              0.000023     let self._right_position += 1
    6              0.000015     let pos += 1
                            
    6              0.000032     if has_key(self, "get_posttitle")
    6   0.000174   0.000102       call self.insert_raw(self.get_posttitle(a:index), pos)
    6              0.000021       let self._right_position += 1
    6              0.000016       let pos += 1
    6              0.000008     endif
                            
    6              0.000023     let self._remaining_space -= title_size
    6              0.000012     return 1
                              endif
                              return 0

FUNCTION  169()
Called 3 times
Total time:   0.093389
 Self time:   0.002207

count  total (s)   self (s)
    3              0.000015   if has_key(self, '_left_position') && self._first_title <= self._last_title
    3   0.008605   0.000179     let self._remaining_space = &columns - s:tabline_evaluated_length(self._build())
                            
    3              0.000024     let center_active = get(g:, 'airline#extensions#tabline#center_active', 0)
                            
    3   0.000250   0.000031     let sep_size = s:tabline_evaluated_length(self._context.left_sep)
    3   0.000205   0.000027     let alt_sep_size = s:tabline_evaluated_length(self._context.left_alt_sep)
                            
    3   0.000093   0.000028     let outer_left_group = airline#builder#get_prev_group(self._sections, self._left_position)
    3   0.000137   0.000040     let outer_right_group = airline#builder#get_next_group(self._sections, self._right_position)
                            
    3              0.000022     let overflow_marker = get(g:, 'airline#extensions#tabline#overflow_marker', g:airline_symbols.ellipsis)
    3   0.000311   0.000030     let overflow_marker_size = s:tabline_evaluated_length(overflow_marker)
                                " Allow space for the markers before we begin filling in titles.
    3              0.000011     if self._left_title > self._first_title
    3   0.000293   0.000093       let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_left_group, sep_size, alt_sep_size)
    3              0.000006     endif
    3              0.000013     if self._left_title < self._last_title
                                  let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_right_group, sep_size, alt_sep_size)
                                endif
                            
                                " Add the current title
    3   0.000493   0.000106     let group = self.get_group(self._left_title)
    3              0.000016     if self._left_title == self._first_title
                                  let sep_change = s:get_separator_change(group, "", outer_left_group, sep_size, alt_sep_size)
                                else
    3   0.002278   0.000111       let sep_change = s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
    3              0.000006     endif
    3              0.000017     if self._left_title == self._last_title
    3   0.001378   0.000065       let sep_change += s:get_separator_change(group, "", outer_right_group, sep_size, alt_sep_size)
    3              0.000004     else
                                  let sep_change += s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
                                endif
    3              0.000008     let left_group = group
    3              0.000006     let right_group = group
    3   0.037267   0.000063     let self._left_title -= self.try_insert_title(self._left_title, group, self._left_position, sep_change, 1)
                            
    3              0.000023     if get(g:, 'airline#extensions#tabline#current_first', 0)
                                  " always have current title first
                                  let self._left_position += 1
                                endif
                            
    3              0.000016     if !center_active && self._right_title <= self._last_title
                                  " Add the title to the right
                                  let group = self.get_group(self._right_title)
                                  if self._right_title == self._last_title
                                    let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                  else
                                    let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
                                  endif
                                  let right_group = group
                                  let self._right_title += self.try_insert_title(self._right_title, group, self._right_position, sep_change, 1)
                                endif
                            
    6              0.000026     while self._remaining_space > 0
    6              0.000019       let done = 0
    6              0.000024       if self._left_title >= self._first_title
                                    " Insert next title to the left
    3   0.000352   0.000038         let group = self.get_group(self._left_title)
    3              0.000012         if self._left_title == self._first_title
    3   0.003450   0.000071           let sep_change = s:get_separator_change_with_end(group, left_group, outer_left_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
    3              0.000005         else
                                      let sep_change = s:get_separator_change(group, left_group, self.overflow_group, sep_size, alt_sep_size)
                                    endif
    3              0.000014         let left_group = group
    3   0.004821   0.000052         let done = self.try_insert_title(self._left_title, group, self._left_position, sep_change, 0)
    3              0.000013         let self._left_title -= done
    3              0.000003       endif
                                  " If center_active is set, this |if| operates as an independent |if|,
                                  " otherwise as an |elif|.
    6              0.000035       if self._right_title <= self._last_title && (center_active || !done)
                                    " Insert next title to the right
                                    let group = self.get_group(self._right_title)
                                    if self._right_title == self._last_title
                                      let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                    else
                                      let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
                                    endif
                                    let right_group = group
                                    let done = self.try_insert_title(self._right_title, group, self._right_position, sep_change, 0)
                                    let self._right_title += done
                                  endif
    6              0.000014       if !done
    3              0.000007         break
                                  endif
    3              0.000006     endwhile
                            
    3              0.000011     if self._left_title >= self._first_title
                                  if get(g:, 'airline#extensions#tabline#current_first', 0)
                                    let self._left_position -= 1
                                  endif
                                  call self.insert_section(self.overflow_group, overflow_marker, self._left_position)
                                  let self._right_position += 1
                                endif
                            
    3              0.000010     if self._right_title <= self._last_title
                                  call self.insert_section(self.overflow_group, overflow_marker, self._right_position)
                                endif
    3              0.000005   endif
                            
    3   0.032233   0.000048   return self._build()

FUNCTION  airline#highlighter#add_separator()
Called 193 times
Total time:   0.091322
 Self time:   0.003534

count  total (s)   self (s)
  193              0.001292   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
  193   0.089892   0.002104   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  airline#extensions#tabline#formatters#unique_tail_improved#format()
Called 330 times
Total time:   0.531338
 Self time:   0.116692

count  total (s)   self (s)
  330              0.001710   if len(a:buffers) <= 1 " don't need to compare bufnames if has less than one buffer opened
                                return airline#extensions#tabline#formatters#default#format(a:bufnr, a:buffers)
                              endif
                            
  330              0.003326   let curbuf_tail = fnamemodify(bufname(a:bufnr), ':t')
  330              0.001106   let do_deduplicate = 0
  330              0.001111   let path_tokens = {}
                            
  990              0.003794   for nr in a:buffers
  660              0.003350     let name = bufname(nr)
  660              0.005996     if !empty(name) && nr != a:bufnr && fnamemodify(name, ':t') == curbuf_tail " only perform actions if curbuf_tail isn't unique
                                  let do_deduplicate = 1
                                  let tokens = reverse(split(substitute(fnamemodify(name, ':p:h'), '\\', '/', 'g'), '/'))
                                  let token_index = 0
                                  for token in tokens
                                    if token == '' | continue | endif
                                    if token == '.' | break | endif
                                    if !has_key(path_tokens, token_index)
                                      let path_tokens[token_index] = {}
                                    endif
                                    let path_tokens[token_index][token] = 1
                                    let token_index += 1
                                  endfor
                                endif
  660              0.001582   endfor
                            
  330              0.001101   if do_deduplicate == 1
                                let path = []
                                let token_index = 0
                                for token in reverse(split(substitute(fnamemodify(bufname(a:bufnr), ':p:h'), '\\', '/', 'g'), '/'))
                                  if token == '.' | break | endif
                                  let duplicated = 0
                                  let uniq = 1
                                  let single = 1
                                  if has_key(path_tokens, token_index)
                                    let duplicated = 1
                                    if len(keys(path_tokens[token_index])) > 1 | let single = 0 | endif
                                    if has_key(path_tokens[token_index], token) | let uniq = 0 | endif
                                  endif
                                  call insert(path, {'token': token, 'duplicated': duplicated, 'uniq': uniq, 'single': single})
                                  let token_index += 1
                                endfor
                            
                                let buf_name = [curbuf_tail]
                                let has_uniq = 0
                                let has_skipped = 0
                                for token1 in reverse(path)
                                  if !token1['duplicated'] && len(buf_name) > 1
                                    call insert(buf_name, s:skip_symbol)
                                    let has_skipped = 0
                                    break
                                  endif
                            
                                  if has_uniq == 1
                                    call insert(buf_name, s:skip_symbol)
                                    let has_skipped = 0
                                    break
                                  endif
                            
                                  if token1['uniq'] == 0 && token1['single'] == 1
                                    let has_skipped = 1
                                  else
                                    if has_skipped == 1
                                      call insert(buf_name, s:skip_symbol)
                                      let has_skipped = 0
                                    endif
                                    call insert(buf_name, token1['token'])
                                  endif
                            
                                  if token1['uniq'] == 1
                                    let has_uniq = 1
                                  endif
                                endfor
                            
                                if has_skipped == 1
                                  call insert(buf_name, s:skip_symbol)
                                endif
                            
                                return airline#extensions#tabline#formatters#default#wrap_name(a:bufnr, join(buf_name, '/'))
                              else
  330   0.420830   0.006183     return airline#extensions#tabline#formatters#default#format(a:bufnr, a:buffers)
                              endif

FUNCTION  FugitiveGitDir()
Called 3068 times
Total time:   0.039149
 Self time:   0.039149

count  total (s)   self (s)
 3068              0.012976   if !a:0 || a:1 ==# -1
 3068              0.018589     return get(b:, 'git_dir', '')
                              elseif type(a:1) == type(0)
                                return getbufvar(a:1, 'git_dir')
                              elseif type(a:1) == type('')
                                return substitute(s:Slash(a:1), '/$', '', '')
                              else
                                return ''
                              endif

FUNCTION  neomake#utils#hook()
Called 106 times
Total time:   0.003906
 Self time:   0.003906

count  total (s)   self (s)
  106              0.001703     if exists('#User#'.a:event)
                                    let jobinfo = a:0 ? a:1 : ( has_key(a:context, 'jobinfo') ? a:context.jobinfo : {})
                                    return s:handle_hook(jobinfo, a:event, a:context)
                                endif

FUNCTION  <SNR>128_get_separator_change()
Called 9 times
Total time:   0.003680
 Self time:   0.000199

count  total (s)   self (s)
    9   0.003668   0.000187   return s:get_separator_change_with_end(a:new_group, a:old_group, a:end_group, a:end_group, a:sep_size, a:alt_sep_size)

FUNCTION  airline#util#wrap()
Called 33748 times
Total time:   0.369685
 Self time:   0.369685

count  total (s)   self (s)
33748              0.167794   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
33748              0.069869   return a:text

FUNCTION  gitgutter#debug#log()
Called 38 times
Total time:   0.002688
 Self time:   0.002688

count  total (s)   self (s)
   38              0.000132   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
                              endif

FUNCTION  <SNR>47_dir()
Called 78 times
Total time:   0.146025
 Self time:   0.002954

count  total (s)   self (s)
   78   0.145855   0.002784   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  175()
Called 1 time
Total time:   0.033339
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000002         if !has_key(self, 'cwd')
    1   0.033333   0.000018             let self.cwd = s:get_cargo_maker_cwd('%:p:h')
    1              0.000002             return self
                                    endif

FUNCTION  airline#extensions#tabline#get_buffer_name()
Called 330 times
Total time:   0.548721
 Self time:   0.013830

count  total (s)   self (s)
  330   0.007993   0.004441   let buffers = a:0 ? a:1 : airline#extensions#tabline#buflist#list()
  330              0.002564   let formatter = get(g:, 'airline#extensions#tabline#formatter', 'default')
  330   0.537627   0.006289   return airline#extensions#tabline#formatters#{formatter}#format(a:nr, buffers)

FUNCTION  deoplete#util#get_keyword_pattern()
Called 523 times
Total time:   0.370002
 Self time:   0.050583

count  total (s)   self (s)
  523              0.004423   if empty(a:keyword_patterns)
  523   0.079417   0.008585     let patterns = deoplete#custom#_get_filetype_option(   'keyword_patterns', a:filetype, '')
  523              0.000850   else
                                let filetype = has_key(a:keyword_patterns, a:filetype) ? a:filetype : '_'
                                let patterns = get(a:keyword_patterns, filetype, '')
                              endif
  523   0.014652   0.009289   let pattern = join(deoplete#util#convert2list(patterns), '|')
                            
                              " Convert keyword.
  523   0.252194   0.008969   let k_pattern = deoplete#util#vimoption2python( &l:iskeyword . (&l:lisp ? ',-' : ''))
  523              0.010156   return substitute(pattern, '\\k', '\=k_pattern', 'g')

FUNCTION  <SNR>32_get()
Called 261 times
Total time:   0.008721
 Self time:   0.008721

count  total (s)   self (s)
  261              0.000643   if a:0 == 2
                                return deepcopy(get(a:2, 'delimitMate_' . a:name, a:1))
                              elseif a:0 == 1
    4              0.000049     let bufoptions = get(s:options, bufnr('%'), {})
    4              0.000030     return deepcopy(get(bufoptions, a:name, a:1))
                              else
  257              0.003359     return deepcopy(eval('s:options.' . bufnr('%') . '.' . a:name))
                              endif

FUNCTION  <SNR>22_get_oldstyle_setting()
Called 112 times
Total time:   0.041732
 Self time:   0.031957

count  total (s)   self (s)
  112              0.000928     let maker_name = get(a:maker, 'name', '')
  112              0.000443     if a:maker_only && empty(maker_name)
                                    if has_key(a:maker, a:key)
                                        return get(a:maker, a:key)
                                    endif
                                    return a:default
                                endif
                            
  112              0.000267     if a:bufnr isnot# ''
  112              0.000418         if !empty(a:ft)
  112   0.008768   0.001510             let fts = neomake#utils#get_config_fts(a:ft) + ['']
  112              0.000158         else
                                        let fts = ['']
                                    endif
  335              0.000879         for ft in fts
                                        " Look through the override vars for a filetype maker, like
                                        " neomake_scss_sasslint_exe (should be a string), and
                                        " neomake_scss_sasslint_args (should be a list).
  224              0.004008             let part = join(filter([ft, maker_name], '!empty(v:val)'), '_')
  224              0.000767             if empty(part)
    1              0.000003                 break
                                        endif
  223              0.001318             let config_var = 'neomake_'.part.'_'.a:key
  223              0.000494             unlet! Bufcfgvar  " vim73
  223   0.004781   0.003014             let Bufcfgvar = neomake#compat#getbufvar(a:bufnr, config_var, s:unset)
  223              0.000693             if Bufcfgvar isnot s:unset
                                            return copy(Bufcfgvar)
                                        endif
  223              0.000985             if has_key(g:, config_var)
                                            return copy(get(g:, config_var))
                                        endif
  223              0.000357         endfor
  112              0.000157     endif
                            
  112              0.000485     if has_key(a:maker, a:key)
                                    return get(a:maker, a:key)
                                endif
                            
  112              0.000353     let key = a:key
  112              0.000252     if a:maker_only
    5              0.000016         let key = maker_name.'_'.key
    5              0.000004     endif
  112              0.000571     let key = a:maker_only ? maker_name.'_'.a:key : a:key
                                " Look for 'neomake_'.key in the buffer and global namespace.
  112   0.002194   0.001443     let bufvar = neomake#compat#getbufvar(a:bufnr, 'neomake_'.key, s:unset)
  112              0.000297     if bufvar isnot s:unset
                                    return bufvar
                                endif
  112              0.000769     if a:key !=# 'enabled_makers' && has_key(g:, 'neomake_'.key)
                                    return get(g:, 'neomake_'.key)
                                endif
  112              0.000245     return a:default

FUNCTION  airline#extensions#tabline#get()
Called 162 times
Total time:   0.163548
 Self time:   0.013509

count  total (s)   self (s)
  162              0.001902   let show_buffers = get(g:, 'airline#extensions#tabline#show_buffers', 1)
  162              0.000942   let show_tabs = get(g:, 'airline#extensions#tabline#show_tabs', 1)
                            
  162              0.000835   let curtabcnt = tabpagenr('$')
  162              0.000645   if curtabcnt != s:current_tabcnt
                                let s:current_tabcnt = curtabcnt
                                call airline#extensions#tabline#tabs#invalidate()
                                call airline#extensions#tabline#buffers#invalidate()
                                call airline#extensions#tabline#ctrlspace#invalidate()
                              endif
                            
  162              0.001556   if !exists('#airline#BufAdd#*')
                                autocmd airline BufAdd * call <sid>update_tabline()
                              endif
  162              0.000304   if s:ctrlspace
                                return airline#extensions#tabline#ctrlspace#get()
                              elseif show_buffers && curtabcnt == 1 || !show_tabs
  162   0.152238   0.002200     return airline#extensions#tabline#buffers#get()
                              else
                                return airline#extensions#tabline#tabs#get()
                              endif

FUNCTION  <SNR>112_on_stdout_nvim()
Called 38 times
Total time:   0.001074
 Self time:   0.001074

count  total (s)   self (s)
   38              0.000332   if empty(self.stdoutbuffer)
   19              0.000125     let self.stdoutbuffer = a:data
   19              0.000031   else
   19              0.000281     let self.stdoutbuffer = self.stdoutbuffer[:-2] + [self.stdoutbuffer[-1] . a:data[0]] + a:data[1:]
   19              0.000023   endif

FUNCTION  neomake#statusline#make_finished()
Called 41 times
Total time:   0.087548
 Self time:   0.087334

count  total (s)   self (s)
   41              0.000070     if a:make_info.options.file_mode
   41              0.000080         let bufnr = a:make_info.options.bufnr
   41              0.000135         if !empty(a:make_info.finished_jobs) && !has_key(s:counts, bufnr)
   10              0.000023             let s:counts[bufnr] = {}
   10              0.000005         endif
   41   0.000425   0.000211         call s:clear_cache(bufnr)
   41              0.000022     else
                                    let s:cache = {}
                                    if !empty(a:make_info.finished_jobs) && !has_key(s:counts, 'project')
                                        let s:counts['project'] = {}
                                    endif
                                endif
                            
                                " Trigger redraw of all statuslines.
                                " TODO: only do this if some relevant formats are used?!
   41              0.086339     redrawstatus!

FUNCTION  airline#builder#get_prev_group()
Called 270 times
Total time:   0.003521
 Self time:   0.003521

count  total (s)   self (s)
  270              0.000664   let x = a:i - 1
  316              0.000467   while x >= 0
  279              0.000634     let group = a:sections[x][0]
  279              0.000555     if group != '' && group != '|'
  233              0.000248       return group
                                endif
   46              0.000074     let x = x - 1
   46              0.000070   endwhile
   37              0.000037   return ''

FUNCTION  neomake#utils#temp_cd()
Called 1 time
Total time:   0.000322
 Self time:   0.000322

count  total (s)   self (s)
    1              0.000002     if a:dir ==# '.'
                                    return ['', '']
                                endif
    1              0.000001     if a:0
                                    let cur_wd = a:1
                                else
    1              0.000007         let cur_wd = getcwd()
    1              0.000002         if cur_wd ==# a:dir
                                        " No need to change directory.
                                        return ['', '']
                                    endif
    1              0.000001     endif
    1              0.000006     let cd = haslocaldir() ? 'lcd' : (exists(':tcd') == 2 && haslocaldir(-1, 0)) ? 'tcd' : 'cd'
    1              0.000001     try
    1              0.000284         exe cd.' '.fnameescape(a:dir)
    1              0.000002     catch
                                    " Tests fail with E344, but in reality it is E472?!
                                    " If uncaught, both are shown - let's just catch everything.
                                    return [v:exception, '']
                                endtry
    1              0.000006     return ['', cd.' '.fnameescape(cur_wd)]

FUNCTION  <SNR>137_reset()
Called 11 times
Total time:   0.000107
 Self time:   0.000107

count  total (s)   self (s)
   11              0.000049         if has_key(s:highlights[a:type], a:buf)
    1              0.000012             call nvim_buf_clear_highlight(a:buf, s:highlights[a:type][a:buf], 0, -1)
    1              0.000003             unlet s:highlights[a:type][a:buf]
    1              0.000001         endif

FUNCTION  airline#util#getwinvar()
Called 375 times
Total time:   0.001343
 Self time:   0.001343

count  total (s)   self (s)
  375              0.001201     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  FugitiveDetect()
Called 1 time
Total time:   0.002574
 Self time:   0.000079

count  total (s)   self (s)
    1              0.000013   if exists('b:git_dir') && b:git_dir =~# '^$\|/$\|^fugitive:'
                                unlet b:git_dir
                              endif
    1              0.000001   if !exists('b:git_dir')
    1   0.001149   0.000028     let dir = FugitiveExtractGitDir(a:path)
    1              0.000002     if dir !=# ''
    1              0.000002       let b:git_dir = dir
    1              0.000001     endif
    1              0.000001   endif
    1              0.000002   if exists('b:git_dir')
    1   0.001393   0.000019     return fugitive#Init()
                              endif

FUNCTION  <SNR>32_is_jump()
Called 8 times
Total time:   0.001609
 Self time:   0.000470

count  total (s)   self (s)
                              " Returns 1 if the next character is a closing delimiter.
    8   0.000538   0.000111   let char = s:get_char(0)
    8   0.000751   0.000172   let list = s:get('right_delims') + s:get('quotes_list')
                            
                              " Closing delimiter on the right.
    8              0.000070   if (!a:0 && index(list, char) > -1) || (a:0 && char == a:1)
    7              0.000013     return 1
                              endif
                            
                              " Closing delimiter with space expansion.
    1   0.000064   0.000011   let nchar = s:get_char(1)
    1              0.000006   if !a:0 && s:get('expand_space') && char == " "
                                if index(list, nchar) > -1
                                  return 2
                                endif
                              elseif a:0 && s:get('expand_space') && nchar == a:1 && char == ' '
                                return 3
                              endif
                            
    1   0.000056   0.000007   if !s:get('jump_expansion')
    1              0.000002     return 0
                              endif
                            
                              " Closing delimiter with CR expansion.
                              let uchar = matchstr(getline(line('.') + 1), '^\s*\zs\S')
                              if !a:0 && s:get('expand_cr') && char == ""
                                if index(list, uchar) > -1
                                  return 4
                                endif
                              elseif a:0 && s:get('expand_cr') && uchar == a:1
                                return 5
                              endif
                              return 0

FUNCTION  airline#extensions#tabline#buffers#invalidate()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000005   let s:current_bufnr = -1

FUNCTION  <SNR>31_init()
Called 2 times
Total time:   0.003903
 Self time:   0.000938

count  total (s)   self (s)
                            " Initialize variables:
                              " autoclose
    2   0.000210   0.000027   call s:option_init("autoclose", 1)
                              " matchpairs
    2   0.000160   0.000027   call s:option_init("matchpairs", string(&matchpairs)[1:-2])
    2   0.000381   0.000162   call s:option_init("matchpairs_list", map(split(s:get('matchpairs'), '.:.\zs,\ze.:.'), 'split(v:val, ''^.\zs:\ze.$'')'))
    2   0.000070   0.000014   let pairs = s:get('matchpairs_list')
    2              0.000022   if len(filter(pairs, 'v:val[0] ==# v:val[1]'))
                                echohl ErrorMsg
                                echom 'delimitMate: each member of a pair in delimitMate_matchpairs must be different from each other.'
                                echom 'delimitMate: invalid pairs: ' . join(map(pairs, 'join(v:val, ":")'), ', ')
                                echohl Normal
                                return 0
                              endif
    2   0.000206   0.000034   call s:option_init("left_delims", map(copy(s:get('matchpairs_list')), 'v:val[0]'))
    2   0.000178   0.000028   call s:option_init("right_delims", map(copy(s:get('matchpairs_list')), 'v:val[1]'))
                              " quotes
    2   0.000102   0.000010   call s:option_init("quotes", "\" ' `")
    2   0.000285   0.000111   call s:option_init("quotes_list",split(s:get('quotes'), '\s\+'))
                              " nesting_quotes
    2   0.000106   0.000011   call s:option_init("nesting_quotes", [])
                              " excluded_regions
    2   0.000105   0.000009   call s:option_init("excluded_regions", "Comment")
    2   0.000172   0.000028   call s:option_init("excluded_regions_list", split(s:get('excluded_regions'), ',\s*'))
    2   0.000055   0.000013   let enabled = len(s:get('excluded_regions_list')) > 0
    2   0.000097   0.000010   call s:option_init("excluded_regions_enabled", enabled)
                              " expand_space
    2              0.000008   if exists("b:delimitMate_expand_space") && type(b:delimitMate_expand_space) == type("")
                                echom "b:delimitMate_expand_space is '".b:delimitMate_expand_space."' but it must be either 1 or 0!"
                                echom "Read :help 'delimitMate_expand_space' for more details."
                                unlet b:delimitMate_expand_space
                                let b:delimitMate_expand_space = 1
                              endif
    2              0.000007   if exists("g:delimitMate_expand_space") && type(g:delimitMate_expand_space) == type("")
                                echom "delimitMate_expand_space is '".g:delimitMate_expand_space."' but it must be either 1 or 0!"
                                echom "Read :help 'delimitMate_expand_space' for more details."
                                unlet g:delimitMate_expand_space
                                let g:delimitMate_expand_space = 1
                              endif
    2   0.000102   0.000009   call s:option_init("expand_space", 0)
                              " expand_cr
    2              0.000007   if exists("b:delimitMate_expand_cr") && type(b:delimitMate_expand_cr) == type("")
                                echom "b:delimitMate_expand_cr is '".b:delimitMate_expand_cr."' but it must be either 1 or 0!"
                                echom "Read :help 'delimitMate_expand_cr' for more details."
                                unlet b:delimitMate_expand_cr
                                let b:delimitMate_expand_cr = 1
                              endif
    2              0.000006   if exists("g:delimitMate_expand_cr") && type(g:delimitMate_expand_cr) == type("")
                                echom "delimitMate_expand_cr is '".g:delimitMate_expand_cr."' but it must be either 1 or 0!"
                                echom "Read :help 'delimitMate_expand_cr' for more details."
                                unlet g:delimitMate_expand_cr
                                let g:delimitMate_expand_cr = 1
                              endif
    2              0.000045   if ((&backspace !~ 'eol' || &backspace !~ 'start') && &backspace != 2) && ((exists('b:delimitMate_expand_cr') && b:delimitMate_expand_cr == 1) || (exists('g:delimitMate_expand_cr') && g:delimitMate_expand_cr == 1))
                                echom "delimitMate: There seems to be some incompatibility with your settings that may interfer with the expansion of <CR>. See :help 'delimitMate_expand_cr' for details."
                              endif
    2   0.000132   0.000019   call s:option_init("expand_cr", 0)
                              " expand_in_quotes
    2   0.000110   0.000010   call s:option_init('expand_inside_quotes', 0)
                              " jump_expansion
    2   0.000117   0.000012   call s:option_init("jump_expansion", 0)
                              " smart_matchpairs
    2   0.000114   0.000015   call s:option_init("smart_matchpairs", '^\%(\w\|\!\|[£$]\|[^[:punct:][:space:]]\)')
                              " smart_quotes
                              " XXX: backward compatibility. Ugly, should go the way of the dodo soon.
    2   0.000086   0.000024   let quotes = escape(join(s:get('quotes_list'), ''), '\-^[]')
    2              0.000009   let default_smart_quotes = '\%(\w\|[^[:punct:][:space:]' . quotes . ']\|\%(\\\\\)*\\\)\%#\|\%#\%(\w\|[^[:space:][:punct:]' . quotes . ']\)'
    2              0.000011   if exists('g:delimitMate_smart_quotes') && type(g:delimitMate_smart_quotes) == type(0)
                                if g:delimitMate_smart_quotes
                                  unlet g:delimitMate_smart_quotes
                                else
                                  unlet g:delimitMate_smart_quotes
                                  let g:delimitMate_smart_quotes = ''
                                endif
                              endif
    2              0.000005   if exists('b:delimitMate_smart_quotes') && type(b:delimitMate_smart_quotes) == type(0)
                                if b:delimitMate_smart_quotes
                                  unlet b:delimitMate_smart_quotes
                                  if exists('g:delimitMate_smart_quotes') && type(g:delimitMate_smart_quotes) && g:delimitMate_smart_quotes
                                    let b:delimitMate_smart_quotes = default_smart_quotes
                                  endif
                                else
                                  unlet b:delimitMate_smart_quotes
                                  let b:delimitMate_smart_quotes = ''
                                endif
                              endif
    2   0.000147   0.000018   call s:option_init("smart_quotes", default_smart_quotes)
                              " apostrophes
    2   0.000112   0.000014   call s:option_init("apostrophes", "")
    2   0.000224   0.000050   call s:option_init("apostrophes_list", split(s:get('apostrophes'), ":\s*"))
                              " tab2exit
    2   0.000100   0.000010   call s:option_init("tab2exit", 1)
                              " balance_matchpairs
    2   0.000108   0.000009   call s:option_init("balance_matchpairs", 0)
                              " eol marker
    2   0.000082   0.000007   call s:option_init("insert_eol_marker", 1)
    2   0.000094   0.000007   call s:option_init("eol_marker", "")
                              " Everything is fine.
    2              0.000002   return 1

FUNCTION  <SNR>47_abs_path()
Called 176 times
Total time:   1.166730
 Self time:   1.166730

count  total (s)   self (s)
  176              1.163360   let p = resolve(expand('#'.a:bufnr.':p'))
  176              0.002840   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  gitgutter#hunk#hunks()
Called 18 times
Total time:   0.000442
 Self time:   0.000192

count  total (s)   self (s)
   18   0.000413   0.000164   return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])

FUNCTION  airline#themes#get_highlight2()
Called 96 times
Total time:   0.023785
 Self time:   0.002261

count  total (s)   self (s)
   96   0.023673   0.002149   return call('airline#highlighter#get_highlight2', [a:fg, a:bg] + a:000)

FUNCTION  gitgutter#sign#update_signs()
Called 18 times
Total time:   0.080789
 Self time:   0.002397

count  total (s)   self (s)
   18   0.036530   0.000251   call s:find_current_signs(a:bufnr)
                            
   18              0.000679   let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
   18   0.006413   0.000382   let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
   18              0.000096   let flicker_possible = s:remove_all_old_signs && !empty(a:modified_lines)
   18              0.000032   if flicker_possible
    1   0.001575   0.000021     call s:add_dummy_sign(a:bufnr)
    1              0.000000   endif
                            
   18   0.005788   0.000275   call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
   18   0.029250   0.000262   call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)
                            
   18              0.000040   if flicker_possible
    1   0.000039   0.000012     call gitgutter#sign#remove_dummy_sign(a:bufnr, 0)
    1              0.000000   endif

FUNCTION  airline#themes#patch()
Called 12 times
Total time:   0.006956
 Self time:   0.006956

count  total (s)   self (s)
  144              0.000472   for mode in keys(a:palette)
  132              0.000282     if mode == 'accents'
   12              0.000050       continue
                                endif
  120              0.000550     if !has_key(a:palette[mode], 'airline_warning')
   84              0.000593       let a:palette[mode]['airline_warning'] = [ '#000000', '#df5f00', 232, 166 ]
   84              0.000081     endif
  120              0.000500     if !has_key(a:palette[mode], 'airline_error')
   84              0.000556       let a:palette[mode]['airline_error'] = [ '#000000', '#990000', 232, 160 ]
   84              0.000087     endif
  120              0.000516     if !has_key(a:palette[mode], 'airline_term')
   84              0.000536       let a:palette[mode]['airline_term'] = [ '#9cffd3', '#202020', 85, 232]
   84              0.000084     endif
  120              0.000180   endfor
                            
   12              0.000130   let a:palette.accents = get(a:palette, 'accents', {})
   12              0.000067   let a:palette.accents.none = [ '', '', '', '', '' ]
   12              0.000069   let a:palette.accents.bold = [ '', '', '', '', 'bold' ]
   12              0.000058   let a:palette.accents.italic = [ '', '', '', '', 'italic' ]
                            
   12              0.000061   if !has_key(a:palette.accents, 'red')
                                let a:palette.accents.red = [ '#ff0000' , '' , 160 , '' ]
                              endif
   12              0.000040   if !has_key(a:palette.accents, 'green')
   12              0.000066     let a:palette.accents.green = [ '#008700' , '' , 22  , '' ]
   12              0.000015   endif
   12              0.000042   if !has_key(a:palette.accents, 'blue')
   12              0.000069     let a:palette.accents.blue = [ '#005fff' , '' , 27  , '' ]
   12              0.000015   endif
   12              0.000044   if !has_key(a:palette.accents, 'yellow')
   12              0.000062     let a:palette.accents.yellow = [ '#dfff00' , '' , 190 , '' ]
   12              0.000012   endif
   12              0.000040   if !has_key(a:palette.accents, 'orange')
   12              0.000065     let a:palette.accents.orange = [ '#df5f00' , '' , 166 , '' ]
   12              0.000014   endif
   12              0.000040   if !has_key(a:palette.accents, 'purple')
   12              0.000063     let a:palette.accents.purple = [ '#af00df' , '' , 128 , '' ]
   12              0.000012   endif

FUNCTION  <SNR>19_neomake_do_automake()
Called 203 times
Total time:   0.683774
 Self time:   0.050030

count  total (s)   self (s)
  203              0.000995     let bufnr = +a:context.bufnr
                            
  203              0.000489     if a:context.delay
  162              0.001075         if exists('s:timer_by_bufnr[bufnr]')
  101              0.000521             let timer = s:timer_by_bufnr[bufnr]
  101   0.004379   0.001713             call s:stop_timer(timer)
  101   0.012941   0.001881             call s:debug_log(printf('stopped existing timer: %d', timer), {'bufnr': bufnr})
  101              0.000157         endif
  162   0.017555   0.002054         if !s:tick_changed(a:context, 0)
    2   0.000173   0.000020             call s:debug_log('buffer was not changed', {'bufnr': bufnr})
    2              0.000002             return
                                    endif
                            
                                    " Cancel any already running automake runs.
  160              0.001066         let prev_make_ids = getbufvar(bufnr, 'neomake_automake_make_ids')
  160              0.000542         if !empty(prev_make_ids)
   31   0.002079   0.000359             call s:debug_log(printf('stopping previous make runs: %s', join(prev_make_ids, ', ')))
   62              0.000145             for prev_make_id in prev_make_ids
   31   0.017619   0.000329               call neomake#CancelMake(prev_make_id)
   31              0.000030             endfor
   31              0.000023         endif
                            
  160              0.002687         let timer = timer_start(a:context.delay, function('s:automake_delayed_cb'))
  160              0.001161         let s:timer_info[timer] = a:context
  160              0.000738         if !has_key(a:context, 'pos')
  159   0.009178   0.002354             let s:timer_info[timer].pos = s:get_position_context()
  159              0.000264         endif
  160              0.000827         let s:timer_by_bufnr[bufnr] = timer
  160   0.019830   0.003357         call s:debug_log(printf('started timer (%dms): %d', a:context.delay, timer), {'bufnr': a:context.bufnr})
  160              0.000214         return
                                endif
                            
   41              0.000536     let ft = getbufvar(bufnr, '&filetype')
   41              0.000265     let event = a:context.event
                            
   41   0.007331   0.000964     call s:debug_log('neomake_do_automake: '.event, {'bufnr': bufnr})
   41   0.013357   0.001299     if !s:tick_changed({'event': event, 'bufnr': bufnr, 'ft': ft}, 1)
                                    call s:debug_log('buffer was not changed', {'bufnr': bufnr})
                                    return
                                endif
                            
   41   0.007396   0.002309     call s:debug_log(printf('enabled makers: %s', join(map(copy(a:context.maker_jobs), 'v:val.maker.name'), ', ')))
   41   0.535753   0.004394     let jobinfos = neomake#Make({ 'file_mode': 1, 'jobs': deepcopy(a:context.maker_jobs), 'ft': ft, 'automake': 1})
   41              0.000975     let started_jobs = filter(copy(jobinfos), "!get(v:val, 'finished', 0)")
   41   0.008654   0.002166     call s:debug_log(printf('started jobs: %s', string(map(copy(started_jobs), 'v:val.id'))))
   41              0.000177     if !empty(started_jobs)
   41              0.000432         let make_ids = map(copy(jobinfos), 'v:val.make_id')
   41   0.002040   0.001343         call setbufvar(bufnr, 'neomake_automake_make_ids', neomake#compat#getbufvar(bufnr, 'neomake_automake_make_ids', []) + make_ids)
   41              0.000071     endif

FUNCTION  <SNR>118_InvokeCompletion()
Called 148 times
Total time:   1.035586
 Self time:   0.891918

count  total (s)   self (s)
  148              0.886324   exec s:python_command "ycm_state.SendCompletionRequest(" . "vimsupport.GetBoolValue( 's:force_semantic' ) )"
                            
  148   0.148666   0.004997   call s:PollCompletion()

FUNCTION  <SNR>118_PollFileParseResponse()
Called 5 times
Total time:   0.008734
 Self time:   0.004347

count  total (s)   self (s)
    5   0.002692   0.000080   if !s:Pyeval( "ycm_state.FileParseRequestReady()" )
                                let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
                                return
                              endif
                            
    5              0.003988   exec s:python_command "ycm_state.HandleFileParseRequest()"
    5   0.001887   0.000112   if s:Pyeval( "ycm_state.ShouldResendFileParseRequest()" )
                                call s:OnFileReadyToParse( 1 )
                              endif

FUNCTION  airline#async#nvim_vcs_untracked()
Called 20 times
Total time:   0.006206
 Self time:   0.005071

count  total (s)   self (s)
   20              0.000181   let cmd = a:cfg.cmd . shellescape(a:file)
   20              0.000044   let id = -1
   20   0.002228   0.001092   let config = { 'buf': '', 'vcs': a:vcs, 'cfg': a:cfg, 'file': a:file, 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')) }
   20              0.000113   if has("nvim")
   20              0.000425     call extend(config, { 'on_stdout': function('s:nvim_output_handler'), 'on_exit': function('s:nvim_untracked_job_handler')})
   20              0.000092     if has_key(s:untracked_jobs, config.file)
                                  " still running
   18              0.000020       return
                                endif
    2              0.000002     try
    2              0.002964     let id = jobstart(cmd, config)
    2              0.000006     catch
                                  " catch-all, jobstart() failed, fall back to system()
                                  let id=-1
                                endtry
    2              0.000014     let s:untracked_jobs[a:file] = id
    2              0.000001   endif
                              " vim without job feature or nvim jobstart failed
    2              0.000002   if id < 1
                                let output=system(cmd)
                                call s:untracked_output(config, output)
                                call airline#extensions#branch#update_untracked_config(a:file, a:vcs)
                              endif

FUNCTION  <SNR>108_HandleMessage()
Called 262 times
Total time:   0.198760
 Self time:   0.175084

count  total (s)   self (s)
  262              0.001985     if a:event ==# 'stdout'
 1313              0.005514         while len(a:lines) > 0
 1051              0.005338             let l:line = remove(a:lines, 0)
                            
 1051              0.002467             if l:line ==# ''
  525              0.001425                 continue
                                        elseif s:content_length == 0
  263              0.009539                 let s:content_length = str2nr(substitute(l:line, '.*Content-Length:', '', ''))
  263              0.000922                 continue
                                        endif
                            
  263              0.002613             let s:input .= strpart(l:line, 0, s:content_length)
  263              0.001194             if s:content_length < strlen(l:line)
                                            call insert(a:lines, strpart(l:line, s:content_length), 0)
                                            let s:content_length = 0
                                        else
  263              0.001427                 let s:content_length = s:content_length - strlen(l:line)
  263              0.000297             endif
  263              0.000470             if s:content_length > 0
                                            continue
                                        endif
                            
  263              0.000794             try
  263              0.004058                 let l:message = json_decode(s:input)
  263              0.001675                 if type(l:message) !=# s:TYPE.dict
                                                throw 'Messsage is not dict.'
                                            endif
  263              0.000474             catch
                                            call s:Debug('Error decoding message: ' . string(v:exception) . ' Message: ' . s:input)
                                            continue
                                        finally
  263              0.001053                 let s:input = ''
  263              0.000550             endtry
                            
  263              0.001391             if has_key(l:message, 'method')
  263              0.001710                 let l:id = get(l:message, 'id', v:null)
  263              0.001275                 let l:method = get(l:message, 'method')
  263              0.001109                 let l:params = get(l:message, 'params')
  263              0.000509                 try
  263              0.000738                     if l:method ==# 'execute'
    1              0.000002                         for l:cmd in l:params
                                                        execute l:cmd
                                                    endfor
    1              0.000002                         let l:result = 0
    1              0.000001                     else
  262              0.002052                         let l:params = type(l:params) == s:TYPE.list ? l:params : [l:params]
  262   0.015834   0.005075                         let l:result = call(l:method, l:params)
  262              0.000367                     endif
  263              0.000803                     if l:id != v:null
  261   0.031529   0.018611                         call LanguageClient#Write(json_encode({ 'jsonrpc': '2.0', 'id': l:id, 'result': l:result, }))
  261              0.000626                     endif
  263              0.000721                 catch
                                                let l:exception = v:exception
                                                if l:id != v:null
                                                    try
                                                        call LanguageClient#Write(json_encode({ 'jsonrpc': '2.0', 'id': l:id, 'error': {   'code': -32603,   'message': string(v:exception)   } }))
                                                    catch
                                                        " TODO
                                                    endtry
                                                endif
                                                call s:Debug(string(l:exception))
                                            endtry
  263              0.001269             elseif has_key(l:message, 'result') || has_key(l:message, 'error')
                                            let l:id = get(l:message, 'id')
                                            let l:Handle = get(s:handlers, l:id)
                                            unlet s:handlers[l:id]
                                            let l:type = type(l:Handle)
                                            if l:type == s:TYPE.funcref || l:type == s:TYPE.string
                                                call call(l:Handle, [l:message])
                                            elseif l:type == s:TYPE.list
                                                call add(l:Handle, l:message)
                                            elseif l:type == s:TYPE.string && exists(l:Handle)
                                                let l:outputs = eval(l:Handle)
                                                call add(l:outputs, l:message)
                                            else
                                                call s:Echoerr('Unknown Handle type: ' . string(l:Handle))
                                            endif
                                        else
                                            call s:Echoerr('Unknown message: ' . string(l:message))
                                        endif
  263              0.000714         endwhile
  262              0.000761     elseif a:event ==# 'stderr'
                                    call s:Echoerr('LanguageClient stderr: ' . string(a:lines))
                                elseif a:event ==# 'exit'
                                    if type(a:lines) == type(0) && a:lines == 0
                                        return
                                    endif
                                    call s:Debug('LanguageClient exited with: ' . string(a:lines))
                                else
                                    call s:Debug('LanguageClient unknown event: ' . a:event)
                                endif

FUNCTION  <SNR>81_get_cargo_maker_cwd()
Called 1 time
Total time:   0.033314
 Self time:   0.000038

count  total (s)   self (s)
    1   0.033306   0.000029     let cargo_workspace_root = s:get_cargo_workspace_root()
    1              0.000004     if !empty(cargo_workspace_root)
    1              0.000002         return cargo_workspace_root
                                endif
                            
                                let cargo_toml = neomake#utils#FindGlobFile('Cargo.toml')
                                if !empty(cargo_toml)
                                    return fnamemodify(cargo_toml, ':h')
                                endif
                            
                                return a:default

FUNCTION  <SNR>129_ExcludeOther()
Called 2 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    2              0.000010   if (getbufvar(a:nr, 'current_syntax') == 'qf') ||  (a:exclude_preview && getbufvar(a:nr, '&bufhidden') == 'wipe'  && getbufvar(a:nr, '&buftype') == 'nofile')
                                return 1 | endif

FUNCTION  gitgutter#hunk#increment_lines_modified()
Called 31 times
Total time:   0.002534
 Self time:   0.000914

count  total (s)   self (s)
   31   0.001220   0.000320   let summary = gitgutter#hunk#summary(a:bufnr)
   31              0.000199   let summary[1] += a:count
   31   0.001053   0.000333   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>110_Slash()
Called 9 times
Total time:   0.000127
 Self time:   0.000127

count  total (s)   self (s)
    9              0.000074   if exists('+shellslash')
                                return tr(a:path, '\', '/')
                              else
    9              0.000009     return a:path
                              endif

FUNCTION  <SNR>90_update_branch()
Called 3068 times
Total time: 214.086191
 Self time:   0.366005

count  total (s)   self (s)
 9204              0.055258   for vcs in keys(s:vcs_config)
 6136 213.850198   0.130012     call {s:vcs_config[vcs].update_branch}()
 6136              0.053576     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
    1              0.000003       let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
    1              0.000002       unlet! b:airline_head
    1              0.000001     endif
 6136              0.012801   endfor

FUNCTION  <SNR>124_completion_begin()
Called 291 times
Total time:   1.200578
 Self time:   0.026206

count  total (s)   self (s)
  291   0.153845   0.004067   if s:is_skip(a:event)
   71   0.002653   0.001101     call deoplete#mapping#_restore_completeopt()
   71              0.000647     let g:deoplete#_context.candidates = []
   71              0.000123     return
                              endif
                            
  220   0.950362   0.005357   let context = deoplete#init#_context(a:event, [])
  220              0.001270   if context['event'] !=# 'Async'
   98   0.003154   0.001583     call deoplete#init#_prev_completion()
   98              0.000169   endif
                            
  220   0.009398   0.003040   if s:check_omnifunc(context)
                                return
                              endif
                            
  220   0.073358   0.003251   call deoplete#util#rpcnotify( 'deoplete_auto_completion_begin', context)

FUNCTION  airline#highlighter#load_theme()
Called 12 times
Total time:   0.395348
 Self time:   0.001515

count  total (s)   self (s)
   12              0.000097   if pumvisible()
                                return
                              endif
   12              0.000328   for winnr in filter(range(1, winnr('$')), 'v:val != winnr()')
                                call airline#highlighter#highlight_modified_inactive(winbufnr(winnr))
                              endfor
   12   0.238543   0.000356   call airline#highlighter#highlight(['inactive'])
   12              0.000166   if getbufvar( bufnr('%'), '&modified'  )
    1   0.017643   0.000027     call airline#highlighter#highlight(['normal', 'modified'])
    1              0.000001   else
   11   0.138296   0.000266     call airline#highlighter#highlight(['normal'])
   11              0.000011   endif

FUNCTION  neomake#utils#GetSetting()
Called 217 times
Total time:   0.292249
 Self time:   0.013711

count  total (s)   self (s)
  217              0.001194     let maker_only = a:0 ? a:1 : 0
                            
                                " Check new-style config.
  217              0.001817     if exists('g:neomake') || !empty(getbufvar(a:bufnr, 'neomake'))
  217              0.002319         let context = {'ft': a:ft, 'maker': a:maker, 'bufnr': a:bufnr, 'maker_only': maker_only}
  217   0.239861   0.003055         let Ret = neomake#config#get(a:key, g:neomake#config#undefined, context)
  217              0.000831         if Ret isnot g:neomake#config#undefined
  105              0.000196             return Ret
                                    endif
  112              0.000150     endif
                            
  112   0.044624   0.002892     return s:get_oldstyle_setting(a:key, a:maker, a:default, a:ft, a:bufnr, maker_only)

FUNCTION  <SNR>97_update_tabline()
Called 1 time
Total time:   0.000532
 Self time:   0.000243

count  total (s)   self (s)
    1              0.000015   if get(g:, 'airline#extensions#tabline#disable_refresh', 0)
                                return
                              endif
    1              0.000017   let match = expand('<afile>')
    1              0.000004   if pumvisible()
                                return
                              elseif !get(g:, 'airline#extensions#tabline#enabled', 0)
                                return
                              " return, if buffer matches ignore pattern or is directory (netrw)
                              elseif empty(match) || airline#util#ignore_buf(match) || isdirectory(expand("<afile>"))
                                return
                              endif
    1   0.000233   0.000013   call airline#util#doautocmd('BufMRUChange')
                              " sometimes, the tabline is not correctly updated see #1580
                              " so force redraw here
    1              0.000012   let &tabline = &tabline

FUNCTION  <SNR>118_IdentifierFinishedOperations()
Called 158 times
Total time:   0.463937
 Self time:   0.191705

count  total (s)   self (s)
  158   0.274195   0.001964   if !s:Pyeval( 'base.CurrentIdentifierFinished()' )
  120              0.000748     return
                              endif
   38              0.187128   exec s:python_command "ycm_state.OnCurrentIdentifierFinished()"
   38              0.000722   let s:force_semantic = 0
   38              0.000462   let s:completion = s:default_completion

FUNCTION  <SNR>20_resolve_name()
Called 2354 times
Total time:   0.097110
 Self time:   0.097110

count  total (s)   self (s)
 2354              0.021001     let parts = type(a:name) == type([]) ? a:name : split(a:name, '\.')
 2354              0.006781     let c = a:dict
 2680              0.012292     for p in parts[0:-2]
 1719              0.007608         if !has_key(c, p)
 1371              0.002722             if !a:init
 1371              0.005858                 return [g:neomake#config#undefined, '']
                                        endif
                                        let c[p] = {}
                                    endif
  348              0.002325         if type(c[p]) != type({})
   22              0.000024           return [g:neomake#config#undefined, '']
                                    endif
  326              0.001576         let c = c[p]
  326              0.000533     endfor
  961              0.003981     return [c, parts[-1]]

FUNCTION  fugitive#buffer()
Called 4 times
Total time:   0.000161
 Self time:   0.000136

count  total (s)   self (s)
    4              0.000026   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
    4              0.000064   call extend(buffer, s:buffer_prototype, 'keep')
    4   0.000061   0.000037   if buffer.getvar('git_dir') !=# ''
    4              0.000004     return buffer
                              endif
                              call s:throw('not a git repository: '.bufname(buffer['#']))

FUNCTION  airline#update_statusline_inactive()
Called 25 times
Total time:   0.000709
 Self time:   0.000638

count  total (s)   self (s)
   25   0.000199   0.000127   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
   25              0.000056   for nr in a:range
                                if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
                                endif
                                call setwinvar(nr, 'airline_active', 0)
                                let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
                                if get(g:, 'airline_inactive_alt_sep', 0)
                                  call extend(context, { 'left_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_alt_sep }, 'keep')
                                endif
                                call s:invoke_funcrefs(context, s:inactive_funcrefs)
                              endfor

FUNCTION  <SNR>93_ws_refresh()
Called 30 times
Total time:   0.000765
 Self time:   0.000765

count  total (s)   self (s)
   30              0.000428   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
   25              0.000063     return
                              endif
    5              0.000052   unlet! b:airline_whitespace_check
    5              0.000030   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh'
                              endif
    5              0.000048   let b:airline_ws_changedtick = b:changedtick

FUNCTION  <SNR>110_buffer_commit()
Called 2 times
Total time:   0.000731
 Self time:   0.000076

count  total (s)   self (s)
    2   0.000728   0.000073   return matchstr(self.spec(),'^fugitive:\%(//\)\=.\{-\}\%(//\|::\)\zs\w*')

FUNCTION  <SNR>118_OnBufferEnter()
Called 1 time
Total time:   0.000022
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000021   0.000013   if !s:VisitedBufferRequiresReparse()
    1              0.000000     return
                              endif
                            
                              call s:SetUpCompleteopt()
                              call s:SetCompleteFunc()
                              call s:StartMessagePoll()
                            
                              exec s:python_command "ycm_state.OnBufferVisit()"
                              " Last parse may be outdated because of changes from other buffers. Force a
                              " new parse.
                              call s:OnFileReadyToParse( 1 )

FUNCTION  <SNR>19_configure_buffer()
Called 1 time
Total time:   0.052259
 Self time:   0.000347

count  total (s)   self (s)
    1              0.000005     let bufnr = +a:bufnr
    1              0.000008     let ft = getbufvar(bufnr, '&filetype')
    1   0.000070   0.000028     let config = s:getbufvar(bufnr, 'neomake', {})
    1              0.000006     let old_config = deepcopy(config)
    1              0.000002     if a:0
                                    let args = [config, a:1]
                                    if a:0 > 1 && has_key(a:2, 'delay')
                                        let args += [a:2.delay]
                                    endif
                                    call call('s:parse_events_from_args', args)
                                    call setbufvar(bufnr, 'neomake', config)
                                endif
                            
                                " Register the buffer, and remember if it is custom.
    1              0.000006     if has_key(s:configured_buffers, bufnr)
                                    let old_registration = copy(get(s:configured_buffers, bufnr, {}))
                                    call extend(s:configured_buffers[bufnr], {'custom': a:0 > 0}, 'force')
                                else
    1              0.000011         let s:configured_buffers[bufnr] = {'custom': a:0 > 0}
    1              0.000002     endif
                            
                                " Create jobs.
    1              0.000005     let options = a:0 > 1 ? a:2 : {}
    1              0.000004     if has_key(options, 'makers')
                                    let makers = neomake#map_makers(options.makers, ft, 0)
                                    let source = 'options'
                                else
    1   0.002808   0.000034         let [makers, source] = neomake#config#get_with_source('automake.enabled_makers')
    1              0.000007         if makers is g:neomake#config#undefined
    1              0.000004             unlet makers
    1   0.014728   0.000074             let makers = neomake#GetEnabledMakers(ft)
    1              0.000001         else
                                        let makers = neomake#map_makers(makers, ft, 0)
                                    endif
    1              0.000001     endif
    1              0.000005     let options = {'file_mode': 1, 'ft': ft, 'bufnr': bufnr, 'automake': 1}
    1   0.034376   0.000030     let jobs = neomake#core#create_jobs(options, makers)
    1              0.000006     let s:configured_buffers[bufnr].maker_jobs = jobs
    1   0.000085   0.000022     call s:debug_log(printf('configured buffer for ft=%s (%s)', ft, empty(jobs) ? 'no enabled makers' : join(map(copy(jobs), 'v:val.maker.name'), ', ').' ('.source.')'), {'bufnr': bufnr})
    1              0.000003     if old_config != config
                                    call s:debug_log('resetting tick because of config changes')
                                    call setbufvar(bufnr, 'neomake_automake_tick', [])
                                elseif exists('old_registration')
                                    if old_registration != s:configured_buffers[bufnr]
                                        call s:debug_log('resetting tick because of registration changes')
                                        call setbufvar(bufnr, 'neomake_automake_tick', [])
                                    endif
                                else
    1   0.000036   0.000004         call s:debug_log('setting tick for new buffer')
    1              0.000003         call setbufvar(bufnr, 'neomake_automake_tick', [])
    1              0.000001     endif
                            
    1              0.000001     if a:0
                                  " Setup autocommands etc (when called manually)?!
                                  call neomake#configure#automake()
                                endif
    1              0.000001     return config

FUNCTION  deoplete#util#vimoption2python_not()
Called 4 times
Total time:   0.001739
 Self time:   0.000073

count  total (s)   self (s)
    4   0.001736   0.000070   return '[^\w' . s:vimoption2python(a:option) . ']'

FUNCTION  <SNR>82_handle_next_job()
Called 52 times
Total time:   0.516104
 Self time:   0.014130

count  total (s)   self (s)
   52              0.000517     let make_id = get(a:prev_jobinfo, 'make_id', s:make_id)
   52              0.000282     if !has_key(s:make_info, make_id)
                                    return {}
                                endif
   52              0.000277     let make_info = s:make_info[make_id]
                            
   52              0.000237     if !empty(a:prev_jobinfo)
   11              0.000020         let status = get(a:prev_jobinfo, 'exit_code', 0)
   11              0.000020         if status != 0 && index([122, 127], status) == -1
                                        " TODO: mark maker.exe as non-executable with status 127, and
                                        "       maybe re-introduce a wrapper for `executable()` to handle it.
                                        "       Ref: https://github.com/neomake/neomake/issues/1699
                                        if neomake#utils#GetSetting('serialize_abort_on_error', a:prev_jobinfo.maker, 0, a:prev_jobinfo.ft, a:prev_jobinfo.bufnr)
                                            call s:abort_next_makers(make_id)
                                            call s:CleanJobinfo(a:prev_jobinfo)
                                            return {}
                                        endif
                                    endif
   11   0.025795   0.000094         call s:CleanJobinfo(a:prev_jobinfo)
   11              0.000019         if !has_key(s:make_info, make_id)
                                        " Last job was cleaned.
   11              0.000008             return {}
                                    endif
                                endif
                            
                                " Create job from the start of the queue, returning it.
   41              0.000233     while !empty(make_info.jobs_queue)
   41              0.000364         let options = remove(make_info.jobs_queue, 0)
   41              0.000228         let maker = options.maker
   41              0.000170         if empty(maker)
                                        continue
                                    endif
                            
                                    " Serialization of jobs, always for non-async Vim.
   41              0.000248         if !has_key(options, 'serialize')
   41   0.092856   0.000980             if !s:async || neomake#utils#GetSetting('serialize', maker, 0, options.ft, options.bufnr)
                                            let options.serialize = 1
                                        else
   41              0.000254                 let options.serialize = 0
   41              0.000064             endif
   41              0.000053         endif
   41              0.000130         try
   41   0.386824   0.002427             let jobinfo = s:MakeJob(make_id, options)
   41              0.000184         catch /^Neomake: /
                                        let log_context = {'make_id': make_id}
                                        let error = substitute(v:exception, '^Neomake: ', '', '')
                                        call neomake#log#exception(error, log_context)
                            
                                        if options.serialize
                                            if neomake#utils#GetSetting('serialize_abort_on_error', maker, 0, options.ft, options.bufnr)
                                                call s:abort_next_makers(make_id)
                                                break
                                            endif
                                        endif
                                        continue
                                    endtry
   41              0.000406         if !empty(jobinfo)
   41              0.000210             return jobinfo
                                    endif
                                endwhile
                            
                                " Cleanup make info, but only if there are no queued actions.
                                for [_, v] in g:neomake#action_queue#_s.action_queue
                                    if v[1][0] == make_info
                                        call neomake#log#debug('Skipping cleaning of make info for queued actions.', make_info)
                                        return {}
                                    endif
                                endfor
                                call s:clean_make_info(make_info)
                                return {}

FUNCTION  airline#extensions#tabline#group_of_bufnr()
Called 18 times
Total time:   0.000791
 Self time:   0.000791

count  total (s)   self (s)
   18              0.000098   let cur = bufnr('%')
   18              0.000045   if cur == a:bufnr
    9              0.000088     if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
    3              0.000015       let group = 'airline_tabmod'
    3              0.000007     else
    6              0.000009       let group = 'airline_tabsel'
    6              0.000003     endif
    9              0.000008   else
    9              0.000069     if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
                                  let group = 'airline_tabmod_unsel'
                                elseif index(a:tab_bufs, a:bufnr) > -1
                                  let group = 'airline_tab'
                                else
    9              0.000027       let group = 'airline_tabhid'
    9              0.000011     endif
    9              0.000009   endif
   18              0.000038   return group

FUNCTION  <SNR>82_HandleLoclistQflistDisplay()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000007     let open_val = a:0 ? a:1 : get(g:, 'neomake_open_list', 0)
    1              0.000001     if !open_val
    1              0.000001         return
                                endif
                                let height = get(g:, 'neomake_list_height', 10)
                                if !height
                                    return
                                endif
                                let height = min([len(a:loc_or_qflist), height])
                                if a:jobinfo.file_mode
                                    call neomake#log#debug('Handling location list: executing lwindow.', a:jobinfo)
                                    let cmd = 'lwindow'
                                else
                                    call neomake#log#debug('Handling quickfix list: executing cwindow.', a:jobinfo)
                                    let cmd = 'botright cwindow'
                                endif
                                if open_val == 2
                                    let make_id = a:jobinfo.make_id
                                    let make_info = s:make_info[make_id]
                                    let s:ignore_automake_events += 1
                                    try
                                        call neomake#compat#save_prev_windows()
                            
                                        let win_count = winnr('$')
                                        exe cmd height
                                        let new_win_count = winnr('$')
                                        if win_count == new_win_count
                                            " No new window, adjust height eventually.
                                            let found = 0
                            
                                            if get(make_info, '_did_lwindow', 0)
                                                for w in range(1, winnr('$'))
                                                    if getwinvar(w, 'neomake_window_for_make_id') == make_id
                                                        let found = w
                                                        break
                                                    endif
                                                endfor
                                                if found
                                                    let cmd = printf('%dresize %d', found, height)
                                                    call neomake#log#debug(printf( 'Resizing existing quickfix window: %s.', cmd), a:jobinfo)
                                                    exe cmd
                                                else
                                                    call neomake#log#debug( 'Could not find corresponding quickfix window.', a:jobinfo)
                                                endif
                                            endif
                                        elseif new_win_count > win_count
                                            if &filetype !=# 'qf'
                                                call neomake#log#debug(printf( 'WARN: unexpected filetype for new window: %s', &filetype), a:jobinfo)
                                            else
                                                call neomake#log#debug(printf( 'list window has been opened (old count: %d, new count: %d).', win_count, new_win_count), a:jobinfo)
                                                let w:neomake_window_for_make_id = a:jobinfo.make_id
                                            endif
                                        else
                                            call neomake#log#debug(printf( 'list window has been closed (old count: %d, new count: %d).', win_count, new_win_count), a:jobinfo)
                                        endif
                                        call neomake#compat#restore_prev_windows()
                                        let make_info._did_lwindow = 1
                                    finally
                                        let s:ignore_automake_events -= 1
                                    endtry
                                else
                                    exe cmd height
                                endif

FUNCTION  gitgutter#all()
Called 12 times
Total time:   3.363077
 Self time:   0.920847

count  total (s)   self (s)
   12              0.000081   let visible = tabpagebuflist()
                            
   48              0.000384   for bufnr in range(1, bufnr('$') + 1)
   36              0.000212     if buflisted(bufnr)
   13              0.917052       let file = expand('#'.bufnr.':p')
   13              0.000199       if !empty(file)
   13              0.000096         if index(visible, bufnr) != -1
   12   0.116469   0.000472           call gitgutter#init_buffer(bufnr)
   12   2.326582   0.000371           call gitgutter#process_buffer(bufnr, a:force)
   12              0.000076         elseif a:force
    1   0.000039   0.000017           call s:reset_tick(bufnr)
    1              0.000000         endif
   13              0.000143       endif
   13              0.000033     endif
   36              0.000183   endfor

FUNCTION  gitgutter#utility#extension()
Called 19 times
Total time:   0.412363
 Self time:   0.000451

count  total (s)   self (s)
   19   0.412311   0.000399   return fnamemodify(s:abs_path(a:bufnr, 0), ':e')

FUNCTION  FugitiveHead()
Called 3068 times
Total time: 213.127577
 Self time:   0.112596

count  total (s)   self (s)
 3068   0.078981   0.039832   let dir = FugitiveGitDir(a:0 > 1 ? a:2 : -1)
 3068              0.012126   if empty(dir)
                                return ''
                              endif
 3068 213.020579   0.044748   return fugitive#Head(a:0 ? a:1 : 0, dir)

FUNCTION  <SNR>124_on_complete_done()
Called 118 times
Total time:   0.015592
 Self time:   0.004562

count  total (s)   self (s)
  118              0.001536   if get(v:completed_item, 'word', '') ==# ''
   66              0.000170     return
                              endif
                            
   52              0.000378   let word = v:completed_item.word
   52              0.000348   if !has_key(g:deoplete#_rank, word)
   40              0.000306     let g:deoplete#_rank[word] = 1
   40              0.000055   else
   12              0.000078     let g:deoplete#_rank[word] += 1
   12              0.000018   endif
                            
   52   0.011789   0.000759   call deoplete#handler#_skip_next_completion()

FUNCTION  <SNR>114_process_removed()
Called 8 times
Total time:   0.000143
 Self time:   0.000143

count  total (s)   self (s)
    8              0.000022   if a:to_line == 0
    8              0.000055     call add(a:modifications, [1, 'removed_first_line'])
    8              0.000011   else
                                call add(a:modifications, [a:to_line, 'removed'])
                              endif

FUNCTION  airline#highlighter#highlight()
Called 54 times
Total time:   0.876361
 Self time:   0.155382

count  total (s)   self (s)
   54              0.000334   let bufnr = a:0 ? a:1 : ''
   54              0.000437   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
   54              0.000910   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
   54              0.000276   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
   54              0.000204   let airline_grouplist = []
   54              0.000438   let buffers_in_tabpage = sort(tabpagebuflist())
   54              0.000271   if exists("*uniq")
   54              0.000269     let buffers_in_tabpage = uniq(buffers_in_tabpage)
   54              0.000075   endif
                              " mapped might be something like ['normal', 'normal_modified']
                              " if a group is in both modes available, only define the second
                              " that is how this was done previously overwrite the previous definition
  119              0.000452   for mode in reverse(mapped)
   65              0.000603     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
   54              0.000295       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  799              0.003088       for kvp in items(dict)
  745              0.002398         let mode_colors = kvp[1]
  745              0.001846         let name = kvp[0]
  745              0.003005         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                      let name = 'airline_c'.bufnr
                                    endif
                                    " do not re-create highlighting for buffers that are no longer visible
                                    " in the current tabpage
  745              0.012010         if name =~# 'airline_c\d\+'
                                      let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
                                      if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
                                        continue
                                      endif
                                    elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                      " group will be redefined below at exec_separator
                                      " or is not needed for tabline with '_inactive' suffix
                                      " since active flag is 1 for builder)
  309              0.000694           continue
                                    endif
  436   0.011458   0.004848         if s:group_not_done(airline_grouplist, name.suffix)
  396   0.134886   0.003787           call airline#highlighter#exec(name.suffix, mode_colors)
  396              0.000393         endif
                            
 1308              0.004700         for accent in keys(s:accents)
  872              0.003847           if !has_key(p.accents, accent)
                                        continue
                                      endif
  872              0.005523           let colors = copy(mode_colors)
  872              0.003195           if p.accents[accent][0] != ''
  436              0.001576             let colors[0] = p.accents[accent][0]
  436              0.000392           endif
  872              0.002258           if p.accents[accent][2] != ''
                                        let colors[2] = p.accents[accent][2]
                                      endif
  872              0.002339           if len(colors) >= 5
  818              0.004112             let colors[4] = get(p.accents[accent], 4, '')
  818              0.000774           else
   54              0.000251             call add(colors, get(p.accents[accent], 4, ''))
   54              0.000040           endif
  872   0.021259   0.009908           if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
  792   0.250579   0.008204             call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  792              0.000797           endif
  872              0.001277         endfor
  436              0.000538       endfor
                            
   54              0.000199       if empty(s:separators)
                                    " nothing to be done
                                    continue
                                  endif
                                  " TODO: optimize this
  662              0.002364       for sep in items(s:separators)
                                    " we cannot check, that the group already exists, else the separators
                                    " might not be correctly defined. But perhaps we can skip above groups
                                    " that match the '_to_' name, because they would be redefined here...
  608   0.337971   0.008427         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
  608              0.000859       endfor
   54              0.000028     endif
   65              0.000254   endfor

FUNCTION  <SNR>47_winshell()
Called 19 times
Total time:   0.000317
 Self time:   0.000317

count  total (s)   self (s)
   19              0.000287   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  <SNR>31_Unmap()
Called 1 time
Total time:   0.001308
 Self time:   0.000958

count  total (s)   self (s)
    1   0.000256   0.000076   let imaps = s:get('right_delims', []) + s:get('left_delims', []) + s:get('quotes_list', []) + s:get('apostrophes_list', []) + ['<BS>', '<C-h>', '<S-BS>', '<Del>', '<CR>', '<Space>', '<S-Tab>', '<Esc>'] + ['<Up>', '<Down>', '<Left>', '<Right>', '<LeftMouse>', '<RightMouse>'] + ['<C-Left>', '<C-Right>'] + ['<Home>', '<End>', '<PageUp>', '<PageDown>', '<S-Down>', '<S-Up>', '<C-G>g']
                            
   33              0.000051   for map in imaps
   32              0.000542     if maparg(map, "i") =~# '^<Plug>delimitMate'
   11              0.000018       if map == '|'
                                    let map = '<Bar>'
                                  endif
   11              0.000084       exec 'silent! iunmap <buffer> ' . map
   11              0.000008     endif
   32              0.000027   endfor
    1   0.000202   0.000032   silent! doautocmd <nomodeline> User delimitMate_unmap
    1              0.000002   let b:delimitMate_enabled = 0

FUNCTION  <SNR>118_OnInsertLeave()
Called 4 times
Total time:   0.050911
 Self time:   0.021753

count  total (s)   self (s)
    4   0.000968   0.000095   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
    4              0.000082   call timer_stop( s:pollers.completion.id )
    4              0.000038   let s:force_semantic = 0
    4              0.000063   let s:completion = s:default_completion
                            
    4   0.028379   0.000095   call s:OnFileReadyToParse()
    4              0.021181   exec s:python_command "ycm_state.OnInsertLeave()"
    4              0.000072   if g:ycm_autoclose_preview_window_after_completion || g:ycm_autoclose_preview_window_after_insertion
                                call s:ClosePreviewWindowIfNeeded()
                              endif

FUNCTION  <SNR>114_process_hunk()
Called 63 times
Total time:   0.020347
 Self time:   0.006894

count  total (s)   self (s)
   63              0.000227   let modifications = []
   63              0.000222   let from_line  = a:hunk[0]
   63              0.000172   let from_count = a:hunk[1]
   63              0.000158   let to_line    = a:hunk[2]
   63              0.000152   let to_count   = a:hunk[3]
                            
   63   0.000886   0.000510   if s:is_added(from_count, to_count)
   24   0.002554   0.000219     call s:process_added(modifications, from_count, to_count, to_line)
   24   0.001966   0.000224     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
                            
   24              0.000085   elseif s:is_removed(from_count, to_count)
    8   0.000235   0.000092     call s:process_removed(modifications, from_count, to_count, to_line)
    8   0.000781   0.000089     call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
                            
    8              0.000032   elseif s:is_modified(from_count, to_count)
   14   0.000725   0.000163     call s:process_modified(modifications, from_count, to_count, to_line)
   14   0.001362   0.000132     call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                            
   14              0.000063   elseif s:is_modified_and_added(from_count, to_count)
   17   0.003208   0.000219     call s:process_modified_and_added(modifications, from_count, to_count, to_line)
   17   0.001723   0.000222     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
   17   0.001481   0.000176     call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
                            
   17              0.000083   elseif s:is_modified_and_removed(from_count, to_count)
                                call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
                            
                              endif
   63              0.000146   return modifications

FUNCTION  airline#builder#get_next_group()
Called 3 times
Total time:   0.000097
 Self time:   0.000097

count  total (s)   self (s)
    3              0.000008   let x = a:i + 1
    3              0.000010   let l = len(a:sections)
    6              0.000010   while x < l
    6              0.000025     let group = a:sections[x][0]
    6              0.000014     if group != '' && group != '|'
    3              0.000003       return group
                                endif
    3              0.000006     let x = x + 1
    3              0.000004   endwhile
                              return ''

FUNCTION  airline#parts#ffenc()
Called 3068 times
Total time:   0.187552
 Self time:   0.187552

count  total (s)   self (s)
 3068              0.029600   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
 3068              0.015575   let bomb     = &l:bomb ? '[BOM]' : ''
 3068              0.066273   let ff       = strlen(&ff) ? '['.&ff.']' : ''
 3068              0.033967   if expected is# &fenc.bomb.ff
                                return ''
                              else
 3068              0.025269     return &fenc.bomb.ff
                              endif

FUNCTION  <SNR>90_format_name()
Called 2 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    2              0.000004     return a:name

FUNCTION  <SNR>32_is_smart_quote()
Called 5 times
Total time:   0.001682
 Self time:   0.001465

count  total (s)   self (s)
                              " TODO: Allow using a:char in the pattern.
    5   0.000294   0.000077   let tmp = s:get('smart_quotes')
    5              0.000026   if empty(tmp)
                                return 0
                              endif
    5              0.000247   let regex = matchstr(tmp, '^!\?\zs.*')
                              " Flip matched value if regex starts with !
    5              0.000079   let mod = tmp =~ '^!' ? [1, 0] : [0, 1]
    5              0.000334   let matched = search(regex, 'ncb', line('.')) > 0
    5              0.000099   let noescaped = substitute(getline('.'), '\\.', '', 'g')
    5              0.000461   let odd =  (count(split(noescaped, '\zs'), a:char) % 2)
    5              0.000052   let result = mod[matched] || odd
    5              0.000019   return result

FUNCTION  <SNR>46_on_bufenter()
Called 1 time
Total time:   0.018777
 Self time:   0.000031

count  total (s)   self (s)
    1              0.000002   if exists('t:gitgutter_didtabenter') && t:gitgutter_didtabenter
                                let t:gitgutter_didtabenter = 0
                                call gitgutter#all(!g:gitgutter_terminal_reports_focus)
                              else
    1   0.001809   0.000008     call gitgutter#init_buffer(bufnr(''))
    1   0.016958   0.000013     call gitgutter#process_buffer(bufnr(''), !g:gitgutter_terminal_reports_focus)
    1              0.000001   endif

FUNCTION  deoplete#util#vimoption2python()
Called 523 times
Total time:   0.243225
 Self time:   0.008014

count  total (s)   self (s)
  523   0.242861   0.007650   return '[\w' . s:vimoption2python(a:option) . ']'

FUNCTION  gitgutter#utility#shellescape()
Called 117 times
Total time:   0.007205
 Self time:   0.006888

count  total (s)   self (s)
  117              0.005643   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   98              0.000416     return a:arg
                              elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
   19              0.000116     return shellescape(a:arg)
                              endif

FUNCTION  <SNR>82_ProcessEntries()
Called 22 times
Total time:   0.030747
 Self time:   0.003807

count  total (s)   self (s)
   22   0.000222   0.000081     if s:need_to_postpone_loclist(a:jobinfo)
                                    return neomake#action_queue#add(['BufEnter', 'WinEnter'], [s:function('s:ProcessEntries'), [a:jobinfo, a:entries] + a:000])
                                endif
   22              0.000048     if !a:0 || type(a:[len(a:000)]) != 0
   11              0.000127         return s:pcall('s:ProcessEntries', [a:jobinfo, a:entries] + a:000)
                                endif
   11              0.000015     let file_mode = a:jobinfo.file_mode
                            
   11   0.000419   0.000065     call neomake#log#debug(printf( 'Processing %d entries.', len(a:entries)), a:jobinfo)
                            
   11              0.000009     if a:0 > 1
                                    " Via errorformat processing, where the list has been set already.
                                    let prev_list = a:1
                                    let new_list = file_mode ? getloclist(0) : getqflist()
                                else
                                    " Fix entries with get_list_entries/process_output/process_json.
   11              0.000017         let maker_name = a:jobinfo.maker.name
   11              0.000212         call map(a:entries, 'extend(v:val, {' . "'bufnr': str2nr(get(v:val, 'bufnr', 0))," . "'lnum': str2nr(v:val.lnum)," . "'col': str2nr(get(v:val, 'col', 0))," . "'vcol': str2nr(get(v:val, 'vcol', 0))," . "'type': get(v:val, 'type', 'E')," . "'nr': get(v:val, 'nr', -1)," . "'maker_name': maker_name," . '})')
                            
   11   0.005445   0.000051         let cd_error = a:jobinfo.cd()
   11              0.000012         if !empty(cd_error)
                                        call neomake#log#debug(printf( "Could not change to job's cwd (%s): %s.", a:jobinfo.cd_from_setting, cd_error), a:jobinfo)
                                    endif
                            
   11   0.000652   0.000070         let prev_list = s:create_locqf_list(a:jobinfo)
                            
   11              0.000014         try
   11              0.000039             let list_entries = a:entries
                                        " Add marker for custom quickfix to the first (new) entry.
   11   0.000091   0.000058             if neomake#quickfix#is_enabled() && !empty(a:entries)
                                            let config = { 'name': maker_name, 'short': get(a:jobinfo.maker, 'short_name', maker_name[:3]), }
                                            let marker_entry = copy(a:entries[0])
                                            let marker_entry.text .= printf(' nmcfg:%s', string(config))
                                            let list_entries = [marker_entry] + a:entries[1:]
                                        endif
                            
   11              0.000010             if file_mode
   11              0.000012                 if s:needs_to_replace_qf_for_lwindow
                                                call setloclist(0, prev_list + list_entries, 'r')
                                            else
   11              0.000362                     call setloclist(0, list_entries, 'a')
   11              0.000006                 endif
   11              0.000004             else
                                            if s:needs_to_replace_qf_for_lwindow
                                                call setqflist(prev_list + list_entries, 'r')
                                            else
                                                call setqflist(list_entries, 'a')
                                            endif
                                        endif
   11              0.000011         finally
   11   0.000081   0.000035             call a:jobinfo.cd_back()
   11              0.000009         endtry
   11              0.000043         let new_list = file_mode ? getloclist(0) : getqflist()
   11              0.000024         let parsed_entries = new_list[len(prev_list):]
   11              0.000009         let idx = 0
   19              0.000023         for e in parsed_entries
    8              0.000013             if a:entries[idx].bufnr != e.bufnr
    8   0.000241   0.000052                 call neomake#log#debug(printf( 'Updating entry bufnr: %s => %s.', a:entries[idx].bufnr, e.bufnr))
    8              0.000015                 let a:entries[idx].bufnr = e.bufnr
    8              0.000004             endif
    8              0.000009             let idx += 1
    8              0.000005         endfor
   11              0.000005     endif
   11   0.000918   0.000053     call s:clean_for_new_make(s:make_info[a:jobinfo.make_id])
                            
   11              0.000014     let counts_changed = 0
   11              0.000016     let maker_type = file_mode ? 'file' : 'project'
   11              0.000037     let do_highlight = get(g:, 'neomake_highlight_columns', 1) || get(g:, 'neomake_highlight_lines', 0)
   11              0.000014     let signs_by_bufnr = {}
   11   0.000223   0.000071     let debug = neomake#utils#get_verbosity(a:jobinfo) >= 3 || !empty(get(g:, 'neomake_logfile'))
   11              0.000019     let entries_with_lnum_by_bufnr = {}
   11              0.000019     let skipped_without_bufnr = []
   11              0.000011     let skipped_without_lnum = []
                            
   11              0.000010     let idx = -1
   19              0.000042     for entry in a:entries
    8              0.000018         let idx += 1
    8              0.000014         if !file_mode
                                        if neomake#statusline#AddQflistCount(entry)
                                            let counts_changed = 1
                                        endif
                                    endif
                            
    8              0.000016         if !entry.bufnr
                                        if debug
                                            let skipped_without_bufnr += [idx]
                                        endif
                                        continue
                                    endif
                            
    8              0.000012         if file_mode
    8   0.000802   0.000149             if neomake#statusline#AddLoclistCount(entry.bufnr, entry)
    8              0.000022                 let counts_changed = 1
    8              0.000007             endif
    8              0.000004         endif
                            
    8              0.000019         if !entry.lnum
                                        if debug
                                            let skipped_without_lnum += [idx]
                                        endif
                                        continue
                                    endif
                            
    8              0.000047         if !has_key(entries_with_lnum_by_bufnr, entry.bufnr)
    2              0.000014             let entries_with_lnum_by_bufnr[entry.bufnr] = []
    2              0.000010             let signs_by_bufnr[entry.bufnr] = []
    2              0.000017             if !exists('s:current_errors[maker_type][entry.bufnr]')
    1              0.000005                 let s:current_errors[maker_type][entry.bufnr] = {}
    1              0.000002             endif
    2              0.000001         endif
                            
    8              0.000018         if do_highlight || g:neomake_place_signs
                                        " NOTE: only lnum/type required for signs.  Similar for do_highlight?!
    8              0.000048             call add(entries_with_lnum_by_bufnr[entry.bufnr], entry)
    8              0.000006         endif
                            
                                    " Track all errors by buffer and line
    8              0.000050         if !has_key(s:current_errors[maker_type][entry.bufnr], entry.lnum)
    2              0.000019             let s:current_errors[maker_type][entry.bufnr][entry.lnum] = [entry]
    2              0.000004         else
    6              0.000035             call add(s:current_errors[maker_type][entry.bufnr][entry.lnum], entry)
    6              0.000005         endif
    8              0.000012     endfor
                            
                                " Handle placing signs and highlights.
   13              0.000044     for [b, entries] in items(entries_with_lnum_by_bufnr)
    2              0.000005         if g:neomake_place_signs
    2   0.002601   0.000079             call neomake#signs#PlaceSigns(b, entries, maker_type)
    2              0.000003         endif
    2              0.000005         if do_highlight
   10              0.000017             for entry in entries
    8   0.000524   0.000085                 call neomake#highlights#AddHighlight(entry, maker_type)
    8              0.000006             endfor
    2              0.000002         endif
    2              0.000001     endfor
                            
   11              0.000014     if !empty(skipped_without_bufnr)
                                    call neomake#log#debug(printf('Skipped %d entries without bufnr: %s.', len(skipped_without_bufnr), string(map(skipped_without_bufnr, 'a:entries[v:val]'))), a:jobinfo)
                                endif
                            
   11              0.000012     if !empty(skipped_without_lnum)
                                    call neomake#log#debug(printf( 'Could not place signs for %d entries without line number: %s.', len(skipped_without_lnum), string(map(skipped_without_lnum, 'a:entries[v:val]'))), a:jobinfo)
                                endif
                            
   11              0.000008     if !counts_changed
   10              0.000016         let counts_changed = new_list != prev_list
   10              0.000004     endif
   11              0.000006     if counts_changed
    1   0.000039   0.000016         call neomake#utils#hook('NeomakeCountsChanged', {'reset': 0, 'jobinfo': a:jobinfo})
    1              0.000001     endif
                            
   11              0.000010     if !empty(new_list)
    1   0.000033   0.000023         call s:HandleLoclistQflistDisplay(a:jobinfo, new_list)
    1              0.000001     endif
   11   0.000046   0.000043     call neomake#highlights#ShowHighlights()
   11              0.000024     return g:neomake#action_queue#processed

FUNCTION  airline#util#ignore_buf()
Called 3071 times
Total time:   0.202802
 Self time:   0.202802

count  total (s)   self (s)
 3071              0.055327   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  'gundo|undotree|vimfiler|tagbar|nerd_tree|startify|!')
 3071              0.141286   return match(a:name, pat) > -1

FUNCTION  <SNR>47_not_git_dir()
Called 58 times
Total time:   0.041622
 Self time:   0.002570

count  total (s)   self (s)
   58   0.041496   0.002443   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  neomake#CursorMovedDelayed()
Called 324 times
Total time:   0.019520
 Self time:   0.019520

count  total (s)   self (s)
  324              0.002793     if exists('s:cursormoved_timer')
  324              0.002667         call timer_stop(s:cursormoved_timer)
  324              0.000622     endif
  324              0.008221     let s:cursormoved_timer = timer_start(get(g:, 'neomake_cursormoved_delay', 100), function('s:cursormoved_delayed_cb'))
  324              0.004068     let s:cursormoved_last_pos = getpos('.')

FUNCTION  neomake#get_maker_by_name()
Called 1 time
Total time:   0.003533
 Self time:   0.000338

count  total (s)   self (s)
    1              0.000004     let for_ft = a:0 ? a:1 : 0
    1              0.000005     let ft_config = for_ft is# 0 ? &filetype : for_ft
    1              0.000004     let bufnr = bufnr('%')
    1              0.000015     if a:maker_name !~# '\v^\w+$'
                                    throw printf('Neomake: Invalid maker name: "%s"', a:maker_name)
                                endif
                            
    1   0.002507   0.000041     let maker = neomake#utils#GetSetting('maker', {'name': a:maker_name}, s:unset_dict, ft_config, bufnr)
    1              0.000022     if maker is# s:unset_dict
    1              0.000021         if a:maker_name ==# 'makeprg'
                                        let maker = s:get_makeprg_maker()
                                    elseif for_ft isnot# 0
    1   0.000848   0.000120             let maker = s:GetMakerForFiletype(for_ft, a:maker_name)
    1              0.000003         else
                                        call neomake#utils#load_global_makers()
                                        let f = 'neomake#makers#'.a:maker_name.'#'.a:maker_name
                                        if exists('*'.f)
                                            let maker = call(f, [])
                                        endif
                                    endif
    1              0.000001     endif
    1              0.000008     if type(maker) != type({})
                                    throw printf('Neomake: Got non-dict for maker %s: %s', a:maker_name, maker)
                                endif
    1              0.000008     if maker isnot# s:unset_dict && !has_key(maker, 'name')
    1              0.000007         let maker.name = a:maker_name
    1              0.000002     endif
    1              0.000002     return maker

FUNCTION  gitgutter#async#available()
Called 20 times
Total time:   0.000167
 Self time:   0.000167

count  total (s)   self (s)
   20              0.000084   return s:available

FUNCTION  neomake#signs#Reset()
Called 41 times
Total time:   0.001108
 Self time:   0.001108

count  total (s)   self (s)
   41              0.000577     if has_key(s:placed_signs[a:type], a:bufnr)
    1              0.000021         let s:last_placed_signs[a:type][a:bufnr] = s:placed_signs[a:type][a:bufnr]
    1              0.000006         unlet s:placed_signs[a:type][a:bufnr]
    1              0.000002     endif

FUNCTION  <SNR>118_OnFileTypeSet()
Called 1 time
Total time:   0.015736
 Self time:   0.005942

count  total (s)   self (s)
    1   0.000313   0.000004   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
    1   0.000038   0.000020   call s:SetUpCompleteopt()
    1   0.000014   0.000009   call s:SetCompleteFunc()
    1   0.000024   0.000010   call s:StartMessagePoll()
                            
    1   0.005839   0.005808   exec s:python_command "ycm_state.OnBufferVisit()"
    1   0.009503   0.000087   call s:OnFileReadyToParse( 1 )

FUNCTION  gitgutter#diff#parse_hunk()
Called 63 times
Total time:   0.003267
 Self time:   0.003267

count  total (s)   self (s)
   63              0.001538   let matches = matchlist(a:line, s:hunk_re)
   63              0.000234   if len(matches) > 0
   63              0.000282     let from_line  = str2nr(matches[1])
   63              0.000300     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
   63              0.000229     let to_line    = str2nr(matches[3])
   63              0.000275     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
   63              0.000286     return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end

FUNCTION  airline#themes#one#refresh()
Called 12 times
Total time:   0.061075
 Self time:   0.015140

count  total (s)   self (s)
   12   0.008107   0.002032   let g:airline#themes#one#palette.accents = { 'red': airline#themes#get_highlight('Constant'), }
                            
   12   0.004534   0.000643   let s:N1 = airline#themes#get_highlight2(['CursorLine', 'bg'], ['DiffAdd', 'fg'], 'none')
   12   0.004389   0.000310   let s:N2 = airline#themes#get_highlight2(['Normal', 'fg'], ['SpecialKey', 'fg'], 'none')
   12   0.005755   0.000225   let s:N3 = airline#themes#get_highlight('CursorLine')
   12   0.003963   0.002360   let g:airline#themes#one#palette.normal = airline#themes#generate_color_map(s:N1, s:N2, s:N3)
                            
   12   0.005204   0.000492   let group = airline#themes#get_highlight('vimCommand')
   12              0.000181   let g:airline#themes#one#palette.normal_modified = { 'airline_c': [ group[0], '', group[2], '', '' ] }
                            
   12   0.003338   0.000393   let s:I1 = airline#themes#get_highlight2(['Normal', 'bg'], ['DiffLine', 'fg'], 'none')
   12   0.003162   0.000358   let s:I2 = airline#themes#get_highlight2(['Normal', 'fg'], ['SpecialKey', 'fg'], 'none')
   12              0.000043   let s:I3 = s:N3
   12   0.002531   0.001291   let g:airline#themes#one#palette.insert = airline#themes#generate_color_map(s:I1, s:I2, s:I3)
   12              0.000123   let g:airline#themes#one#palette.insert_modified = g:airline#themes#one#palette.normal_modified
                            
   12   0.003545   0.000555   let s:R1 = airline#themes#get_highlight2(['Normal', 'bg'], ['Error', 'fg'], 'none')
   12              0.000128   let s:R2 = s:N2
   12              0.000033   let s:R3 = s:N3
   12   0.002192   0.001147   let g:airline#themes#one#palette.replace = airline#themes#generate_color_map(s:R1, s:R2, s:R3)
   12              0.000100   let g:airline#themes#one#palette.replace_modified = g:airline#themes#one#palette.normal_modified
                            
   12   0.003067   0.000477   let s:V1 = airline#themes#get_highlight2(['Normal', 'bg'], ['Statement', 'fg'], 'none')
   12   0.002572   0.000285   let s:V2 = airline#themes#get_highlight2(['Normal', 'fg'], ['SpecialKey', 'fg'], 'none')
   12              0.000070   let s:V3 = s:N3
   12   0.002191   0.001123   let g:airline#themes#one#palette.visual = airline#themes#generate_color_map(s:V1, s:V2, s:V3)
   12              0.000491   let g:airline#themes#one#palette.visual_modified = g:airline#themes#one#palette.normal_modified
                            
   12   0.002551   0.000354   let s:IA = airline#themes#get_highlight2(['NonText', 'fg'], ['CursorLine', 'bg'])
   12   0.002160   0.001285   let g:airline#themes#one#palette.inactive = airline#themes#generate_color_map(s:IA, s:IA, s:IA)
   12              0.000385   let g:airline#themes#one#palette.inactive_modified = { 'airline_c': [ group[0], '', group[2], '', '' ] }

FUNCTION  <SNR>107_get_section()
Called 275 times
Total time:   0.008086
 Self time:   0.007102

count  total (s)   self (s)
  275              0.000655   if has_key(s:section_truncate_width, a:key)
  200              0.000412     if winwidth(a:winnr) < s:section_truncate_width[a:key]
                                  return ''
                                endif
  200              0.000076   endif
  275              0.000469   let spc = g:airline_symbols.space
  275              0.000889   if !exists('g:airline_section_{a:key}')
                                return ''
                              endif
  275   0.002518   0.001534   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
  275              0.001375   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
  275              0.000688   return empty(text) ? '' : prefix.text.suffix

FUNCTION  deoplete#util#get_context_filetype()
Called 226 times
Total time:   0.056797
 Self time:   0.045526

count  total (s)   self (s)
  226              0.001712   if !exists('s:context_filetype')
                                let s:context_filetype = {}
                            
                                " Force context_filetype call.
                                try
                                  call context_filetype#get_filetype()
                                catch
                                  " Ignore error
                                endtry
                              endif
                            
  226              0.020220   if empty(s:context_filetype) || s:context_filetype.prev_filetype !=# &filetype || s:context_filetype.line != line('.') || s:context_filetype.bufnr != bufnr('%') || (a:input =~# '\W$' &&     substitute(a:input, '\s\zs\s\+$', '', '') !=#     substitute(s:context_filetype.input, '\s\zs\s\+$', '', '')) || (a:input =~# '\w$' &&     substitute(a:input, '\w\+$', '', '') !=#     substitute(s:context_filetype.input, '\w\+$', '', '')) || a:event ==# 'InsertEnter'
                            
   69              0.000626     let s:context_filetype.line = line('.')
   69              0.000433     let s:context_filetype.bufnr = bufnr('%')
   69              0.000467     let s:context_filetype.input = a:input
   69              0.000455     let s:context_filetype.prev_filetype = &filetype
   69              0.001276     let s:context_filetype.filetype = (exists('*context_filetype#get_filetype') ?   context_filetype#get_filetype() :   (&filetype ==# '' ? 'nothing' : &filetype))
   69   0.015195   0.003923     let s:context_filetype.filetypes = exists('*context_filetype#get_filetypes') ?   context_filetype#get_filetypes() :   &filetype ==# '' ? ['nothing'] :                     deoplete#util#uniq([&filetype]                          + split(&filetype, '\.'))
   69              0.001168     let s:context_filetype.same_filetypes = exists('*context_filetype#get_same_filetypes') ?   context_filetype#get_same_filetypes() : []
   69              0.000154   endif
  226              0.002101   return [ s:context_filetype.filetype,  s:context_filetype.filetypes, s:context_filetype.same_filetypes]

FUNCTION  <SNR>107_add_section()
Called 200 times
Total time:   0.012687
 Self time:   0.004566

count  total (s)   self (s)
  200              0.000747     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
  200   0.002030   0.000695     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
                                endif
  200              0.000121     if condition
                                  call a:builder.add_raw('%(')
                                endif
  200   0.008399   0.001614     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
  200              0.000227     if condition
                                  call a:builder.add_raw('%)')
                                endif

FUNCTION  neomake#log#debug()
Called 1864 times
Total time:   0.130366
 Self time:   0.031019

count  total (s)   self (s)
 1864   0.128732   0.029385     call call('s:log', [3] + a:000)

FUNCTION  <SNR>82_pcall()
Called 22 times
Total time:   0.052111
 Self time:   0.000227

count  total (s)   self (s)
   22              0.000041     let jobinfo = a:args[0]
   22              0.000024     try
   22   0.035884   0.020756         return call(a:fn, a:args + [1])
                                catch /^\%(Vim\%((\a\+)\)\=:\%(E48\|E523\)\)/  " only E48/E523 (sandbox / not allowed here)
                                    call neomake#log#debug('Error during pcall: '.v:exception.'.', jobinfo)
                                    call neomake#log#debug(printf('(in %s)', v:throwpoint), jobinfo)
                                    " Might throw in case of X failed attempts.
                                    call neomake#action_queue#add(['Timer', 'WinEnter'], [s:function(a:fn), a:args])
                                endtry
                                return g:neomake#action_queue#not_processed

FUNCTION  neomake#CancelMake()
Called 31 times
Total time:   0.017290
 Self time:   0.002639

count  total (s)   self (s)
   31              0.000119     if !has_key(s:make_info, a:make_id)
                                    call neomake#log#error('CancelMake: make not found: '.a:make_id.'.')
                                    return 0
                                endif
   31              0.000098     let make_info = s:make_info[a:make_id]
   31              0.000084     let make_info.canceled = 1
   31              0.000074     let make_info.make_id = a:make_id  " for logging.
   31   0.001892   0.000177     call neomake#log#debug('Cancelling make.', make_info)
   31              0.000067     let bang = a:0 ? a:1 : 0
   31              0.000263     let jobs = filter(copy(values(s:jobs)), 'v:val.make_id == a:make_id')
   62              0.000146     for job in jobs
   31   0.008335   0.000290         call neomake#CancelJob(job.id, bang)
   31              0.000054     endfor
   31   0.000866   0.000237     call neomake#action_queue#clean(make_info)
                                " Ensure that make gets cleaned really, e.g. if there were no jobs yet.
   31              0.000094     if has_key(s:make_info, a:make_id)
   31   0.004583   0.000319         call s:clean_make_info(make_info, bang)
   31              0.000025     endif
   31              0.000028     return 1

FUNCTION  gitgutter#hunk#increment_lines_removed()
Called 8 times
Total time:   0.000692
 Self time:   0.000221

count  total (s)   self (s)
    8   0.000334   0.000088   let summary = gitgutter#hunk#summary(a:bufnr)
    8              0.000040   let summary[2] += a:count
    8   0.000307   0.000082   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  airline#load_theme()
Called 12 times
Total time:   0.587518
 Self time:   0.002242

count  total (s)   self (s)
   12              0.000252   let g:airline_theme = get(g:, 'airline_theme', 'dark')
   12              0.000160   if exists('*airline#themes#{g:airline_theme}#refresh')
   12   0.061400   0.000325     call airline#themes#{g:airline_theme}#refresh()
   12              0.000015   endif
                            
   12              0.000086   let palette = g:airline#themes#{g:airline_theme}#palette
   12   0.007320   0.000364   call airline#themes#patch(palette)
                            
   12              0.000074   if exists('g:airline_theme_patch_func')
                                let Fn = function(g:airline_theme_patch_func)
                                call Fn(palette)
                              endif
                            
   12   0.395656   0.000308   call airline#highlighter#load_theme()
   12   0.039619   0.000211   call airline#extensions#load_theme()
   12   0.082731   0.000242   call airline#update_statusline()

FUNCTION  <SNR>132_nvim_untracked_job_handler()
Called 2 times
Total time:   0.000272
 Self time:   0.000133

count  total (s)   self (s)
    2              0.000017     if a:event == 'exit'
    2   0.000212   0.000072       call s:untracked_output(self, self.buf)
    2              0.000016       if has_key(s:untracked_jobs, self.file)
    2              0.000016         call remove(s:untracked_jobs, self.file)
    2              0.000003       endif
    2              0.000002     endif

FUNCTION  airline#parts#paste()
Called 3068 times
Total time:   0.021665
 Self time:   0.021665

count  total (s)   self (s)
 3068              0.019258   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  <SNR>114_process_modified()
Called 14 times
Total time:   0.000562
 Self time:   0.000562

count  total (s)   self (s)
   14              0.000059   let offset = 0
   34              0.000093   while offset < a:to_count
   20              0.000061     let line_number = a:to_line + offset
   20              0.000114     call add(a:modifications, [line_number, 'modified'])
   20              0.000050     let offset += 1
   20              0.000027   endwhile

FUNCTION  <SNR>82_CleanJobinfo()
Called 41 times
Total time:   0.106670
 Self time:   0.004108

count  total (s)   self (s)
   41              0.000193     if get(a:jobinfo, 'pending_output', 0) && !get(a:jobinfo, 'canceled', 0)
                                    call neomake#log#debug( 'Output left to be processed, not cleaning job yet.', a:jobinfo)
                                    return
                                endif
                            
   41   0.000946   0.000274     let queued_actions = neomake#action_queue#get_queued_actions(a:jobinfo)
   41              0.000070     if !empty(queued_actions)
                                    call neomake#log#debug(printf( 'Skipping cleaning of job info because of queued actions: %s.', join(queued_actions, ', ')), a:jobinfo)
                                    return neomake#action_queue#add(['WinEnter'], [s:function('s:CleanJobinfo'), [a:jobinfo]])
                                endif
                            
   41   0.001899   0.000195     call neomake#log#debug('Cleaning jobinfo.', a:jobinfo)
   41              0.000108     let a:jobinfo.finished = 1
                            
   41              0.000107     if !has_key(s:make_info, a:jobinfo.make_id)
                                    return
                                endif
   41              0.000091     let make_info = s:make_info[a:jobinfo.make_id]
                            
   41              0.000123     if has_key(s:jobs, get(a:jobinfo, 'id', -1))
   41              0.000132         call remove(s:jobs, a:jobinfo.id)
   41              0.000192         call filter(s:map_job_ids, 'v:val != a:jobinfo.id')
                            
   41              0.000098         if has_key(s:pending_outputs, a:jobinfo.id)
                                        unlet s:pending_outputs[a:jobinfo.id]
                                    endif
   41              0.000020     endif
                            
   41              0.000085     if exists('s:kill_vim_timers')
                                    for [timer, job] in items(s:kill_vim_timers)
                                        if job == a:jobinfo
                                            call timer_stop(+timer)
                                            unlet s:kill_vim_timers[timer]
                                            break
                                        endif
                                    endfor
                                endif
                            
   41              0.000123     if !get(a:jobinfo, 'canceled', 0) && !get(a:jobinfo, 'failed_to_start', 0)
   11              0.000028         let make_info.finished_jobs += [a:jobinfo]
   11   0.000242   0.000068         call neomake#utils#hook('NeomakeJobFinished', {'jobinfo': a:jobinfo})
   11              0.000007     endif
                            
   41              0.000187     call filter(make_info.active_jobs, 'v:val != a:jobinfo')
                            
                                " Trigger cleanup (and autocommands) if all jobs have finished.
   41              0.000129     if empty(make_info.active_jobs) && empty(make_info.jobs_queue)
   41   0.100320   0.000308         call s:clean_make_info(make_info)
   41              0.000056         return g:neomake#action_queue#processed
                                endif

FUNCTION  <SNR>82_RegisterJobOutput()
Called 11 times
Total time:   0.045145
 Self time:   0.000411

count  total (s)   self (s)
                                " Allow to filter output (storing the setting on the jobinfo lazily).
   11              0.000025     if !has_key(a:jobinfo, 'filter_output')
   11   0.006715   0.000097         let a:jobinfo.filter_output = neomake#utils#GetSetting('filter_output', a:jobinfo.maker, '', a:jobinfo.ft, a:jobinfo.bufnr)
   11              0.000005     endif
   11              0.000017     if !empty(a:jobinfo.filter_output)
                                    call call(a:jobinfo.filter_output, [ a:lines, {'source': a:source, 'jobinfo': a:jobinfo}], a:jobinfo.maker)
                                endif
                            
   11              0.000011     if empty(a:lines)
                                    return
                                endif
                            
   11              0.000018     if a:jobinfo.output_stream !=# 'both' && a:jobinfo.output_stream !=# a:source
                                    if !has_key(a:jobinfo, 'unexpected_output')
                                        let a:jobinfo.unexpected_output = {}
                                    endif
                                    if !has_key(a:jobinfo.unexpected_output, a:source)
                                        let a:jobinfo.unexpected_output[a:source] = []
                                    endif
                                    let a:jobinfo.unexpected_output[a:source] += a:lines
                                    return
                                endif
                            
   11   0.038205   0.000088     call s:process_pending_output(a:jobinfo, a:lines, a:source)

FUNCTION  <SNR>47_unc_path()
Called 20 times
Total time:   0.018066
 Self time:   0.000536

count  total (s)   self (s)
   20   0.017993   0.000463   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  airline#update_statusline()
Called 25 times
Total time:   0.170673
 Self time:   0.001689

count  total (s)   self (s)
   25   0.000320   0.000193   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
   25              0.000200   let range = filter(range(1, winnr('$')), 'v:val != winnr()')
                              " create inactive statusline
   25   0.000826   0.000117   call airline#update_statusline_inactive(range)
                            
   25              0.000072   unlet! w:airline_render_left w:airline_render_right
   25              0.000339   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
                              " Now create the active statusline
   25              0.000040   let w:airline_active = 1
   25              0.000130   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
   25   0.168613   0.000466   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  neomake#core#instantiate_maker()
Called 1 time
Total time:   0.034244
 Self time:   0.000286

count  total (s)   self (s)
    1              0.000002     let maker = a:maker
    1              0.000002     let options = a:options
    1              0.000003     let ft = get(options, 'ft', '')
    1              0.000002     let bufnr = get(options, 'bufnr', '')
                            
                                " Call InitForJob function in maker object, if any.
    1   0.000623   0.000032     let Init = neomake#utils#GetSetting('InitForJob', maker, g:neomake#config#undefined, ft, bufnr)
    1              0.000002     if empty(Init)
                                    " Deprecated: should use InitForJob instead.
                                    if has_key(maker, 'fn')
                                        unlet Init  " vim73
                                        let Init = maker.fn
                                        call neomake#log#warn_once(printf("Please use 'InitForJob' instead of 'fn' for maker %s.", maker.name), printf('deprecated-fn-%s', maker.name))
                                    endif
                                endif
    1              0.000002     if !empty(Init)
                                    " TODO: Allow to throw and/or return 0 to abort/skip?!
    1   0.033357   0.000019         let returned_maker = call(Init, [options], maker)
    1              0.000001         if returned_maker isnot# 0
                                        " This conditional assignment allows to both return a copy
                                        " (factory), while also can be used as a init method.
    1              0.000003             let maker = returned_maker
    1              0.000000         endif
    1              0.000000     endif
                            
    1              0.000002     if has_key(maker, '_bind_args')
    1   0.000046   0.000017         call maker._bind_args()
    1              0.000002         if type(maker.exe) != type('')
                                        let error = printf('Non-string given for executable of maker %s: type %s', maker.name, type(maker.exe))
                                        if !get(maker, 'auto_enabled', 0)
                                            throw 'Neomake: '.error
                                        endif
                                        call neomake#log#debug(error.'.', options)
                                        return {}
                                    endif
    1              0.000148         if a:check_exe && !executable(maker.exe)
                                        if get(maker, 'auto_enabled', 0)
                                            call neomake#log#debug(printf( 'Exe (%s) of auto-configured maker %s is not executable, skipping.', maker.exe, maker.name), options)
                                        else
                                            let error = printf('Exe (%s) of maker %s is not executable', maker.exe, maker.name)
                                            throw 'Neomake: '.error
                                        endif
                                        return {}
                                    endif
    1              0.000001     endif
    1              0.000002     return maker

FUNCTION  airline#update_statusline_focuslost()
Called 12 times
Total time:   0.000218
 Self time:   0.000218

count  total (s)   self (s)
   12              0.000085   if get(g:, 'airline_focuslost_inactive', 0)
                                let bufnr=bufnr('%')
                                call airline#highlighter#highlight_modified_inactive(bufnr)
                                call airline#highlighter#highlight(['inactive'], bufnr)
                                call airline#update_statusline_inactive(range(1, winnr('$')))
                              endif

FUNCTION  <SNR>106_get_transitioned_seperator()
Called 193 times
Total time:   0.097747
 Self time:   0.006425

count  total (s)   self (s)
  193              0.000309   let line = ''
  193              0.000750   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
                              else
  193   0.092657   0.001336     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
  193              0.000969     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
  193              0.000815     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
  193              0.000371     let line .= '%#'.a:group.'#'
  193              0.000117   endif
  193              0.000196   return line

FUNCTION  <SNR>118_OnCursorMovedNormalMode()
Called 324 times
Total time:   0.737271
 Self time:   0.692426

count  total (s)   self (s)
  324   0.049174   0.004329   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
  324              0.686240   exec s:python_command "ycm_state.OnCursorMoved()"

FUNCTION  <SNR>114_is_modified()
Called 31 times
Total time:   0.000227
 Self time:   0.000227

count  total (s)   self (s)
   31              0.000184   return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count

FUNCTION  neomake#compat#get_mode()
Called 213 times
Total time:   0.003499
 Self time:   0.003499

count  total (s)   self (s)
  213              0.002417         let mode = nvim_get_mode()
  213              0.000675         return mode.mode

FUNCTION  <SNR>92_diagnostics_for_buffer()
Called 6136 times
Total time: 168.767068
 Self time: 168.767068

count  total (s)   self (s)
 6136            168.755688   return get(s:diagnostics, expand('%:p'), [])

FUNCTION  airline#parts#readonly()
Called 3068 times
Total time:   0.343648
 Self time:   0.140960

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
 3068   0.273691   0.071003   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
                                return ''
                              endif
 3068              0.018502   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
                              else
 3068              0.012544     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  <SNR>124_completion_async()
Called 154 times
Total time:   0.628044
 Self time:   0.012327

count  total (s)   self (s)
  154   0.008169   0.005682   if mode() !=# 'i' || s:is_exiting()
                                call deoplete#handler#_async_timer_stop()
                                return
                              endif
                            
  154   0.617433   0.004203   call s:completion_begin(s:async_timer.event)

FUNCTION  fugitive#Head()
Called 3068 times
Total time: 212.975832
 Self time: 212.975832

count  total (s)   self (s)
 3068              0.022667   let dir = a:0 > 1 ? a:2 : get(b:, 'git_dir', '')
 3068            162.852122   if empty(dir) || !filereadable(dir . '/HEAD')
                                return ''
                              endif
 3068             49.835046   let head = readfile(dir . '/HEAD')[0]
 3068              0.098203   if head =~# '^ref: '
 3068              0.123066     return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                              elseif head =~# '^\x\{40\}$'
                                let len = a:0 ? a:1 : 0
                                return len < 0 ? head : len ? head[0:len-1] : ''
                              else
                                return ''
                              endif

FUNCTION  <SNR>110_cpath()
Called 1 time
Total time:   0.000018
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000002   if exists('+fileignorecase') && &fileignorecase
                                let path = s:PlatformSlash(tolower(a:path))
                              else
    1   0.000011   0.000007     let path = s:PlatformSlash(a:path)
    1              0.000000   endif
    1              0.000002   return a:0 ? path ==# s:cpath(a:1) : path

FUNCTION  deoplete#send_event()
Called 6 times
Total time:   0.025679
 Self time:   0.000365

count  total (s)   self (s)
    6              0.000090   let sources = get(a:000, 0, [])
    6   0.025574   0.000260   call deoplete#util#rpcnotify('deoplete_on_event', deoplete#init#_context(a:event, sources))

FUNCTION  LanguageClient#handleCompleteDone()
Called 118 times
Total time:   0.002858
 Self time:   0.002858

count  total (s)   self (s)
  118              0.001817     let user_data = get(v:completed_item, 'user_data', '')
  118              0.000435     if user_data ==# ''
  118              0.000244         return
                                endif
                            
                                try
                                    call LanguageClient#Notify('languageClient/handleCompleteDone', { 'filename': LSP#filename(), 'completed_item': v:completed_item, 'line': LSP#line(), 'character': LSP#character(), })
                                catch
                                    call s:Debug('LanguageClient caught exception: ' . string(v:exception))
                                endtry

FUNCTION  LanguageClient#handleCursorMoved()
Called 324 times
Total time:  12.785679
 Self time:   0.049229

count  total (s)   self (s)
  324              0.006557     let l:cursor_line = getcurpos()[1] - 1
  324              0.002024     if l:cursor_line == s:last_cursor_line
    2              0.000005         return
                                endif
  322              0.001456     let s:last_cursor_line = l:cursor_line
                            
  322              0.002882     if &buftype !=# '' || &filetype ==# ''
                                    return
                                endif
                            
  322              0.001103     try
  322  12.761894   0.025443         call LanguageClient#Notify('languageClient/handleCursorMoved', { 'buftype': &buftype, 'filename': LSP#filename(), 'line': l:cursor_line, 'LSP#visible_line_start()': LSP#visible_line_start(), 'LSP#visible_line_end()': LSP#visible_line_end(), })
  322              0.001235     catch
                                    call s:Debug('LanguageClient caught exception: ' . string(v:exception))
                                endtry

FUNCTION  gitgutter#utility#setbufvar()
Called 230 times
Total time:   0.006534
 Self time:   0.006534

count  total (s)   self (s)
  230              0.001937   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
  230              0.000903   let needs_setting = empty(dict)
  230              0.001874   let dict[a:varname] = a:val
  230              0.000432   if needs_setting
    1              0.000002     call setbufvar(+a:buffer, 'gitgutter', dict)
    1              0.000000   endif

FUNCTION  airline#builder#should_change_group()
Called 174 times
Total time:   0.040732
 Self time:   0.003746

count  total (s)   self (s)
  174              0.000392   if a:group1 == a:group2
                                return 0
                              endif
  174   0.020713   0.001072   let color1 = airline#highlighter#get_highlight(a:group1)
  174   0.018308   0.000962   let color2 = airline#highlighter#get_highlight(a:group2)
  174              0.000234   if g:airline_gui_mode ==# 'gui'
  174              0.000561     return color1[1] != color2[1] || color1[0] != color2[0]
                              else
                                return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  <SNR>114_is_added()
Called 63 times
Total time:   0.000376
 Self time:   0.000376

count  total (s)   self (s)
   63              0.000328   return a:from_count == 0 && a:to_count > 0

FUNCTION  airline#highlighter#exec()
Called 2175 times
Total time:   0.599083
 Self time:   0.156433

count  total (s)   self (s)
 2175              0.004803   if pumvisible()
                                return
                              endif
 2175              0.004928   let colors = a:colors
 2175              0.003128   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
 2175   0.335520   0.016031   let old_hi = airline#highlighter#get_highlight(a:group)
 2175              0.006104   if len(colors) == 4
  882              0.002581     call add(colors, '')
  882              0.000570   endif
 2175              0.003580   if g:airline_gui_mode ==# 'gui'
 2175              0.011466     let new_hi = [colors[0], colors[1], '', '', colors[4]]
 2175              0.001847   else
                                let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
                              endif
 2175   0.079005   0.015050   let colors = s:CheckDefined(colors)
 2175   0.043907   0.015661   if old_hi != new_hi || !s:hl_group_exists(a:group)
  302   0.033937   0.002977     let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
  302              0.005155     exe cmd
  302              0.001495     if has_key(s:hl_groups, a:group)
  302              0.001155       let s:hl_groups[a:group] = colors
  302              0.000267     endif
  302              0.000174   endif

FUNCTION  <SNR>93_check_mixed_indent()
Called 6 times
Total time:   0.001745
 Self time:   0.001745

count  total (s)   self (s)
    6              0.000048   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
    6              0.000017   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
                              elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw')
                              else
    6              0.001520     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  <SNR>19_stop_timer()
Called 101 times
Total time:   0.002665
 Self time:   0.002665

count  total (s)   self (s)
  101              0.000700     let timer_info = s:timer_info[a:timer]
  101              0.000574     unlet s:timer_info[a:timer]
  101              0.000434     unlet s:timer_by_bufnr[timer_info.bufnr]
  101              0.000799     call timer_stop(+a:timer)

FUNCTION  <SNR>112_on_stderr_nvim()
Called 19 times
Total time:   0.002382
 Self time:   0.000400

count  total (s)   self (s)
   19   0.002356   0.000374   call self.handler.err(self.buffer)

FUNCTION  LanguageClient#handleBufWritePost()
Called 1 time
Total time:   0.001086
 Self time:   0.000087

count  total (s)   self (s)
    1              0.000010     if &buftype !=# '' || &filetype ==# ''
                                    return
                                endif
                            
    1              0.000004     try
    1   0.001056   0.000056         call LanguageClient#Notify('languageClient/handleBufWritePost', { 'filename': LSP#filename(), })
    1              0.000003     catch
                                    call s:Debug('LanguageClient caught exception: ' . string(v:exception))
                                endtry

FUNCTION  neomake#compat#gettabwinvar()
Called 82 times
Total time:   0.000309
 Self time:   0.000309

count  total (s)   self (s)
   82              0.000261         return gettabwinvar(a:t, a:w, a:v, a:d)

FUNCTION  neomake#utils#ExpandArgs()
Called 41 times
Total time:   0.007560
 Self time:   0.007560

count  total (s)   self (s)
                                " Expand % in args similar to when using :!
                                " \% is ignored
                                " \\% is expanded to \\file.ext
                                " %% becomes %
                                " % must be followed with an expansion keyword
   41              0.004152     let ret = map(copy(a:args), 'substitute(v:val, ' . '''\(\%(\\\@<!\\\)\@<!%\%(%\|\%(:[phtreS8.~]\)\+\|\ze\w\@!\)\)'', ' . '''\=(submatch(1) == "%%" ? "%" : expand(submatch(1)))'', ' . '''g'')')
   41              0.003028     let ret = map(ret, 'substitute(v:val, ''\v^\~\ze%(/|$)'', expand(''~''), ''g'')')
   41              0.000141     return ret

FUNCTION  <SNR>68_airline_refresh()
Called 12 times
Total time:   0.678814
 Self time:   0.001567

count  total (s)   self (s)
   12              0.000194   if !exists("#airline")
                                " disabled
                                return
                              endif
   12   0.003344   0.000224   call airline#util#doautocmd('AirlineBeforeRefresh')
   12   0.005993   0.000271   call airline#highlighter#reset_hlcache()
   12   0.588111   0.000593   call airline#load_theme()
   12   0.081005   0.000118   call airline#update_statusline()

FUNCTION  LanguageClient#handleBufReadPost()
Called 1 time
Total time:   0.000675
 Self time:   0.000079

count  total (s)   self (s)
    1              0.000015     if &buftype !=# '' || &filetype ==# ''
                                    return
                                endif
                            
    1              0.000004     try
    1   0.000640   0.000044         call LanguageClient#Notify('languageClient/handleBufReadPost', { 'filename': LSP#filename(), })
    1              0.000003     catch
                                    call s:Debug('LanguageClient caught exception: ' . string(v:exception))
                                endtry

FUNCTION  airline#extensions#whitespace#check()
Called 3068 times
Total time:   0.801783
 Self time:   0.698102

count  total (s)   self (s)
 3068              0.028184   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
 3068              0.045160   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
                              endif
 3068              0.058241   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
 3068              0.020332   if !exists('b:airline_whitespace_check')
    6              0.000027     let b:airline_whitespace_check = ''
    6              0.000066     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
    6              0.000019     let trailing = 0
    6              0.000018     let check = 'trailing'
    6              0.000150     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    6              0.000020       try
    6              0.000041         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
    6              0.000755         let trailing = search(regexp, 'nw')
    6              0.000020       catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
                                  endtry
    6              0.000008     endif
                            
    6              0.000018     let mixed = 0
    6              0.000016     let check = 'indent'
    6              0.000132     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    6   0.001844   0.000098       let mixed = s:check_mixed_indent()
    6              0.000014     endif
                            
    6              0.000024     let mixed_file = ''
    6              0.000018     let check = 'mixed-indent-file'
    6              0.000132     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    6   0.000715   0.000106       let mixed_file = s:check_mixed_indent_file()
    6              0.000008     endif
                            
    6              0.000017     let long = 0
    6              0.000031     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
    6              0.000052     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file)
    5              0.000037       let b:airline_whitespace_check = s:symbol
    5              0.000029       if strlen(s:symbol) > 0
    5              0.000037         let space = (g:airline_symbols.space)
    5              0.000010       else
                                    let space = ''
                                  endif
                            
    5              0.000013       if s:show_message
    5              0.000015         if trailing != 0
    5              0.000051           let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
    5              0.000092           let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
    5              0.000013         endif
    5              0.000014         if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
    5              0.000015         if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
    5              0.000028         if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
    5              0.000007       endif
    5              0.000006     endif
    6              0.000008   endif
 3068   0.145584   0.044257   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  necosyntax#gather_candidates()
Called 6 times
Total time:   0.001022
 Self time:   0.000872

count  total (s)   self (s)
    6              0.000113   let filetype = &filetype
    6              0.000021   if filetype == ''
                                return []
                              endif
                            
    6              0.000040   if !has_key(s:syntax_list, filetype)
                                call s:make_cache()
                              endif
                            
    6              0.000011   let list = []
   12   0.000277   0.000128   for ft in s:get_context_filetypes(filetype)
    6              0.000395     let list += get(s:syntax_list, ft, [])
    6              0.000014   endfor
    6              0.000009   return list

FUNCTION  neomake#compat#getbufvar()
Called 376 times
Total time:   0.003214
 Self time:   0.003214

count  total (s)   self (s)
  376              0.002732         return getbufvar(a:buf, a:key, a:def)

FUNCTION  neomake#statusline#QflistCounts()
Called 3522 times
Total time:   0.023397
 Self time:   0.023397

count  total (s)   self (s)
 3522              0.020260     return get(s:counts, 'project', s:unknown_counts)

FUNCTION  deoplete#custom#_get_option()
Called 3651 times
Total time:   0.275336
 Self time:   0.163608

count  total (s)   self (s)
 3651   0.254810   0.143082   let custom = extend(copy(deoplete#custom#_get().option), deoplete#custom#_get_buffer().option)
 3651              0.015986   return custom[a:name]

FUNCTION  <SNR>19_debug_log()
Called 883 times
Total time:   0.103864
 Self time:   0.034695

count  total (s)   self (s)
  883              0.007743     let context = {'bufnr': bufnr('%')}
  883              0.001974     if a:0
  688              0.007323         call extend(context, a:1)
  688              0.001128     endif
  883   0.082933   0.013765     call neomake#log#debug(printf('automake: %s.', a:msg), context)

FUNCTION  <SNR>82_Make()
Called 41 times
Total time:   0.528567
 Self time:   0.028354

count  total (s)   self (s)
   41              0.000798     let is_automake = !empty(expand('<abuf>'))
   41              0.000132     if is_automake
    1              0.000004         if s:ignore_automake_events
                                        call neomake#log#debug(printf( 'Ignoring Make through autocommand due to s:ignore_automake_events=%d.', s:ignore_automake_events), {'winnr': winnr()})
                                        return []
                                    endif
    1   0.000872   0.000019         let disabled = neomake#config#get_with_source('disabled', 0)
    1              0.000004         if disabled[0]
                                        call neomake#log#debug(printf( 'Make through autocommand disabled via %s.', disabled[1]))
                                        return []
                                    endif
    1              0.000002     endif
                            
   41              0.000267     let s:make_id += 1
   41              0.000186     let make_id = s:make_id
   41              0.001362     let options = extend(copy(a:options), { 'file_mode': 1, 'bufnr': bufnr('%'), 'ft': &filetype, 'make_id': make_id, }, 'keep')
   41              0.000228     let bufnr = options.bufnr
   41              0.000208     let file_mode = options.file_mode
                            
   41              0.001749     let s:make_info[make_id] = { 'cwd': getcwd(), 'verbosity': get(g:, 'neomake_verbose', 1), 'active_jobs': [], 'finished_jobs': [], 'options': options, }
   41              0.000311     let make_info = s:make_info[make_id]
   41              0.000131     if &verbose
                                    let make_info.verbosity += &verbose
                                    call neomake#log#debug(printf( 'Adding &verbose (%d) to verbosity level: %d.', &verbose, make_info.verbosity), options)
                                endif
   41              0.000170     if make_info.verbosity >= 3
                                    call neomake#log#debug(printf( 'Calling Make with options %s.', string(filter(copy(options), "index(['bufnr', 'make_id'], v:key) == -1"))), {'make_id': make_id, 'bufnr': bufnr})
                                endif
                            
                                " Use pre-compiled jobs (used with automake).
   41              0.000234     if has_key(options, 'jobs')
   41              0.001123         let jobs = map(copy(options.jobs), "extend(v:val, {'make_id': make_id})")
   41              0.000191         unlet options.jobs
   41              0.000078     else
                                    if has_key(options, 'enabled_makers')
                                        if file_mode
                                            let makers = neomake#map_makers(options.enabled_makers, options.ft, 0)
                                        else
                                            let makers = neomake#map_makers(options.enabled_makers, -1, 0)
                                        endif
                                        unlet options.enabled_makers
                                    else
                                        let makers = call('neomake#GetEnabledMakers', file_mode ? [options.ft] : [])
                                        if empty(makers)
                                            if file_mode
                                                let msg = printf('Nothing to make: no enabled file mode makers (filetype=%s).', options.ft)
                                                if is_automake
                                                    call neomake#log#debug(msg, options)
                                                else
                                                    call neomake#log#warning(msg, options)
                                                endif
                                                unlet s:make_info[make_id]
                                                return []
                                            endif
                                        endif
                                    endif
                                    let jobs = neomake#core#create_jobs(options, makers)
                                endif
                            
   41              0.000222     if empty(jobs)
                                    call neomake#log#debug('Nothing to make: no valid makers.', options)
                                    call s:clean_make_info(make_info)
                                    return []
                                endif
                            
   41              0.001345     let maker_info = join(map(copy(jobs), "v:val.maker.name . (get(v:val.maker, 'auto_enabled', 0) ? ' (auto)' : '')"), ', ')
   41   0.006128   0.000873     call neomake#log#debug(printf( 'Running makers: %s.', maker_info), options)
                            
   41              0.000307     let make_info.jobs_queue = jobs
                            
   41              0.000105     if file_mode
                                    " XXX: this clears counts for job's buffer only, but we add counts for
                                    " the entry's buffers, which might be different!
   41   0.003581   0.000611         call neomake#statusline#ResetCountsForBuf(bufnr)
   41              0.000172         if g:neomake_place_signs
   41   0.001902   0.000793             call neomake#signs#Reset(bufnr, 'file')
   41              0.000074         endif
   41              0.000063     else
                                    call neomake#statusline#ResetCountsForProject()
                                    if g:neomake_place_signs
                                        call neomake#signs#ResetProject()
                                    endif
                                endif
                            
   41              0.000607     let w:neomake_make_ids = add(get(w:, 'neomake_make_ids', []), make_id)
                            
                                " Cancel any already running jobs for the makers from these jobs.
   41              0.000194     if !empty(s:jobs)
                                    " @vimlint(EVL102, 1, l:job)
                                    for job in jobs
                                        let running_already = values(filter(copy(s:jobs), 'v:val.maker == job.maker' .' && v:val.bufnr == job.bufnr' ." && !get(v:val, 'canceled')"))
                                        if !empty(running_already)
                                            let jobinfo = running_already[0]
                                            call neomake#log#info(printf( 'Cancelling already running job (%d.%d) for the same maker.', jobinfo.make_id, jobinfo.id), {'make_id': make_id})
                                            call neomake#CancelJob(jobinfo.id, 1)
                                        endif
                                    endfor
                                endif
                            
                                " Start all jobs in the queue (until serialized).
   41              0.000200     let jobinfos = []
   82              0.000240     while 1
   82              0.000425         if empty(make_info.jobs_queue)
   41              0.000070             break
                                    endif
   41   0.491602   0.001575         let jobinfo = s:handle_next_job({})
   41              0.000241         if empty(jobinfo)
                                        break
                                    endif
   41              0.000309         call add(jobinfos, jobinfo)
   41              0.000096         if jobinfo.serialize
                                        " Break and continue through exit handler.
                                        break
                                    endif
   41              0.000104     endwhile
   41              0.000240     return jobinfos

FUNCTION  airline#extensions#tabline#formatters#default#format()
Called 330 times
Total time:   0.414647
 Self time:   0.399973

count  total (s)   self (s)
  330              0.003061   let fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':~:.')
  330              0.000915   let _ = ''
                            
  330              0.001695   let name = bufname(a:bufnr)
  330              0.001131   if empty(name)
                                let _ .= '[No Name]'
                              else
  330              0.000830     if s:fnamecollapse
                                  " Does not handle non-ascii characters like Cyrillic: 'D/Учёба/t.c'
                                  "let _ .= substitute(fnamemodify(name, fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
  330              0.371127       let _ .= pathshorten(fnamemodify(name, fmod))
  330              0.001864     else
                                  let _ .= fnamemodify(name, fmod)
                                endif
  330              0.003741     if a:bufnr != bufnr('%') && s:fnametruncate && strlen(_) > s:fnametruncate
                                  let _ = strpart(_, 0, s:fnametruncate)
                                endif
  330              0.000457   endif
                            
  330   0.021815   0.007141   return airline#extensions#tabline#formatters#default#wrap_name(a:bufnr, _)

FUNCTION  <SNR>103_get_syn()
Called 8514 times
Total time:   0.266136
 Self time:   0.266136

count  total (s)   self (s)
 8514              0.028617   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
                              endif
 8514              0.012066   let color = ''
 8514              0.032601   if hlexists(a:group)
 8344              0.052339     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
 8344              0.006914   endif
 8514              0.019669   if empty(color) || color == -1
                                " should always exists
  230              0.004503     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
  230              0.000670     if empty(color) || color == -1
                                  let color = 'NONE'
                                endif
  230              0.000148   endif
 8514              0.010001   return color

FUNCTION  gitgutter#hunk#reset()
Called 18 times
Total time:   0.001905
 Self time:   0.000507

count  total (s)   self (s)
   18   0.000990   0.000242   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', [])
   18   0.000895   0.000246   call s:reset_summary(a:bufnr)

FUNCTION  <SNR>82_cursormoved_delayed_cb()
Called 38 times
Total time:   0.012889
 Self time:   0.002448

count  total (s)   self (s)
   38              0.001391     if getpos('.') == s:cursormoved_last_pos
   38   0.011217   0.000777         call neomake#CursorMoved()
   38              0.000078     endif

FUNCTION  <SNR>31_AutoClose()
Called 2 times
Total time:   0.001736
 Self time:   0.000969

count  total (s)   self (s)
                              " Add matching pair and jump to the midle:
                              " inoremap <silent> <buffer> ( ()<Left>
    2              0.000003   let i = 0
    8   0.000215   0.000049   while i < len(s:get('matchpairs_list'))
    6   0.000276   0.000051     let ld = s:get('left_delims')[i] == '|' ? '<bar>' : s:get('left_delims')[i]
    6   0.000255   0.000045     let rd = s:get('right_delims')[i] == '|' ? '<bar>' : s:get('right_delims')[i]
    6              0.000247     exec 'inoremap <expr><silent> <Plug>delimitMate' . ld. ' <SID>TriggerAbb().delimitMate#ParenDelim("' . escape(rd, '|') . '")'
    6              0.000085     exec 'silent! imap <unique> <buffer> '.ld.' <Plug>delimitMate'.ld
    6              0.000012     let i += 1
    6              0.000006   endwhile
                            
                              " Exit from inside the matching pair:
    8   0.000101   0.000023   for delim in s:get('right_delims')
    6              0.000014     let delim = delim == '|' ? '<bar>' : delim
    6              0.000095     exec 'inoremap <expr><silent> <Plug>delimitMate' . delim. ' <SID>TriggerAbb().delimitMate#JumpOut("\' . delim . '")'
    6              0.000058     exec 'silent! imap <unique> <buffer> ' . delim. ' <Plug>delimitMate'. delim
    6              0.000004   endfor
                            
                              " Add matching quote and jump to the midle, or exit if inside a pair of matching quotes:
                              " inoremap <silent> <buffer> " <C-R>=delimitMate#QuoteDelim("\"")<CR>
    8   0.000063   0.000018   for delim in s:get('quotes_list')
    6              0.000006     if delim == '|'
                                  let delim = '<Bar>'
                                endif
    6              0.000107     exec 'inoremap <expr><silent> <Plug>delimitMate' . delim. ' <SID>TriggerAbb()."<C-R>=delimitMate#QuoteDelim(\"\\\' . delim . '\")<CR>"'
    6              0.000059     exec 'silent! imap <unique> <buffer> ' . delim. ' <Plug>delimitMate' . delim
    6              0.000004   endfor
                            
                              " Try to fix the use of apostrophes (kept for backward compatibility):
                              " inoremap <silent> <buffer> n't n't
    2   0.000054   0.000011   for map in s:get('apostrophes_list')
                                exec "inoremap <silent> " . map . " " . map
                                exec 'silent! imap <unique> <buffer> ' . map . ' <Plug>delimitMate' . map
                              endfor

FUNCTION  <SNR>118_AllowedToCompleteInCurrentBuffer()
Called 939 times
Total time:   0.116156
 Self time:   0.012419

count  total (s)   self (s)
  939   0.115176   0.011438   return s:AllowedToCompleteInBuffer( '%' )

FUNCTION  neomake#get_nearest_error()
Called 49 times
Total time:   0.005865
 Self time:   0.005865

count  total (s)   self (s)
   49              0.000483     let buf = bufnr('%')
   49              0.000258     let ln = line('.')
   49              0.000207     let ln_errors = []
                            
  147              0.000709     for maker_type in ['file', 'project']
   98              0.001301         let buf_errors = get(s:current_errors[maker_type], buf, {})
   98              0.000828         let ln_errors += get(buf_errors, ln, [])
   98              0.000247     endfor
                            
   49              0.000257     if empty(ln_errors)
   49              0.000146         return {}
                                endif
                            
                                if len(ln_errors) > 1
                                    let ln_errors = copy(ln_errors)
                                    call sort(ln_errors, function('neomake#utils#sort_by_col'))
                                endif
                                return ln_errors[0]

FUNCTION  neomake#CursorMoved()
Called 38 times
Total time:   0.010441
 Self time:   0.000736

count  total (s)   self (s)
   38   0.010358   0.000654     call neomake#EchoCurrentError()

FUNCTION  <SNR>114_is_removed()
Called 39 times
Total time:   0.000203
 Self time:   0.000203

count  total (s)   self (s)
   39              0.000174   return a:from_count > 0 && a:to_count == 0

FUNCTION  neomake#signs#PlaceSigns()
Called 2 times
Total time:   0.002522
 Self time:   0.001121

count  total (s)   self (s)
                                " Query the list of currently placed signs.
                                " This allows to cope with movements, e.g. when lines were added.
    2   0.001131   0.000062     let placed_signs = neomake#signs#by_lnum(a:bufnr)
                            
    2              0.000009     let entries_by_linenr = {}
   10              0.000027     for entry in a:entries
    8              0.000019         let lnum = entry.lnum
    8              0.000122         let sign_type = printf('neomake_%s_%s', a:type, get(s:entry_to_sign_type, toupper(entry.type), 'err'))
    8              0.000071         if !exists('entries_by_linenr[lnum]') || s:sign_order[entries_by_linenr[lnum]]    > s:sign_order[sign_type]
    5              0.000024             let entries_by_linenr[lnum] = sign_type
    5              0.000006         endif
    8              0.000007     endfor
                            
    2              0.000008     let place_new = []
    2              0.000010     let log_context = {'bufnr': a:bufnr}
    7              0.000033     for [lnum, sign_type] in items(entries_by_linenr)
    5              0.000023         let existing_sign = get(placed_signs, lnum, [])
    5              0.000061         if empty(existing_sign) || existing_sign[1] !~# '^neomake_'.a:type.'_'
    2              0.000013             call add(place_new, [lnum, sign_type])
    2              0.000006             continue
                                    endif
    3              0.000007         if existing_sign[1] == sign_type
    3              0.000007             let sign_id = existing_sign[0]
    3   0.000198   0.000046             call neomake#log#debug(printf( 'Reusing sign: id=%d, type=%s, lnum=%d.', sign_id, existing_sign[1], lnum), log_context)
                            
                                        " Keep this sign from being cleaned.
    3              0.000019             if exists('s:last_placed_signs[a:type][a:bufnr][sign_id]')
                                            unlet s:last_placed_signs[a:type][a:bufnr][sign_id]
                                        endif
    3              0.000003         else
                                        let cmd = 'sign place '.existing_sign[0].' name='.sign_type.' buffer='.a:bufnr
                                        call neomake#log#debug('Upgrading sign for lnum='.lnum.': '.cmd.'.', log_context)
                                        exe cmd
                                    endif
    3              0.000003     endfor
                            
    4              0.000016     for [lnum, sign_type] in place_new
    2              0.000009         if !exists('next_sign_id')
    1              0.000003             if !empty(placed_signs)
                                            let next_sign_id = max(map(values(copy(placed_signs)), 'v:val[0]')) + 1
                                        else
    1              0.000006                 let next_sign_id = s:base_sign_id
    1              0.000003             endif
    1              0.000001         else
    1              0.000003             let next_sign_id += 1
    1              0.000001         endif
    2              0.000024         let cmd = 'sign place '.next_sign_id.' line='.lnum. ' name='.sign_type. ' buffer='.a:bufnr
    2   0.000230   0.000051         call neomake#log#debug('Placing sign: '.cmd.'.', log_context)
    2              0.000014         let placed_signs[lnum] = [next_sign_id, sign_type]
    2              0.000037         exe cmd
    2              0.000005     endfor
                            
    2              0.000037     let s:placed_signs[a:type][a:bufnr] = {}
    7              0.000024     for [lnum, sign_info] in items(placed_signs)
    5              0.000031         let s:placed_signs[a:type][a:bufnr][sign_info[0]] = sign_info[1]
    5              0.000005     endfor

FUNCTION  youcompleteme#CompleteFunc()
Called 194 times
Total time:   0.005351
 Self time:   0.005351

count  total (s)   self (s)
  194              0.000771   if a:findstart
                                " When auto-wrapping is enabled, Vim wraps the current line after the
                                " completion request is sent but before calling this function. The starting
                                " column returned by the server is invalid in that case and must be
                                " recomputed.
   97              0.000662     if s:completion.line != line( '.' )
                                  " Given
                                  "   scb: column where the completion starts before auto-wrapping
                                  "   cb: cursor column before auto-wrapping
                                  "   sca: column where the completion starts after auto-wrapping
                                  "   ca: cursor column after auto-wrapping
                                  " we have
                                  "   ca - sca = cb - scb
                                  "   sca = scb + ca - cb
    1              0.000005       let s:completion.completion_start_column += col( '.' ) - s:completion.column
    1              0.000001     endif
   97              0.000323     return s:completion.completion_start_column - 1
                              endif
   97              0.000247   return s:completion.completions

FUNCTION  <SNR>82_GetTabWinForMakeId()
Called 41 times
Total time:   0.001174
 Self time:   0.000969

count  total (s)   self (s)
   41              0.000343     for t in [tabpagenr()] + range(1, tabpagenr()-1) + range(tabpagenr()+1, tabpagenr('$'))
   41              0.000135         for w in range(1, tabpagewinnr(t, '$'))
   41   0.000561   0.000357             if index(neomake#compat#gettabwinvar(t, w, 'neomake_make_ids', []), a:make_id) != -1
   41              0.000058                 return [t, w]
                                        endif
                                    endfor
                                endfor
                                return [-1, -1]

FUNCTION  airline#parts#mode()
Called 3068 times
Total time:   0.161750
 Self time:   0.058142

count  total (s)   self (s)
 3068   0.157657   0.054050   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  <SNR>106_get_seperator()
Called 162 times
Total time:   0.118824
 Self time:   0.002416

count  total (s)   self (s)
  162   0.035567   0.000966   if airline#builder#should_change_group(a:prev_group, a:group)
  162   0.083107   0.001299     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  <SNR>82_GetMakerForFiletype()
Called 1 time
Total time:   0.000728
 Self time:   0.000228

count  total (s)   self (s)
    1   0.000264   0.000038     for config_ft in neomake#utils#get_config_fts(a:ft)
    1   0.000136   0.000051         call neomake#utils#load_ft_makers(config_ft)
    1              0.000028         let f = 'neomake#makers#ft#'.config_ft.'#'.a:maker_name
    1              0.000010         if exists('*'.f)
    1   0.000282   0.000092             let maker = call(f, [])
    1              0.000004             return maker
                                    endif
                                endfor
                                return s:unset_dict

FUNCTION  airline#builder#new()
Called 28 times
Total time:   0.000929
 Self time:   0.000929

count  total (s)   self (s)
   28              0.000277   let builder = copy(s:prototype)
   28              0.000070   let builder._context = a:context
   28              0.000045   let builder._sections = []
                            
   28              0.000436   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
   28              0.000046   return builder

FUNCTION  <SNR>47_strip_trailing_new_line()
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000018   return substitute(a:line, '\n$', '', '')

FUNCTION  <SNR>110_define_commands()
Called 1 time
Total time:   0.000212
 Self time:   0.000212

count  total (s)   self (s)
   29              0.000021   for command in s:commands
   28              0.000173     exe 'command! -buffer '.command
   28              0.000013   endfor

FUNCTION  LSP#text()
Called 254 times
Total time:   0.010753
 Self time:   0.010753

count  total (s)   self (s)
  254              0.005630     let l:lines = getline(1, '$')
  254              0.001939     if l:lines[-1] !=# '' && &fixendofline
  251              0.001389         let l:lines += ['']
  251              0.000366     endif
  254              0.000659     return l:lines

FUNCTION  <SNR>134_find_current_signs()
Called 18 times
Total time:   0.036280
 Self time:   0.034234

count  total (s)   self (s)
   18              0.000087   let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
   18              0.000050   let other_signs = []      " [<line_number (number),...]
   18              0.000047   let dummy_sign_placed = 0
                            
   18              0.000102   redir => signs
   18              0.001049     silent execute "sign place buffer=" . a:bufnr
   18              0.000111   redir END
                            
  479              0.002152   for sign_line in filter(split(signs, '\n')[2:], 'v:val =~# "="')
                                " Typical sign line:  line=88 id=1234 name=GitGutterLineAdded
                                " We assume splitting is faster than a regexp.
  461              0.007571     let components  = split(sign_line)
  461              0.003153     let name        = split(components[2], '=')[1]
  461              0.002072     if name =~# 'GitGutterDummy'
                                  let dummy_sign_placed = 1
                                else
  461              0.002778       let line_number = str2nr(split(components[0], '=')[1])
  461              0.001555       if name =~# 'GitGutter'
  429              0.002301         let id = str2nr(split(components[1], '=')[1])
                                    " Remove orphaned signs (signs placed on lines which have been deleted).
                                    " (When a line is deleted its sign lingers.  Subsequent lines' signs'
                                    " line numbers are decremented appropriately.)
  429              0.001497         if has_key(gitgutter_signs, line_number)
                                      execute "sign unplace" gitgutter_signs[line_number].id
                                    endif
  429              0.002393         let gitgutter_signs[line_number] = {'id': id, 'name': name}
  429              0.000327       else
   32              0.000098         call add(other_signs, line_number)
   32              0.000020       endif
  461              0.000245     end
  461              0.000378   endfor
                            
   18   0.001082   0.000374   call gitgutter#utility#setbufvar(a:bufnr, 'dummy_sign', dummy_sign_placed)
   18   0.001141   0.000165   call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', gitgutter_signs)
   18   0.000629   0.000267   call gitgutter#utility#setbufvar(a:bufnr, 'other_signs', other_signs)

FUNCTION  fugitive#ReloadStatus()
Called 12 times
Total time:   0.004493
 Self time:   0.004493

count  total (s)   self (s)
   12              0.000138   if exists('s:reloading_status')
                                return
                              endif
   12              0.000043   try
   12              0.000160     let s:reloading_status = 1
   12              0.000098     let mytab = tabpagenr()
   36              0.000462     for tab in [mytab] + range(1,tabpagenr('$'))
   48              0.000393       for winnr in range(1,tabpagewinnr(tab,'$'))
   24              0.000340         if getbufvar(tabpagebuflist(tab)[winnr-1],'fugitive_type') ==# 'index'
                                      execute 'tabnext '.tab
                                      if winnr != winnr()
                                        execute winnr.'wincmd w'
                                        let restorewinnr = 1
                                      endif
                                      try
                                        if !&modified
                                          call fugitive#BufReadStatus()
                                        endif
                                      finally
                                        if exists('restorewinnr')
                                          wincmd p
                                        endif
                                        execute 'tabnext '.mytab
                                      endtry
                                    endif
   24              0.000104       endfor
   24              0.000093     endfor
   12              0.000039   finally
   12              0.000068     unlet! s:reloading_status
   12              0.000030   endtry

FUNCTION  <SNR>82_nvim_exit_handler_buffered()
Called 41 times
Total time:   0.179832
 Self time:   0.003526

count  total (s)   self (s)
   41              0.000412     let jobinfo = get(s:jobs, get(s:map_job_ids, a:job_id, -1), {})
   41              0.000080     if empty(jobinfo)
                                    call neomake#log#debug(printf('exit: job not found: %d.', a:job_id))
                                    return
                                endif
                            
  123              0.000276     for stream in ['stdout', 'stderr']
   82              0.000224         if has_key(jobinfo.jobstart_opts, stream)
   82              0.000632             let data = copy(jobinfo.jobstart_opts[stream])
   82   0.014159   0.000721             call s:output_handler(jobinfo, data, stream, 1)
   82              0.000065         endif
   82              0.000070     endfor
                            
   41   0.163283   0.000415     call s:exit_handler(jobinfo, a:data)

FUNCTION  <SNR>111_has_fresh_changes()
Called 33 times
Total time:   0.002067
 Self time:   0.000882

count  total (s)   self (s)
   33   0.001953   0.000767   return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')

FUNCTION  <SNR>124_on_insert_leave()
Called 4 times
Total time:   0.000226
 Self time:   0.000114

count  total (s)   self (s)
    4   0.000108   0.000041   call deoplete#mapping#_restore_completeopt()
    4              0.000041   let g:deoplete#_context = {}
    4   0.000070   0.000025   call deoplete#init#_prev_completion()

FUNCTION  <SNR>19_neomake_automake()
Called 162 times
Total time:   0.662732
 Self time:   0.047652

count  total (s)   self (s)
  162   0.138666   0.004370     let disabled = neomake#config#get_with_source('disabled', 0)
  162              0.000575     if disabled[0]
                                    call s:debug_log(printf('disabled (%s)', disabled[1]))
                                    return
                                endif
  162              0.000730     let bufnr = +a:bufnr
                            
                                " TODO: blacklist/whitelist.
                                " TODO: after/only for configured buffers?!
  162              0.001483     let buftype = getbufvar(bufnr, '&buftype')
  162              0.000628     if !empty(buftype)
                                    " TODO: test
                                    call s:debug_log(printf('ignoring %s for buftype=%s', a:event, buftype), {'bufnr': bufnr})
                                    return
                                endif
                            
  162              0.001029     if a:event ==# 'TextChanged' && has('patch-8.0.1494') && !has('patch-8.0.1633')
                                  " TextChanged gets triggered in this case when loading a buffer (Vim
                                  " issue #2742).
                                  if !getbufvar(bufnr, '_neomake_seen_TextChanged', 0)
                                    call s:debug_log('Ignoring first TextChanged')
                                    call setbufvar(bufnr, '_neomake_seen_TextChanged', 1)
                                    return
                                  endif
                                endif
  162   0.023376   0.004440     call s:debug_log(printf('handling event %s', a:event), {'bufnr': bufnr})
                            
                                " NOTE: Do it later for BufWinEnter again, since &ft might not be defined (startify).
  162   0.142261   0.002579     if s:disabled_for_ft(bufnr, a:event)
                                    return
                                endif
                            
  162              0.000965     if !has_key(s:configured_buffers, bufnr)
                                    " register the buffer, and remember that it's automatic.
    1   0.052310   0.000051         call s:configure_buffer(bufnr)
    1              0.000002     endif
  162              0.000999     if empty(s:configured_buffers[bufnr].maker_jobs)
                                    call s:debug_log('no enabled makers', {'bufnr': bufnr})
                                    return
                                endif
                            
  162   0.020146   0.003920     call s:debug_log(printf('automake for event %s', a:event), {'bufnr': bufnr})
  162   0.134292   0.002247     let config = neomake#config#get('automake.events', {})
  162              0.000880     if !has_key(config, a:event)
                                    call s:debug_log('event is not registered', {'bufnr': bufnr})
                                    return
                                endif
  162              0.000863     let config = config[a:event]
                            
  162              0.000693     let event = a:event
  162              0.000576     let bufnr = +a:bufnr
                                " TODO: rename to neomake.automake.delay
  162   0.006669   0.003358     let delay = get(config, 'delay', s:get_setting('automake_delay', s:default_delay))
  162              0.002043     let context = { 'delay': delay, 'bufnr': bufnr, 'event': a:event, 'maker_jobs': s:configured_buffers[bufnr].maker_jobs, }
  162              0.000576     if event ==# 'BufWinEnter'
                                    " Ignore context, so that e.g. with vim-stay restoring the view
                                    " (cursor position), it will still be triggered.
    1              0.000002         let context.pos = []
    1              0.000000     endif
  162   0.120295   0.001972     call s:neomake_do_automake(context)

FUNCTION  gitgutter#utility#repo_path()
Called 71 times
Total time:   0.004353
 Self time:   0.001526

count  total (s)   self (s)
   71   0.002887   0.000912   let p = gitgutter#utility#getbufvar(a:bufnr, 'path')
   71   0.001366   0.000514   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  neomake#compat#get_argv()
Called 41 times
Total time:   0.000477
 Self time:   0.000477

count  total (s)   self (s)
   41              0.000129         if a:args_is_list
   41              0.000286             return [a:exe] + a:args
                                    endif
                                    return a:exe . (empty(a:args) ? '' : ' '.a:args)

FUNCTION  <SNR>81_get_cargo_workspace_root()
Called 1 time
Total time:   0.033277
 Self time:   0.000605

count  total (s)   self (s)
    1              0.000003     if !exists('b:_neomake_cargo_workspace')
    1              0.000002         let cmd = 'cargo metadata --no-deps --format-version 1'
    1   0.000338   0.000016         let [cd_error, cd_back_cmd] = neomake#utils#temp_cd(expand('%:h'))
    1              0.000002         if !empty(cd_error)
                                        call neomake#log#debug(printf( 's:get_cargo_workspace_root: failed to cd to buffer directory: %s.', cd_error))
                                    endif
    1   0.032285   0.000046         let output = system(cmd)
    1              0.000013         if !empty(cd_back_cmd)
    1              0.000433             exe cd_back_cmd
    1              0.000004         endif
    1              0.000005         if v:shell_error
                                        call neomake#log#debug(printf( 'Failed to get cargo metadata for workspace using %s.', string(cmd)))
                                        let b:_neomake_cargo_workspace = ''
                                    else
    1   0.000161   0.000050             let json = neomake#compat#json_decode(output)
    1              0.000009             let b:_neomake_cargo_workspace = json['workspace_root']
    1              0.000001         endif
    1              0.000000     endif
    1              0.000003     return b:_neomake_cargo_workspace

FUNCTION  neomake#GetMaker()
Called 1 time
Total time:   0.011973
 Self time:   0.000153

count  total (s)   self (s)
    1              0.000005     let for_ft = a:0 ? a:1 : 0
    1              0.000006     let bufnr = bufnr('%')
    1              0.000007     if type(a:name_or_maker) == type({})
                                    let maker = a:name_or_maker
                                    if !has_key(maker, 'name')
                                        let maker.name = 'unnamed_maker'
                                    endif
                                else
    1   0.003562   0.000029         let maker = neomake#get_maker_by_name(a:name_or_maker, for_ft)
    1              0.000004         if maker is# s:unset_dict
                                        if !a:0
                                            " Check &filetype if no args where provided.
                                            let maker = neomake#get_maker_by_name(a:name_or_maker, &filetype)
                                        endif
                                    endif
    1              0.000003         if maker is# s:unset_dict
                                        if for_ft isnot# 0
                                            throw printf('Neomake: Maker not found (for %s): %s', !empty(for_ft) ? 'filetype '.for_ft : 'empty filetype', a:name_or_maker)
                                        else
                                            throw printf('Neomake: Maker not found (without filetype): %s', a:name_or_maker)
                                        endif
                                    endif
    1              0.000001     endif
    1   0.008338   0.000052     return neomake#create_maker_object(maker, a:0 ? a:1 : &filetype)

FUNCTION  GetRustIndent()
Called 70 times
Total time:   0.034253
 Self time:   0.021973

count  total (s)   self (s)
                            
                            	" Starting assumption: cindent (called at the end) will do it right
                            	" normally. We just want to fix up a few cases.
                            
   70              0.000453 	let line = getline(a:lnum)
                            
   70              0.000484 	if has('syntax_items')
   70              0.007166 		let synname = synIDattr(synID(a:lnum, 1, 1), "name")
   70              0.000219 		if synname == "rustString"
                            			" If the start of the line is in a string, don't change the indent
                            			return -1
                            		elseif synname =~ '\(Comment\|Todo\)' && line !~ '^\s*/\*'  " not /* opening line
                            			if synname =~ "CommentML" " multi-line
                            				if line !~ '^\s*\*' && getline(a:lnum - 1) =~ '^\s*/\*'
                            					" This is (hopefully) the line after a /*, and it has no
                            					" leader, so the correct indentation is that of the
                            					" previous line.
                            					return GetRustIndent(a:lnum - 1)
                            				endif
                            			endif
                            			" If it's in a comment, let cindent take care of it now. This is
                            			" for cases like "/*" where the next line should start " * ", not
                            			" "* " as the code below would otherwise cause for module scope
                            			" Fun fact: "  /*\n*\n*/" takes two calls to get right!
                            			return cindent(a:lnum)
                            		endif
   70              0.000059 	endif
                            
                            	" cindent gets second and subsequent match patterns/struct members wrong,
                            	" as it treats the comma as indicating an unfinished statement::
                            	"
                            	" match a {
                            	"     b => c,
                            	"         d => e,
                            	"         f => g,
                            	" };
                            
                            	" Search backwards for the previous non-empty line.
   70              0.000374 	let prevlinenum = prevnonblank(a:lnum - 1)
   70   0.013114   0.000833 	let prevline = s:get_line_trimmed(prevlinenum)
   70              0.000614 	while prevlinenum > 1 && prevline !~ '[^[:blank:]]'
                            		let prevlinenum = prevnonblank(prevlinenum - 1)
                            		let prevline = s:get_line_trimmed(prevlinenum)
                            	endwhile
                            
                            	" Handle where clauses nicely: subsequent values should line up nicely.
   70              0.000334 	if prevline[len(prevline) - 1] == "," && prevline =~# '^\s*where\s'
                            		return indent(prevlinenum) + 6
                            	endif
                            
   70              0.000453 	if prevline[len(prevline) - 1] == "," && s:get_line_trimmed(a:lnum) !~ '^\s*[\[\]{}]' && prevline !~ '^\s*fn\s' && prevline !~ '([^()]\+,$' && s:get_line_trimmed(a:lnum) !~ '^\s*\S\+\s*=>'
                            		" Oh ho! The previous line ended in a comma! I bet cindent will try to
                            		" take this too far... For now, let's normally use the previous line's
                            		" indent.
                            
                            		" One case where this doesn't work out is where *this* line contains
                            		" square or curly brackets; then we normally *do* want to be indenting
                            		" further.
                            		"
                            		" Another case where we don't want to is one like a function
                            		" definition with arguments spread over multiple lines:
                            		"
                            		" fn foo(baz: Baz,
                            		"        baz: Baz) // <-- cindent gets this right by itself
                            		"
                            		" Another case is similar to the previous, except calling a function
                            		" instead of defining it, or any conditional expression that leaves
                            		" an open paren:
                            		"
                            		" foo(baz,
                            		"     baz);
                            		"
                            		" if baz && (foo ||
                            		"            bar) {
                            		"
                            		" Another case is when the current line is a new match arm.
                            		"
                            		" There are probably other cases where we don't want to do this as
                            		" well. Add them as needed.
                            		return indent(prevlinenum)
                            	endif
                            
   70              0.000362 	if !has("patch-7.4.355")
                            		" cindent before 7.4.355 doesn't do the module scope well at all; e.g.::
                            		"
                            		" static FOO : &'static [bool] = [
                            		" true,
                            		"	 false,
                            		"	 false,
                            		"	 true,
                            		"	 ];
                            		"
                            		"	 uh oh, next statement is indented further!
                            
                            		" Note that this does *not* apply the line continuation pattern properly;
                            		" that's too hard to do correctly for my liking at present, so I'll just
                            		" start with these two main cases (square brackets and not returning to
                            		" column zero)
                            
                            		call cursor(a:lnum, 1)
                            		if searchpair('{\|(', '', '}\|)', 'nbW', 's:is_string_comment(line("."), col("."))') == 0
                            			if searchpair('\[', '', '\]', 'nbW', 's:is_string_comment(line("."), col("."))') == 0
                            				" Global scope, should be zero
                            				return 0
                            			else
                            				" At the module scope, inside square brackets only
                            				"if getline(a:lnum)[0] == ']' || search('\[', '', '\]', 'nW') == a:lnum
                            				if line =~ "^\\s*]"
                            					" It's the closing line, dedent it
                            					return 0
                            				else
                            					return shiftwidth()
                            				endif
                            			endif
                            		endif
                            	endif
                            
                            	" Fall back on cindent, which does it mostly right
   70              0.004339 	return cindent(a:lnum)

FUNCTION  neomake#statusline#AddLoclistCount()
Called 8 times
Total time:   0.000653
 Self time:   0.000228

count  total (s)   self (s)
    8              0.000092     let s:counts[a:buf] = get(s:counts, a:buf, {})
    8   0.000547   0.000121     return s:incCount(s:counts[a:buf], a:item, a:buf)

FUNCTION  neomake#compat#in_completion()
Called 70 times
Total time:   0.002683
 Self time:   0.002683

count  total (s)   self (s)
   70              0.000319     if pumvisible()
   16              0.000038         return 1
                                endif
   54              0.000740     if has('patch-8.0.0283')
   54              0.000402         let mode = mode(1)
   54              0.000344         if mode[1] ==# 'c' || mode[1] ==# 'x'
                                        return 1
                                    endif
   54              0.000077     endif
   54              0.000109     return 0

FUNCTION  gitgutter#utility#windows()
Called 20 times
Total time:   0.000545
 Self time:   0.000545

count  total (s)   self (s)
   20              0.000411   return has('win64') || has('win32') || has('win16')

FUNCTION  airline#parts#spell()
Called 3068 times
Total time:   0.174977
 Self time:   0.174977

count  total (s)   self (s)
 3068              0.086418   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
 3068              0.014687   if g:airline_detect_spell && &spell
                                if winwidth(0) >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth(0) >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
                              endif
 3068              0.004898   return ''

FUNCTION  deoplete#init#_prev_completion()
Called 154 times
Total time:   0.002502
 Self time:   0.002502

count  total (s)   self (s)
  154              0.002179   let g:deoplete#_prev_completion = { 'event': '', 'input': '', 'candidates': [], }

FUNCTION  <SNR>110_SetupTemp()
Called 1 time
Total time:   0.000038
 Self time:   0.000019

count  total (s)   self (s)
    1   0.000025   0.000007   if has_key(s:temp_files, s:cpath(a:file))
                                let dict = s:temp_files[s:cpath(a:file)]
                                let b:git_dir = dict.dir
                                call extend(b:, {'fugitive_type': 'temp'}, 'keep')
                                if has_key(dict, 'filetype') && dict.filetype !=# &l:filetype
                                  let &l:filetype = dict.filetype
                                endif
                                setlocal foldmarker=<<<<<<<,>>>>>>>
                                setlocal bufhidden=delete nobuflisted
                                setlocal buftype=nowrite
                                nnoremap <buffer> <silent> q    :<C-U>bdelete<CR>
                                if getline(1) !~# '^diff '
                                  setlocal nomodifiable
                                endif
                                call FugitiveDetect(a:file)
                              endif
    1              0.000001   return ''

FUNCTION  <SNR>134_next_sign_id()
Called 157 times
Total time:   0.000864
 Self time:   0.000864

count  total (s)   self (s)
  157              0.000321   let next_id = s:next_sign_id
  157              0.000291   let s:next_sign_id += 1
  157              0.000158   return next_id

FUNCTION  <SNR>124_completion_timer_stop()
Called 485 times
Total time:   0.009324
 Self time:   0.009324

count  total (s)   self (s)
  485              0.002173   if !exists('s:completion_timer')
                                return
                              endif
                            
  485              0.002779   call timer_stop(s:completion_timer)
  485              0.001839   unlet s:completion_timer

FUNCTION  airline#extensions#tabline#load_theme()
Called 12 times
Total time:   0.038748
 Self time:   0.002222

count  total (s)   self (s)
   12              0.000020   if pumvisible()
                                return
                              endif
   12              0.000045   let colors    = get(a:palette, 'tabline', {})
   12              0.000043   let tablabel  = get(colors, 'airline_tablabel', a:palette.normal.airline_b)
                              " Theme for tabs on the left
   12              0.000024   let tab     = get(colors, 'airline_tab', a:palette.normal.airline_b)
   12              0.000026   let tabsel  = get(colors, 'airline_tabsel', a:palette.normal.airline_a)
   12              0.000032   let tabtype = get(colors, 'airline_tabtype', a:palette.visual.airline_a)
   12              0.000026   let tabfill = get(colors, 'airline_tabfill', a:palette.normal.airline_c)
   12              0.000030   let tabmod  = get(colors, 'airline_tabmod', a:palette.insert.airline_a)
   12              0.000020   let tabhid  = get(colors, 'airline_tabhid', a:palette.normal.airline_c)
   12              0.000044   if has_key(a:palette, 'normal_modified') && has_key(a:palette.normal_modified, 'airline_c')
   12              0.000026     let tabmodu = get(colors, 'airline_tabmod_unsel', a:palette.normal_modified.airline_c)
   12              0.000008   else
                                "Fall back to normal airline_c if modified airline_c isn't present
                                let tabmodu = get(colors, 'airline_tabmod_unsel', a:palette.normal.airline_c)
                              endif
   12   0.003348   0.000131   call airline#highlighter#exec('airline_tablabel', tablabel)
   12   0.003627   0.000146   call airline#highlighter#exec('airline_tab', tab)
   12   0.003295   0.000127   call airline#highlighter#exec('airline_tabsel', tabsel)
   12   0.003482   0.000132   call airline#highlighter#exec('airline_tabtype', tabtype)
   12   0.002163   0.000118   call airline#highlighter#exec('airline_tabfill', tabfill)
   12   0.002729   0.000080   call airline#highlighter#exec('airline_tabmod', tabmod)
   12   0.003301   0.000108   call airline#highlighter#exec('airline_tabmod_unsel', tabmodu)
   12   0.002026   0.000098   call airline#highlighter#exec('airline_tabhid', tabhid)
                            
                              " Theme for tabs on the right
   12              0.000053   let tabsel_right  = get(colors, 'airline_tabsel_right', a:palette.normal.airline_a)
   12              0.000043   let tab_right     = get(colors, 'airline_tab_right',    a:palette.inactive.airline_c)
   12              0.000034   let tabmod_right  = get(colors, 'airline_tabmod_right', a:palette.insert.airline_a)
   12              0.000026   let tabhid_right  = get(colors, 'airline_tabhid_right', a:palette.normal.airline_c)
   12              0.000038   if has_key(a:palette, 'normal_modified') && has_key(a:palette.normal_modified, 'airline_c')
   12              0.000032     let tabmodu_right = get(colors, 'airline_tabmod_unsel_right', a:palette.normal_modified.airline_c)
   12              0.000007   else
                                "Fall back to normal airline_c if modified airline_c isn't present
                                let tabmodu_right = get(colors, 'airline_tabmod_unsel_right', a:palette.normal.airline_c)
                              endif
   12   0.002134   0.000086   call airline#highlighter#exec('airline_tab_right',    tab_right)
   12   0.003190   0.000102   call airline#highlighter#exec('airline_tabsel_right', tabsel_right)
   12   0.003243   0.000114   call airline#highlighter#exec('airline_tabmod_right', tabmod_right)
   12   0.002074   0.000105   call airline#highlighter#exec('airline_tabhid_right', tabhid_right)
   12   0.003366   0.000105   call airline#highlighter#exec('airline_tabmod_unsel_right', tabmodu_right)

FUNCTION  neomake#GetMakeOptions()
Called 589 times
Total time:   0.009589
 Self time:   0.009589

count  total (s)   self (s)
  589              0.001879         let make_id = a:0 ? a:1 : s:make_id
  589              0.001907         if !has_key(s:make_info, make_id)
                                        call neomake#log#warning('warning: missing make_info key: '.make_id.'.')
                                        return {'verbosity': get(g:, 'neomake_verbose', 1)}
                                    endif
  589              0.001351         return s:make_info[make_id]

FUNCTION  neomake#utils#Slash()
Called 63 times
Total time:   0.000697
 Self time:   0.000697

count  total (s)   self (s)
   63              0.000595     return (!exists('+shellslash') || &shellslash) ? '/' : '\'

FUNCTION  <SNR>112_build_command()
Called 20 times
Total time:   0.000315
 Self time:   0.000315

count  total (s)   self (s)
   20              0.000134   if has('unix')
   20              0.000134     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  deoplete#handler#_do_complete()
Called 220 times
Total time:   0.027799
 Self time:   0.018093

count  total (s)   self (s)
  220              0.001955   let context = g:deoplete#_context
  220              0.001740   let event = get(context, 'event', '')
  220              0.001697   let modes = (event ==# 'InsertEnter') ? ['n', 'i'] : ['i']
  220   0.006799   0.004275   if s:is_exiting() || index(modes, mode()) < 0
                                call s:completion_timer_stop()
                                return
                              endif
                            
  220   0.006586   0.002751   if empty(get(context, 'candidates', [])) || deoplete#util#get_input(context.event) !=# context.input
  199              0.000317     return
                              endif
                            
   21              0.000107   let prev = g:deoplete#_prev_completion
   21              0.000096   let prev.event = context.event
   21              0.000069   let prev.input = context.input
   21              0.000120   let prev.candidates = context.candidates
                            
   21              0.000068   if context.event ==# 'Manual'
                                let context.event = ''
                              elseif !exists('g:deoplete#_saved_completeopt')
   13   0.001737   0.000226     call deoplete#mapping#_set_completeopt()
   13              0.000016   endif
                            
   21   0.002303   0.000467   let complete_method = deoplete#custom#_get_option('complete_method')
   21              0.000076   if complete_method ==# 'complete'
   21              0.000264     call feedkeys("\<Plug>_", 'i')
   21              0.000060   elseif complete_method ==# 'completefunc'
                                let &l:completefunc = 'deoplete#mapping#_completefunc'
                                call feedkeys("\<C-x>\<C-u>", 'in')
                              elseif complete_method ==# 'omnifunc'
                                let &l:omnifunc = 'deoplete#mapping#_completefunc'
                                call feedkeys("\<C-x>\<C-o>", 'in')
                              endif

FUNCTION  <SNR>110_buffer_spec()
Called 8 times
Total time:   0.001271
 Self time:   0.001150

count  total (s)   self (s)
    8              0.000026     let bufname = bufname(self['#'])
    8   0.001238   0.001118     return s:Slash(bufname == '' ? '' : fnamemodify(bufname,':p'))

FUNCTION  deoplete#util#get_next_input()
Called 226 times
Total time:   0.041635
 Self time:   0.006007

count  total (s)   self (s)
  226   0.041171   0.005543   return getline('.')[len(deoplete#util#get_input(a:event)) :]

FUNCTION  LSP#filename()
Called 578 times
Total time:  12.761144
 Self time:  12.761144

count  total (s)   self (s)
  578             12.759542     return expand('%:p')

FUNCTION  neomake#makers#ft#rust#CargoProcessOutput()
Called 11 times
Total time:   0.012111
 Self time:   0.007300

count  total (s)   self (s)
   11              0.000016     let errors = []
  445              0.000403     for line in a:context['output']
  434              0.000398         if line[0] !=# '{'
                                        continue
                                    endif
                            
  434   0.006476   0.001983         let decoded = neomake#compat#json_decode(line)
  434              0.000746         let data = get(decoded, 'message', -1)
  434              0.000755         if type(data) != type({}) || empty(data['spans'])
  429              0.000373             continue
                                    endif
                            
    5              0.000014         let error = {'maker_name': 'cargo'}
    5              0.000017         let code_dict = get(data, 'code', -1)
    5              0.000012         if code_dict is g:neomake#compat#json_null
                                        if get(data, 'level', '') ==# 'warning'
                                            let error.type = 'W'
                                        else
                                            let error.type = 'E'
                                        endif
                                    else
    5              0.000020             let error.type = code_dict['code'][0]
    5              0.000014             let error.nr = code_dict['code'][1:]
    5              0.000004         endif
                            
    5              0.000014         let span = data.spans[0]
    5              0.000026         for candidate_span in data.spans
    5              0.000009             if candidate_span.is_primary
    5              0.000007                 let span = candidate_span
    5              0.000010                 break
                                        endif
                                    endfor
                            
    5              0.000009         let expanded = 0
    5              0.000036         let has_expansion = type(span.expansion) == type({}) && type(span.expansion.span) == type({}) && type(span.expansion.def_site_span) == type({})
                            
    5              0.000054         if span.file_name =~# '^<.*>$' && has_expansion
                                        let expanded = 1
                                        call neomake#makers#ft#rust#FillErrorFromSpan(error, span.expansion.span)
                                    else
    5   0.000128   0.000061             call neomake#makers#ft#rust#FillErrorFromSpan(error, span)
    5              0.000005         endif
                            
    5              0.000013         let error.text = data.message
    5              0.000008         let detail = span.label
    5              0.000025         let children = data.children
    5              0.000024         if type(detail) == type('') && !empty(detail)
                                        let error.text = error.text . ': ' . detail
                                    elseif !empty(children) && has_key(children[0], 'message')
    5              0.000025             let error.text = error.text . '. ' . children[0].message
    5              0.000005         endif
                            
    5              0.000017         call add(errors, error)
                            
    5              0.000008         if has_expansion && !expanded
                                        let error = copy(error)
                                        call neomake#makers#ft#rust#FillErrorFromSpan(error, span.expansion.span)
                                        call add(errors, error)
                                    endif
                            
    8              0.000040         for child in children[1:]
    3              0.000011             if !has_key(child, 'message')
                                            continue
                                        endif
                            
    3              0.000027             let info = deepcopy(error)
    3              0.000006             let info.type = 'I'
    3              0.000006             let info.text = child.message
    3   0.000277   0.000049             call neomake#postprocess#compress_whitespace(info)
    3              0.000022             if has_key(child, 'rendered') && !(child.rendered is g:neomake#compat#json_null)
                                            let info.text = info.text . ': ' . child.rendered
                                        endif
                            
    3              0.000009             if len(child.spans)
    2              0.000006                 let span = child.spans[0]
    2              0.000022                 if span.file_name =~# '^<.*>$' && type(span.expansion) == type({}) && type(span.expansion.span) == type({}) && type(span.expansion.def_site_span) == type({})
                                                call neomake#makers#ft#rust#FillErrorFromSpan(info, span.expansion.span)
                                            else
    2   0.000038   0.000017                     call neomake#makers#ft#rust#FillErrorFromSpan(info, span)
    2              0.000002                 endif
    2              0.000004                 let detail = span.label
    2              0.000008                 if type(detail) == type('') && len(detail)
                                                let info.text = info.text . ': ' . detail
                                            endif
    2              0.000001             endif
                            
    3              0.000010             call add(errors, info)
    3              0.000005         endfor
    5              0.000007     endfor
   11              0.000016     return errors

FUNCTION  LanguageClient#Write()
Called 839 times
Total time:   0.045767
 Self time:   0.045767

count  total (s)   self (s)
  839              0.006897     let l:message = a:message . "\n"
  839              0.008429     if has('nvim')
                                    " jobsend respond 1 for success.
  839              0.027116         return !jobsend(s:job, l:message)
                                elseif has('channel')
                                    return ch_sendraw(s:job, l:message)
                                else
                                    echoerr 'Not supported: not nvim nor vim with +channel.'
                                endif

FUNCTION  <SNR>110_buffer_getvar()
Called 6 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    6              0.000028   return getbufvar(self['#'],a:var)

FUNCTION  gitgutter#init_buffer()
Called 13 times
Total time:   0.117798
 Self time:   0.000903

count  total (s)   self (s)
   13   0.114948   0.000233   if gitgutter#utility#is_active(a:bufnr)
   13   0.000941   0.000253     let p = gitgutter#utility#repo_path(a:bufnr, 0)
   13              0.000107     if type(p) != s:t_string || empty(p)
    1   0.001324   0.000015       call gitgutter#utility#set_repo_path(a:bufnr)
    1   0.000219   0.000035       call s:setup_maps()
    1              0.000001     endif
   13              0.000022   endif

FUNCTION  airline#parts#crypt()
Called 3068 times
Total time:   0.070380
 Self time:   0.070380

count  total (s)   self (s)
 3068              0.067456   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  airline#extensions#tabline#formatters#default#wrap_name()
Called 330 times
Total time:   0.014673
 Self time:   0.014673

count  total (s)   self (s)
  330              0.002585   let _ = s:buf_nr_show ? printf(s:buf_nr_format, a:bufnr) : ''
  330              0.005519   let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
  330              0.002980   if getbufvar(a:bufnr, '&modified') == 1
  158              0.000709     let _ .= s:buf_modified_symbol
  158              0.000206   endif
  330              0.000722   return _

FUNCTION  fugitive#Init()
Called 1 time
Total time:   0.001373
 Self time:   0.000707

count  total (s)   self (s)
    1              0.000018   if exists('#User#FugitiveBoot')
                                try
                                  let [save_mls, &modelines] = [&mls, 0]
                                  doautocmd User FugitiveBoot
                                finally
                                  let &mls = save_mls
                                endtry
                              endif
    1              0.000002   if !exists('g:fugitive_no_maps')
    1   0.000232   0.000023     call s:map('c', '<C-R><C-G>', '<SID>fnameescape(fugitive#Object(@%))', '<expr>')
    1   0.000096   0.000008     call s:map('n', 'y<C-G>', ':<C-U>call setreg(v:register, fugitive#Object(@%))<CR>', '<silent>')
    1              0.000000   endif
    1              0.000190   if expand('%:p') =~# ':[\/][\/]'
                                let &l:path = s:sub(&path, '^\.%(,|$)', '')
                              endif
    1              0.000012   if stridx(&tags, escape(b:git_dir, ', ')) == -1
    1              0.000181     if filereadable(b:git_dir.'/tags')
                                  let &l:tags = escape(b:git_dir.'/tags', ', ').','.&tags
                                endif
    1              0.000174     if &filetype !=# '' && filereadable(b:git_dir.'/'.&filetype.'.tags')
                                  let &l:tags = escape(b:git_dir.'/'.&filetype.'.tags', ', ').','.&tags
                                endif
    1              0.000000   endif
    1              0.000001   try
    1              0.000013     let [save_mls, &modelines] = [&mls, 0]
    1   0.000230   0.000018     call s:define_commands()
    1   0.000178   0.000019     doautocmd User Fugitive
    1              0.000001   finally
    1              0.000005     let &mls = save_mls
    1              0.000001   endtry

FUNCTION  airline#extensions#keymap#status()
Called 3068 times
Total time:   0.080084
 Self time:   0.080084

count  total (s)   self (s)
 3068              0.039379   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
 3068              0.035650     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  <SNR>31_setup()
Called 2 times
Total time:   0.008232
 Self time:   0.000210

count  total (s)   self (s)
    2              0.000012   let swap = a:0 && a:1 == 2
    2              0.000003   let enable = a:0 && a:1
    2              0.000003   let disable = a:0 && !a:1
                              " First, remove all magic, if needed:
    2              0.000008   if get(b:, 'delimitMate_enabled', 0)
    1   0.001337   0.000029     call s:Unmap()
                                " Switch
    1              0.000001     if swap
                                  echo "delimitMate is disabled."
                                  return
                                endif
    1              0.000000   endif
    2              0.000003   if disable
                                " Just disable the mappings.
                                return
                              endif
    2              0.000002   if !a:0
                                " Check if this file type is excluded:
    2              0.000010     if exists("g:delimitMate_excluded_ft") && index(split(g:delimitMate_excluded_ft, ','), &filetype, 0, 1) >= 0
                                  " Finish here:
                                  return 1
                                endif
                                " Check if user tried to disable using b:loaded_delimitMate
    2              0.000005     if exists("b:loaded_delimitMate")
                                  return 1
                                endif
    2              0.000001   endif
                              " Initialize settings:
    2   0.003949   0.000045   if ! s:init()
                                " Something went wrong.
                                return
                              endif
    2              0.000008   if enable || swap || !get(g:, 'delimitMate_offByDefault', 0)
                                " Now, add magic:
    2   0.002841   0.000031     call s:Map()
    2              0.000002     if a:0
                                  echo "delimitMate is enabled."
                                endif
    2              0.000001   endif

FUNCTION  <SNR>118_OnDeleteChar()
Called 10 times
Total time:   0.001404
 Self time:   0.000346

count  total (s)   self (s)
   10   0.001191   0.000133   if !s:AllowedToCompleteInCurrentBuffer()
                                return a:key
                              endif
                            
   10              0.000075   call timer_stop( s:pollers.completion.id )
   10              0.000024   if pumvisible()
    1              0.000007     return "\<C-y>" . a:key
                              endif
    9              0.000015   return a:key

FUNCTION  deoplete#custom#_get_filetype_option()
Called 1174 times
Total time:   0.171409
 Self time:   0.069635

count  total (s)   self (s)
 1174   0.036036   0.015843   let buffer_option = deoplete#custom#_get_buffer().option
 1174              0.006289   if has_key(buffer_option, a:name)
                                " Use buffer_option instead
                                return buffer_option[a:name]
                              endif
                            
 1174   0.102466   0.020885   let option = deoplete#custom#_get_option(a:name)
 1174              0.009881   let filetype = has_key(option, a:filetype) ? a:filetype : '_'
 1174              0.007080   return get(option, filetype, a:default)

FUNCTION  neomake#config#get_with_source()
Called 707 times
Total time:   0.625255
 Self time:   0.362452

count  total (s)   self (s)
  707              0.008001     let context = a:0 > 1 ? a:2 : {'ft': &filetype, 'bufnr': bufnr('%')}
  707              0.012752     let parts = type(a:name) == type([]) ? a:name : split(a:name, '\.')
                            
  707              0.002711     let prefixes = [[]]
  707              0.004945     if has_key(context, 'ft') && !empty(context.ft)
 1414   0.063338   0.012101         for ft in neomake#utils#get_config_fts(context.ft, '.')
  707              0.005544             call insert(prefixes, ['ft', ft], 0)
  707              0.001451         endfor
  707              0.000930     endif
                            
  707              0.006795     let maker_name = get(get(context, 'maker', {}), 'name', '')
  707              0.003877     let maker_only = get(context, 'maker_only', 0)
  707              0.003549     if parts[0][0:1] ==# 'b:'
                                    if !has_key(context, 'bufnr')
                                        let context.bufnr = bufnr('%')
                                    endif
                                    let parts[0] = parts[0][2:-1]
                                    if context.bufnr is# ''
                                        let lookups = []
                                    else
                                        let lookups = [['buffer', getbufvar(context.bufnr, 'neomake')]]
                                    endif
                                    call add(lookups, ['maker', get(context, 'maker', {})])
                                elseif empty(maker_name) && maker_only
                                    let lookups = [['maker', get(context, 'maker', {})]]
                                else
  707              0.021203         let lookups = (has_key(context, 'bufnr') && context.bufnr isnot# ''  ? [['buffer', getbufvar(context.bufnr, 'neomake')]]  : []) + [ ['tab', get(t:, 'neomake', {})], ['global', get(g:, 'neomake', {})], ['maker', get(context, 'maker', {})]]
  707              0.002760         if !empty(maker_name)
  216              0.000415             if maker_only
   68              0.000279                 if parts[0] !=# maker_name
   68              0.000828                     call map(prefixes, 'add(v:val, maker_name)')
   68              0.000088                 endif
   68              0.000063             else
  444              0.001647                 for prefix in reverse(copy(prefixes))
  296              0.002106                     call insert(prefixes, prefix + [maker_name], 0)
  296              0.000429                 endfor
  148              0.000197             endif
  216              0.000216         endif
  707              0.000910     endif
                            
 2780              0.010582     for [source, lookup] in lookups
 2503              0.008533         if !empty(lookup)
  923              0.002500             if source ==# 'maker'
  216              0.006305                 let maker_prefixes = map(copy(prefixes), '!empty(v:val) && v:val[-1] ==# maker_name ? v:val[:-2] : v:val')
  216              0.001636                 let maker_setting_parts = parts[0] == maker_name ? parts[1:] : parts
  216   0.043266   0.003267                 let [prefix, R] = s:get(lookup, maker_setting_parts, maker_prefixes)
  216              0.000315             else
  707   0.151752   0.011618                 let [prefix, R] = s:get(lookup, parts, prefixes)
  707              0.001011             endif
  923              0.003289             if R isnot# g:neomake#config#undefined
  430              0.013835                 let log_name = join(map(copy(parts), "substitute(v:val, '\\.', '|', '')"), '.')
  430              0.002977                 let log_source = get(context, 'log_source', '')
  430   0.046323   0.014889                 call neomake#log#debug(printf( "Using setting %s=%s from '%s'%s%s.", log_name, string(R), source,   empty(prefix) ? '' : ' (prefix: '.string(prefix).')',   empty(log_source) ? '' : ' ('.log_source.')'), context)
  430              0.001553                 return [R, source]
                                        endif
  493              0.001137             unlet R  " for Vim without patch-7.4.1546
  493              0.000572         endif
 2073              0.004250         unlet lookup  " for Vim without patch-7.4.1546
 2073              0.003063     endfor
                            
                                " Return default.
  277              0.000699     if a:0
  275              0.001103       return [a:1, 'default']
                                elseif has_key(g:neomake#config#_defaults, a:name)
    1              0.000006       return [copy(g:neomake#config#_defaults[a:name]), 'default']
                                endif
    1              0.000008     return [g:neomake#config#undefined, 'default']

FUNCTION  airline#extensions#load_theme()
Called 12 times
Total time:   0.039409
 Self time:   0.000220

count  total (s)   self (s)
   12   0.039392   0.000204   call airline#util#exec_funcrefs(s:ext._theme_funcrefs, g:airline#themes#{g:airline_theme}#palette)

FUNCTION  airline#extensions#tabline#buflist#clean()
Called 1 time
Total time:   0.000058
 Self time:   0.000047

count  total (s)   self (s)
    1   0.000018   0.000013   call airline#extensions#tabline#buflist#invalidate()
    1   0.000039   0.000033   call airline#extensions#tabline#buffers#invalidate()

FUNCTION  gitgutter#diff#run_diff()
Called 19 times
Total time:   2.051025
 Self time:   0.017120

count  total (s)   self (s)
   20   0.001483   0.000408   while gitgutter#utility#repo_path(a:bufnr, 0) == -1
    1   0.012688   0.008626     sleep 5m
    1              0.000017   endwhile
                            
   19   0.000897   0.000208   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
                              endif
                            
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
   19              0.000066   let cmd = '('
                            
                              " Append buffer number to avoid race conditions between writing and reading
                              " the files when asynchronously processing multiple buffers.
                              "
                              " Without the buffer number, index_file would have a race in the shell
                              " between the second process writing it (with git-show) and the first
                              " reading it (with git-diff).
   19              0.000183   let index_file = s:temp_index.'.'.a:bufnr
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
   19              0.000128   let buff_file = s:temp_buffer.'.'.a:bufnr
                            
   19   0.412685   0.000322   let extension = gitgutter#utility#extension(a:bufnr)
   19              0.000134   if !empty(extension)
   19              0.000170     let index_file .= '.'.extension
   19              0.000086     let buff_file .= '.'.extension
   19              0.000051   endif
                            
                              " Write file from index to temporary file.
   19   0.002438   0.000537   let index_name = g:gitgutter_diff_base.':'.gitgutter#utility#repo_path(a:bufnr, 1)
   19              0.000212   let cmd .= g:gitgutter_git_executable.' --no-pager show '.index_name.' > '.index_file.' && '
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
   19   0.004242   0.000550   call s:write_buffer(a:bufnr, buff_file)
                            
                              " Call git-diff with the temporary files.
   19              0.000239   let cmd .= g:gitgutter_git_executable.' --no-pager '.g:gitgutter_git_args
   19              0.000052   if s:c_flag
   19              0.000076     let cmd .= ' -c "diff.autorefreshindex=0"'
   19              0.000069     let cmd .= ' -c "diff.noprefix=false"'
   19              0.000063     let cmd .= ' -c "core.safecrlf=false"'
   19              0.000029   endif
   19              0.000204   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.index_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
   19              0.000137   if !a:preserve_full_diff && !empty(g:gitgutter_grep)
   19   0.001808   0.000479     let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
   19              0.000025   endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
   19              0.000094   let cmd .= ' || exit 0'
                            
   19              0.000055   let cmd .= ')'
                            
   19   0.126715   0.000297   let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
   19   0.000582   0.000416   if g:gitgutter_async && gitgutter#async#available()
   19   1.483987   0.001778     call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
   19              0.000151     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  neomake#create_maker_object()
Called 1 time
Total time:   0.008286
 Self time:   0.000332

count  total (s)   self (s)
    1              0.000017     let [maker, ft, bufnr] = [a:maker, a:ft, bufnr('%')]
                            
                                " Create the maker object.
    1   0.001610   0.000019     let GetEntries = neomake#utils#GetSetting('get_list_entries', maker, -1, ft, bufnr)
    1              0.000004     if GetEntries isnot# -1
                                    let maker = copy(maker)
                                    let maker.get_list_entries = GetEntries
                                else
    1              0.000053         let maker = extend(copy(s:command_maker_base), copy(maker))
    1              0.000003     endif
    1              0.000004     if !has_key(maker, 'get_list_entries')
                                    " Set defaults for command/job based makers.
    1   0.000584   0.000024         let defaults = extend( copy(g:neomake#config#_defaults['maker_defaults']), neomake#config#get('maker_defaults'))
    1              0.000009         call extend(defaults, { 'exe': maker.name, 'args': [], })
    1              0.000004         if !has_key(maker, 'process_output') && !has_key(maker, 'process_json')
                                        call extend(defaults, { 'errorformat': &errorformat, })
                                    endif
    6              0.000020         for [key, default] in items(defaults)
    5   0.005931   0.000127             let maker[key] = neomake#utils#GetSetting(key, {'name': maker.name}, get(maker, key, default), ft, bufnr, 1)
    5              0.000008             unlet default  " for Vim without patch-7.4.1546
    5              0.000005         endfor
    1              0.000001     endif
    1              0.000001     if v:profiling
    1              0.000005         call add(s:hack_keep_refs_for_profiling, maker)
    1              0.000000     endif
    1              0.000001     return maker

FUNCTION  <SNR>82_ProcessPendingOutput()
Called 11 times
Total time:   0.037380
 Self time:   0.000385

count  total (s)   self (s)
   11              0.000015     if a:jobinfo.file_mode
   11              0.000042         let window_make_ids = get(w:, 'neomake_make_ids', [])
   11              0.000022         if index(window_make_ids, a:jobinfo.make_id) == -1
                                        if !bufexists(a:jobinfo.bufnr)
                                            call neomake#log#info('No buffer found for output!', a:jobinfo)
                                            return 1
                                        endif
                            
                                        if a:jobinfo.bufnr != bufnr('%')
                                            call neomake#log#debug('Skipped pending job output for another buffer.', a:jobinfo)
                                            return 0
                                        elseif s:GetTabWinForMakeId(a:jobinfo.make_id) != [-1, -1]
                                            call neomake#log#debug('Skipped pending job output (not in origin window).', a:jobinfo)
                                            return 0
                                        else
                                            call neomake#log#debug("Processing pending output for job's buffer in new window.", a:jobinfo)
                                            let w:neomake_make_ids = add(get(w:, 'neomake_make_ids', []), a:jobinfo.make_id)
                                        endif
                                    endif
   11              0.000004     endif
                            
   11   0.037061   0.000067     call s:ProcessJobOutput(a:jobinfo, a:lines, a:source)
   11              0.000021     if get(a:jobinfo, 'pending_output', 0)
                                    call neomake#log#debug('Processed pending output.', a:jobinfo)
                                    let a:jobinfo.pending_output = 0
                                    call s:CleanJobinfo(a:jobinfo)
                                endif
   11              0.000006     return 1

FUNCTION  <SNR>132_untracked_output()
Called 2 times
Total time:   0.000140
 Self time:   0.000140

count  total (s)   self (s)
    2              0.000089   if a:buf =~? ('^'. a:dict.cfg['untracked_mark'])
                                let a:dict.cfg.untracked[a:dict.file] = get(g:, 'airline#extensions#branch#notexists', g:airline_symbols.notexists)
                              else
    2              0.000020     let a:dict.cfg.untracked[a:dict.file] = ''
    2              0.000003   endif

FUNCTION  neomake#config#get()
Called 543 times
Total time:   0.502101
 Self time:   0.014770

count  total (s)   self (s)
  543   0.501673   0.014341     return call('neomake#config#get_with_source', [a:name] + a:000)[0]

FUNCTION  GitGutterGetHunkSummary()
Called 3066 times
Total time:   0.183747
 Self time:   0.039564

count  total (s)   self (s)
 3066   0.180952   0.036769   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  neomake#highlights#ShowHighlights()
Called 11 times
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)

FUNCTION  <SNR>90_display_git_branch()
Called 2 times
Total time:   0.000922
 Self time:   0.000119

count  total (s)   self (s)
    2              0.000005   let name = b:buffer_vcs_config['git'].branch
    2              0.000004   try
    2   0.000859   0.000056     let commit = fugitive#buffer().commit()
                            
    2              0.000009     if has_key(s:names, commit)
                                  let name = get(s:names, commit)."(".name.")"
                                elseif !empty(commit)
                                  let ref = fugitive#repo().git_chomp('describe', '--all', '--exact-match', commit)
                                  if ref !~ "^fatal: no tag exactly matches"
                                    let name = s:format_name(substitute(ref, '\v\C^%(heads/|remotes/|tags/)=','',''))."(".name.")"
                                  else
                                    let name = matchstr(commit, '.\{'.s:sha1size.'}')."(".name.")"
                                  endif
                                endif
    2              0.000004   catch
                              endtry
                            
    2              0.000003   return name

FUNCTION  neomake#statusline#ResetCountsForBuf()
Called 41 times
Total time:   0.002970
 Self time:   0.002343

count  total (s)   self (s)
   41              0.000320     let bufnr = a:0 ? +a:1 : bufnr('%')
   41   0.001099   0.000531     call s:clear_cache(bufnr)
   41              0.000277     if has_key(s:counts, bufnr)
   11              0.000094       let r = s:counts[bufnr] != {}
   11              0.000071       unlet s:counts[bufnr]
   11              0.000029       if r
    1   0.000114   0.000056           call neomake#utils#hook('NeomakeCountsChanged', { 'reset': 1, 'file_mode': 1, 'bufnr': bufnr})
    1              0.000002       endif
   11              0.000029       return r
                                endif
   30              0.000062     return 0

FUNCTION  <SNR>103_GetHiCmd()
Called 302 times
Total time:   0.030959
 Self time:   0.030959

count  total (s)   self (s)
                              " a:list needs to have 5 items!
  302              0.000524   let res = ''
  302              0.000491   let i = -1
 1812              0.002022   while i < 4
 1510              0.002054     let i += 1
 1510              0.004290     let item = get(a:list, i, '')
 1510              0.001925     if item is ''
  791              0.001203       continue
                                endif
  719              0.000724     if i == 0
  302              0.001013       let res .= ' guifg='.item
  302              0.000310     elseif i == 1
  238              0.000501       let res .= ' guibg='.item
  238              0.000167     elseif i == 2
                                  let res .= ' ctermfg='.item
                                elseif i == 3
                                  let res .= ' ctermbg='.item
                                elseif i == 4
  179              0.000892       let res .= printf(' gui=%s cterm=%s term=%s', item, item, item)
  179              0.000120     endif
  719              0.000757   endwhile
  302              0.000576   return res

FUNCTION  <SNR>90_reset_untracked_cache()
Called 1 time
Total time:   0.000522
 Self time:   0.000489

count  total (s)   self (s)
                              " shellcmdpost - whether function was called as a result of ShellCmdPost hook
    1              0.000009   if !g:airline#init#vim_async && !has('nvim')
                                if a:shellcmdpost
                                  " Clear cache only if there was no error or the script uses an
                                  " asynchronous interface. Otherwise, cache clearing would overwrite
                                  " v:shell_error with a system() call inside get_*_untracked.
                                  if v:shell_error
                                    return
                                  endif
                                endif
                              endif
                            
    1              0.000399   let file = expand("%:p")
    3              0.000026   for vcs in keys(s:vcs_config)
                                " Dump the value of the cache for the current file. Partially mitigates the
                                " issue of cache invalidation happening before a call to
                                " s:update_untracked()
    2   0.000060   0.000027     call airline#extensions#branch#update_untracked_config(file, vcs)
    2              0.000009     let s:vcs_config[vcs].untracked = {}
    2              0.000002   endfor

FUNCTION  airline#extensions#tabline#buflist#invalidate()
Called 3 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    3              0.000021   unlet! s:current_buffer_list

FUNCTION  airline#extensions#quickfix#apply()
Called 25 times
Total time:   0.000291
 Self time:   0.000291

count  total (s)   self (s)
   25              0.000127   if &buftype == 'quickfix'
                                let w:airline_section_a = airline#extensions#quickfix#get_type()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
                              endif

FUNCTION  airline#extensions#languageclient#get()
Called 6136 times
Total time: 169.117362
 Self time:   0.350294

count  total (s)   self (s)
 6136              0.034934   let is_err = a:type == s:severity_error
 6136              0.033085   let symbol = is_err ? s:error_symbol : s:warning_symbol
                            
 6136              0.017065   let cnt = 0
 6136 168.859040   0.091972   for d in s:diagnostics_for_buffer()
                                if has_key(d, 'severity') && d.severity == a:type
                                  let cnt += 1
                                endif
                              endfor
                            
 6136              0.021269   if cnt == 0
 6136              0.012967     return ''
                              endif
                            
                              if s:show_line_numbers == 1
                                return s:airline_languageclient_count(cnt, symbol) . <sid>airline_languageclient_get_line_number(a:type)
                              else
                                return s:airline_languageclient_count(cnt, symbol)
                              endif

FUNCTION  <SNR>100_map_keys()
Called 162 times
Total time:   0.045922
 Self time:   0.045922

count  total (s)   self (s)
  162              0.001011   if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 1)
  162              0.009560     noremap <silent> <Plug>AirlineSelectTab1 :call <SID>select_tab(0)<CR>
  162              0.004009     noremap <silent> <Plug>AirlineSelectTab2 :call <SID>select_tab(1)<CR>
  162              0.003287     noremap <silent> <Plug>AirlineSelectTab3 :call <SID>select_tab(2)<CR>
  162              0.003238     noremap <silent> <Plug>AirlineSelectTab4 :call <SID>select_tab(3)<CR>
  162              0.003148     noremap <silent> <Plug>AirlineSelectTab5 :call <SID>select_tab(4)<CR>
  162              0.003227     noremap <silent> <Plug>AirlineSelectTab6 :call <SID>select_tab(5)<CR>
  162              0.003211     noremap <silent> <Plug>AirlineSelectTab7 :call <SID>select_tab(6)<CR>
  162              0.003177     noremap <silent> <Plug>AirlineSelectTab8 :call <SID>select_tab(7)<CR>
  162              0.003110     noremap <silent> <Plug>AirlineSelectTab9 :call <SID>select_tab(8)<CR>
  162              0.003941     noremap <silent> <Plug>AirlineSelectPrevTab :<C-u>call <SID>jump_to_tab(-v:count1)<CR>
  162              0.003812     noremap <silent> <Plug>AirlineSelectNextTab :<C-u>call <SID>jump_to_tab(v:count1)<CR>
  162              0.000386   endif

FUNCTION  <SNR>124_is_skip()
Called 291 times
Total time:   0.149778
 Self time:   0.019831

count  total (s)   self (s)
  291   0.118743   0.003974   if s:is_skip_text(a:event)
   71              0.000142     return 1
                              endif
                            
  220   0.020391   0.005212   let auto_complete = deoplete#custom#_get_option('auto_complete')
                            
  220              0.007122   if &paste || (a:event !=# 'Manual' && a:event !=# 'Async' && !auto_complete) || (&l:completefunc !=# '' && &l:buftype =~# 'nofile') || (a:event !=# 'InsertEnter' && mode() !=# 'i')
                                return 1
                              endif
                            
  220              0.000419   return 0

FUNCTION  airline#util#strchars()
Called 18 times
Total time:   0.000180
 Self time:   0.000180

count  total (s)   self (s)
   18              0.000088   if exists('*strchars')
   18              0.000069     return strchars(a:str)
                              else
                                return strlen(substitute(a:str, '.', 'a', 'g'))
                              endif

FUNCTION  <SNR>118_PollCompletion()
Called 292 times
Total time:   0.524174
 Self time:   0.023048

count  total (s)   self (s)
  292   0.232106   0.005314   if !s:Pyeval( 'ycm_state.CompletionRequestReady()' )
  148              0.005289     let s:pollers.completion.id = timer_start( s:pollers.completion.wait_milliseconds, function( 's:PollCompletion' ) )
  148              0.000348     return
                              endif
                            
  144   0.271438   0.004338   let s:completion = s:Pyeval( 'ycm_state.GetCompletionResponse()' )
  144   0.011172   0.003938   call s:Complete()

FUNCTION  <SNR>84_is_excluded_window()
Called 25 times
Total time:   0.001248
 Self time:   0.001248

count  total (s)   self (s)
   25              0.000089   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
                              endfor
                            
  100              0.000109   for matchw in g:airline_exclude_filenames
   75              0.000616     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
                                endif
   75              0.000046   endfor
                            
   25              0.000043   if g:airline_exclude_preview && &previewwindow
                                return 1
                              endif
                            
   25              0.000017   return 0

FUNCTION  gitgutter#async#execute()
Called 20 times
Total time:   1.483217
 Self time:   1.481217

count  total (s)   self (s)
   20   0.002042   0.000357   call gitgutter#debug#log('[async] '.a:cmd)
                            
   20              0.000249   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
   20   0.000576   0.000261   let command = s:build_command(a:cmd)
                            
   20              0.000166   if has('nvim')
   20              1.478661     call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
   20              0.000230   else
                                call job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
                              endif

FUNCTION  <SNR>103_get_array()
Called 4257 times
Total time:   0.048130
 Self time:   0.048130

count  total (s)   self (s)
 4257              0.019346   let opts=empty(a:opts) ? '' : join(a:opts, ',')
 4257              0.025796   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  gitgutter#diff#handler()
Called 18 times
Total time:   0.114285
 Self time:   0.002482

count  total (s)   self (s)
   18   0.001170   0.000168   call gitgutter#debug#log(a:diff)
                            
   18              0.000068   if !bufexists(a:bufnr)
                                return
                              endif
                            
   18   0.007052   0.000329   call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
   18   0.022795   0.000287   let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
   18              0.000082   let signs_count = len(modified_lines)
   18              0.000064   if signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf( 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).', signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
                              else
   18              0.000061     if g:gitgutter_signs || g:gitgutter_highlight_lines
   18   0.081156   0.000367       call gitgutter#sign#update_signs(a:bufnr, modified_lines)
   18              0.000017     endif
   18              0.000013   endif
                            
   18   0.001082   0.000303   call s:save_last_seen_change(a:bufnr)
   18              0.000233   if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
                              endif

FUNCTION  airline#extensions#wordcount#apply()
Called 25 times
Total time:   0.000734
 Self time:   0.000734

count  total (s)   self (s)
   25              0.000132   let filetypes = get(g:, 'airline#extensions#wordcount#filetypes', s:filetypes)
                            
                              " Check if filetype needs testing
   25              0.000075   if did_filetype() || filetypes isnot s:filetypes
    1              0.000002     let s:filetypes = filetypes
                            
                                " Select test based on type of "filetypes": new=list, old=string
    1              0.000008     if type(filetypes) == get(v:, 't_list', type([])) ? index(filetypes, &filetype) > -1 || index(filetypes, 'all') > -1 : match(&filetype, filetypes) > -1
                                  let b:airline_changedtick = -1
                                  call s:update_wordcount(1) " force update: ensures initial worcount exists
                                elseif exists('b:airline_wordcount') " cleanup when filetype is removed
                                  unlet b:airline_wordcount
                                endif
    1              0.000000   endif
                            
   25              0.000067   if exists('b:airline_wordcount')
                                call airline#extensions#prepend_to_section( 'z', '%{airline#extensions#wordcount#get()}')
                              endif

FUNCTION  <SNR>89_get_hunks_gitgutter()
Called 3068 times
Total time:   0.313838
 Self time:   0.082879

count  total (s)   self (s)
 3068   0.091817   0.044605   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
    2              0.000003     return ''
                              endif
 3066   0.208250   0.024503   return GitGutterGetHunkSummary()

FUNCTION  deoplete#custom#_get_source_vars()
Called 321 times
Total time:   0.035590
 Self time:   0.016349

count  total (s)   self (s)
  321   0.022264   0.007250   let global_vars = get(deoplete#custom#_get_source(a:name), 'vars', {})
  321   0.008559   0.004332   let buffer_vars = get(deoplete#custom#_get_buffer().source_vars, a:name, {})
  321              0.003927   return extend(copy(global_vars), buffer_vars)

FUNCTION  <SNR>134_remove_signs()
Called 18 times
Total time:   0.005513
 Self time:   0.005505

count  total (s)   self (s)
   18   0.000114   0.000106   if a:all_signs && s:supports_star && empty(gitgutter#utility#getbufvar(a:bufnr, 'other_signs'))
                                let dummy_sign_present = gitgutter#utility#getbufvar(a:bufnr, 'dummy_sign')
                                execute "sign unplace * buffer=" . a:bufnr
                                if dummy_sign_present
                                  execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . a:bufnr
                                endif
                              else
  154              0.000207     for id in a:sign_ids
  136              0.004695       execute "sign unplace" id
  136              0.000106     endfor
   18              0.000019   endif

FUNCTION  <SNR>118_AllowedToCompleteInBuffer()
Called 939 times
Total time:   0.103738
 Self time:   0.092411

count  total (s)   self (s)
  939              0.012630   let buffer_filetype = getbufvar( a:buffer, '&filetype' )
                            
  939              0.011546   if empty( buffer_filetype ) || getbufvar( a:buffer, '&buftype' ) ==# 'nofile' || buffer_filetype ==# 'qf'
                                return 0
                              endif
                            
  939   0.021338   0.010011   if s:DisableOnLargeFile( a:buffer )
                                return 0
                              endif
                            
  939              0.016868   let whitelist_allows = type( g:ycm_filetype_whitelist ) != type( {} ) || has_key( g:ycm_filetype_whitelist, '*' ) || has_key( g:ycm_filetype_whitelist, buffer_filetype )
  939              0.010579   let blacklist_allows = type( g:ycm_filetype_blacklist ) != type( {} ) || !has_key( g:ycm_filetype_blacklist, buffer_filetype )
                            
  939              0.004780   let allowed = whitelist_allows && blacklist_allows
  939              0.001913   if allowed
  939              0.006713     let s:previous_allowed_buffer_number = bufnr( a:buffer )
  939              0.001426   endif
  939              0.002023   return allowed

FUNCTION  <SNR>19_tick_changed()
Called 203 times
Total time:   0.027559
 Self time:   0.021716

count  total (s)   self (s)
  203              0.001050     let bufnr = +a:context.bufnr
  203              0.002202     let ft = get(a:context, 'ft', getbufvar(bufnr, '&filetype'))
  203              0.001314     let prev_tick = getbufvar(bufnr, 'neomake_automake_tick')
  203              0.000562     let r = 1
  203              0.000788     if empty(prev_tick)
    3   0.000292   0.000031         call s:debug_log('tick changed (new)')
    3              0.000004     else
  200              0.001540         let cur_tick = [getbufvar(bufnr, 'changedtick'), ft]
  200              0.000894         if cur_tick == prev_tick
    2   0.000156   0.000013             call s:debug_log('tick is unchanged')
    2              0.000003             return 0
                                    endif
                            
                                    " NOTE: every write (BufWritePost) increments b:changedtick.
  198              0.000737         if a:context.event ==# 'BufWritePost'
    1              0.000008             let adjusted_prev_tick = [prev_tick[0]+1, prev_tick[1]]
    1              0.000004             if adjusted_prev_tick == cur_tick
                                            let r = 0
                                            call setbufvar(bufnr, 'neomake_automake_tick', adjusted_prev_tick)
                                            call s:debug_log('tick is unchanged with BufWritePost adjustment')
                                        endif
    1              0.000001         endif
  198              0.000260     endif
  201              0.000420     if a:update
   41              0.000292         let tick = getbufvar(bufnr, 'changedtick')
   41   0.006094   0.000654         call s:debug_log('Updating tick: '.tick)
   41              0.000595         call setbufvar(bufnr, 'neomake_automake_tick', [tick, ft])
   41              0.000085     endif
  201              0.000432     return r

FUNCTION  <SNR>89_is_branch_empty()
Called 3068 times
Total time:   0.047212
 Self time:   0.047212

count  total (s)   self (s)
 3068              0.043676   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  gitgutter#hunk#increment_lines_added()
Called 41 times
Total time:   0.003243
 Self time:   0.001050

count  total (s)   self (s)
   41   0.001640   0.000366   let summary = gitgutter#hunk#summary(a:bufnr)
   41              0.000168   let summary[0] += a:count
   41   0.001371   0.000453   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  neomake#signs#by_lnum()
Called 2 times
Total time:   0.001069
 Self time:   0.000901

count  total (s)   self (s)
    2              0.000017     if !bufexists(a:bufnr + 0)
                                    return {}
                                endif
    2   0.000251   0.000083     let signs_output = split(neomake#utils#redir('sign place buffer='.a:bufnr), '\n')
                            
                                " Originally via ALE.
                                " Matches output like :
                                " line=4  id=1  name=neomake_err
                                " строка=1  id=1000001  имя=neomake_err
                                " 行=1  識別子=1000001  名前=neomake_err
                                " línea=12 id=1000001 nombre=neomake_err
                                " riga=1 id=1000001, nome=neomake_err
    2              0.000009     let d = {}
   39              0.000094     for line in reverse(signs_output[2:])
   37              0.000146         let sign_type = line[strridx(line, '=')+1:]
   37              0.000079         if sign_type[0:7] ==# 'neomake_'
    3              0.000008             let lnum_idx = stridx(line, '=')
    3              0.000006             let lnum = line[lnum_idx+1:] + 0
    3              0.000003             if lnum
    3              0.000012                 let sign_id = line[stridx(line, '=', lnum_idx+1)+1:] + 0
    3              0.000022                 let d[lnum] = [sign_id, sign_type]
    3              0.000004             endif
    3              0.000002         endif
   37              0.000046     endfor
    2              0.000008     return d

FUNCTION  <SNR>118_DisableOnLargeFile()
Called 939 times
Total time:   0.011327
 Self time:   0.011327

count  total (s)   self (s)
  939              0.006622   if exists( 'b:ycm_largefile' )
  938              0.002681     return b:ycm_largefile
                              endif
                            
    1              0.000002   let threshold = g:ycm_disable_for_files_larger_than_kb * 1024
    1              0.000238   let b:ycm_largefile = threshold > 0 && getfsize( expand( a:buffer ) ) > threshold
    1              0.000004   if b:ycm_largefile
                                exec s:python_command "vimsupport.PostVimMessage(" . "'YouCompleteMe is disabled in this buffer; " . "the file exceeded the max size (see YCM options).' )"
                              endif
    1              0.000002   return b:ycm_largefile

FUNCTION  delimitMate#JumpOut()
Called 8 times
Total time:   0.005298
 Self time:   0.000442

count  total (s)   self (s)
    8   0.003363   0.000115   if s:is_forbidden(a:char)
                                return a:char
                              endif
    8   0.001781   0.000172   let jump = s:is_jump(a:char)
    8              0.000018   if jump == 1
                                " HACK: Instead of <Right>, we remove the char to be jumped over and
                                " insert it again. This will trigger re-indenting via 'indentkeys'.
                                " Ref: https://github.com/Raimondi/delimitMate/issues/168
    7              0.000039     return "\<Del>".a:char
                              elseif jump == 3
                                return s:joinUndo() . "\<Right>" . s:joinUndo() . "\<Right>"
                              elseif jump == 5
                                return "\<Down>\<C-O>I" . s:joinUndo() . "\<Right>"
                              else
    1              0.000003     return a:char
                              endif

FUNCTION  <SNR>118_InsideCommentOrString()
Called 158 times
Total time:   0.032078
 Self time:   0.032078

count  total (s)   self (s)
                              " Has to be col('.') -1 because col('.') doesn't exist at this point. We are
                              " in insert mode when this func is called.
  158              0.028204   let syntax_group = synIDattr( synIDtrans( synID( line( '.' ), col( '.' ) - 1, 1 ) ), 'name')
                            
  158              0.001292   if stridx(syntax_group, 'Comment') > -1
                                return 1
                              endif
                            
  158              0.000503   if stridx(syntax_group, 'String') > -1
   27              0.000041     return 2
                              endif
                            
  131              0.000209   return 0

FUNCTION  <SNR>124_check_omnifunc()
Called 220 times
Total time:   0.006358
 Self time:   0.006358

count  total (s)   self (s)
  220              0.001232   let prev = g:deoplete#_prev_completion
  220              0.001192   let blacklist = ['LanguageClient#complete']
  220              0.002709   if a:context.event ==# 'Manual' || &l:omnifunc ==# '' || index(blacklist, &l:omnifunc) >= 0 || prev.input ==# a:context.input
  220              0.000466     return
                              endif
                            
                              for filetype in a:context.filetypes
                                for pattern in deoplete#util#convert2list( deoplete#custom#_get_filetype_option(   'omni_patterns', filetype, ''))
                                  if pattern !=# '' && a:context.input =~# '\%('.pattern.'\)$'
                                    let g:deoplete#_context.candidates = []
                            
                                    let prev.event = a:context.event
                                    let prev.input = a:context.input
                                    let prev.candidates = []
                            
                                    call deoplete#mapping#_set_completeopt()
                                    call feedkeys("\<C-x>\<C-o>", 'in')
                                    return 1
                                  endif
                                endfor
                              endfor

FUNCTION  neomake#utils#shellescape()
Called 164 times
Total time:   0.002951
 Self time:   0.002951

count  total (s)   self (s)
  164              0.002447     if a:arg =~# '^[A-Za-z0-9_/.=-]\+$'
  164              0.000353         return a:arg
                                elseif &shell =~? 'cmd' || exists('+shellslash') && !&shellslash
                                    return '"'.s:gsub(s:gsub(a:arg, '"', '""'), '\%', '"%"').'"'
                                endif
                                return shellescape(a:arg)

FUNCTION  <SNR>118_OnTextChangedInsertMode()
Called 158 times
Total time:   2.227197
 Self time:   0.447382

count  total (s)   self (s)
  158   0.018756   0.001797   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
  158              0.000361   if s:completion_stopped
                                let s:completion_stopped = 0
                                let s:completion = s:default_completion
                                return
                              endif
                            
  158   0.465973   0.002036   call s:IdentifierFinishedOperations()
                            
                              " We have to make sure we correctly leave semantic mode even when the user
                              " inserts something like a "operator[]" candidate string which fails
                              " CurrentIdentifierFinished check.
  158              0.001930   if s:force_semantic && !s:Pyeval( 'base.LastEnteredCharIsIdentifierChar()' )
                                let s:force_semantic = 0
                              endif
                            
  158   0.262024   0.006048   if &completefunc == "youcompleteme#CompleteFunc" && ( g:ycm_auto_trigger || s:force_semantic ) && !s:InsideCommentOrStringAndShouldStop() && !s:OnBlankLine()
                                " Immediately call previous completion to avoid flickers.
  148   0.011390   0.004033     call s:Complete()
  148   1.036823   0.001237     call s:InvokeCompletion()
  148              0.000334   endif
                            
  158              0.420290   exec s:python_command "ycm_state.OnCursorMoved()"
                            
  158              0.001803   if g:ycm_autoclose_preview_window_after_completion
                                call s:ClosePreviewWindowIfNeeded()
                              endif

FUNCTION  <SNR>47_is_file_buffer()
Called 58 times
Total time:   0.000991
 Self time:   0.000991

count  total (s)   self (s)
   58              0.000885   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  airline#extensions#tabline#builder#new()
Called 3 times
Total time:   0.000181
 Self time:   0.000070

count  total (s)   self (s)
    3   0.000135   0.000024   let builder = airline#builder#new(a:context)
    3              0.000011   let builder._build = builder.build
    3              0.000027   call extend(builder, s:prototype, 'force')
    3              0.000004   return builder

FUNCTION  airline#extensions#tabline#buffers#get()
Called 162 times
Total time:   0.150038
 Self time:   0.010035

count  total (s)   self (s)
  162              0.000554   try
  162   0.047817   0.001894     call <sid>map_keys()
  162              0.000411   catch
                                " no-op
                              endtry
  162              0.001540   let cur = bufnr('%')
  162              0.001407   if cur == s:current_bufnr && &columns == s:column_width
  161              0.001792     if !g:airline_detect_modified || getbufvar(cur, '&modified') == s:current_modified
  159              0.000682       return s:current_tabline
                                endif
    2              0.000002   endif
                            
    3   0.000357   0.000036   let b = airline#extensions#tabline#new_builder()
    3              0.000013   let tab_bufs = tabpagebuflist(tabpagenr())
    3              0.000006   let show_buf_label_first = 0
                            
    3              0.000009   if get(g:, 'airline#extensions#tabline#buf_label_first', 0)
                                let show_buf_label_first = 1
                              endif
    3              0.000004   if show_buf_label_first
                                call airline#extensions#tabline#add_label(b, 'buffers')
                              endif
                            
    3              0.000012   let b.tab_bufs = tabpagebuflist(tabpagenr())
                            
    3              0.000006   let b.overflow_group = 'airline_tabhid'
    3   0.000178   0.000026   let b.buffers = airline#extensions#tabline#buflist#list()
    3              0.000008   if get(g:, 'airline#extensions#tabline#current_first', 0)
                                if index(b.buffers, cur) > -1
                                  call remove(b.buffers, index(b.buffers, cur))
                                endif
                                let b.buffers = [cur] + b.buffers
                              endif
                            
    3              0.000010   function! b.get_group(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                if bufnum == -1
                                  return ''
                                endif
                                let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
                                if bufnum == bufnr('%')
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                endif
                                return group
                              endfunction
                            
    3              0.000014   if has("tablineat")
    3              0.000006     function! b.get_pretitle(i) dict
                                  let bufnum = get(self.buffers, a:i, -1)
                                  return '%'.bufnum.'@airline#extensions#tabline#buffers#clickbuf@'
                                endfunction
                            
    3              0.000004     function! b.get_posttitle(i) dict
                                  return '%X'
                                endfunction
    3              0.000002   endif
                            
    3              0.000004   function! b.get_title(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                let group = self.get_group(a:i)
                                let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
                                if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
                                  let space = s:spc
                                else
                                  let space= (pgroup == group ? s:spc : '')
                                endif
                            
                                if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. get(s:number_map, a:i+1, '') . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
                                  return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif
                              endfunction
                            
    3              0.000022   let current_buffer = max([index(b.buffers, cur), 0])
    3              0.000011   let last_buffer = len(b.buffers) - 1
    3   0.000093   0.000024   call b.insert_titles(current_buffer, 0, last_buffer)
                            
    3   0.000036   0.000015   call b.add_section('airline_tabfill', '')
    3   0.000026   0.000011   call b.split()
    3   0.000023   0.000011   call b.add_section('airline_tabfill', '')
    3              0.000005   if !show_buf_label_first
    3   0.000126   0.000024     call airline#extensions#tabline#add_label(b, 'buffers')
    3              0.000002   endif
                            
    3              0.000007   if tabpagenr('$') > 1
                                call b.add_section_spaced('airline_tabmod', printf('%s %d/%d', "tab", tabpagenr(), tabpagenr('$')))
                              endif
                            
    3              0.000007   let s:current_bufnr = cur
    3              0.000008   let s:column_width = &columns
    3   0.093429   0.000039   let s:current_tabline = b.build()
    3              0.000038   let s:current_visible_buffers = copy(b.buffers)
    3              0.000013   if b._right_title <= last_buffer
                                call remove(s:current_visible_buffers, b._right_title, last_buffer)
                              endif
    3              0.000007   if b._left_title > 0
                                call remove(s:current_visible_buffers, 0, b._left_title)
                              endif
    3              0.000010   return s:current_tabline

FUNCTION  deoplete#custom#_get()
Called 4198 times
Total time:   0.069587
 Self time:   0.069587

count  total (s)   self (s)
 4198              0.028203   if !exists('s:custom')
                                call deoplete#custom#_init()
                              endif
                            
 4198              0.010422   return s:custom

FUNCTION  <SNR>89_get_hunks()
Called 3068 times
Total time:   0.481803
 Self time:   0.167964

count  total (s)   self (s)
 3068              0.030745   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
    1              0.000004     if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
    1              0.000006       let b:source_func = 's:get_hunks_gitgutter'
    1              0.000001     elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
    1              0.000000   endif
 3068   0.360087   0.046248   return {b:source_func}()

FUNCTION  deoplete#custom#_get_buffer()
Called 5146 times
Total time:   0.078485
 Self time:   0.078477

count  total (s)   self (s)
 5146              0.028548   if !exists('b:custom')
    1   0.000018   0.000011     call deoplete#custom#_init_buffer()
    1              0.000001   endif
                            
 5146              0.011955   return b:custom

FUNCTION  <SNR>111_setup_maps()
Called 1 time
Total time:   0.000185
 Self time:   0.000185

count  total (s)   self (s)
    1              0.000002   if !g:gitgutter_map_keys
                                return
                              endif
                            
    1              0.000029   if !hasmapto('<Plug>GitGutterPrevHunk') && maparg('[c', 'n') ==# ''
    1              0.000009     nmap <buffer> [c <Plug>GitGutterPrevHunk
    1              0.000000   endif
    1              0.000011   if !hasmapto('<Plug>GitGutterNextHunk') && maparg(']c', 'n') ==# ''
    1              0.000006     nmap <buffer> ]c <Plug>GitGutterNextHunk
    1              0.000000   endif
                            
    1              0.000012   if !hasmapto('<Plug>GitGutterStageHunk') && maparg('<Leader>hs', 'n') ==# ''
    1              0.000008     nmap <buffer> <Leader>hs <Plug>GitGutterStageHunk
    1              0.000000   endif
    1              0.000012   if !hasmapto('<Plug>GitGutterUndoHunk') && maparg('<Leader>hu', 'n') ==# ''
    1              0.000006     nmap <buffer> <Leader>hu <Plug>GitGutterUndoHunk
    1              0.000000   endif
    1              0.000011   if !hasmapto('<Plug>GitGutterPreviewHunk') && maparg('<Leader>hp', 'n') ==# ''
    1              0.000008     nmap <buffer> <Leader>hp <Plug>GitGutterPreviewHunk
    1              0.000000   endif
                            
    1              0.000010   if !hasmapto('<Plug>GitGutterTextObjectInnerPending') && maparg('ic', 'o') ==# ''
    1              0.000007     omap <buffer> ic <Plug>GitGutterTextObjectInnerPending
    1              0.000000   endif
    1              0.000010   if !hasmapto('<Plug>GitGutterTextObjectOuterPending') && maparg('ac', 'o') ==# ''
    1              0.000006     omap <buffer> ac <Plug>GitGutterTextObjectOuterPending
    1              0.000000   endif
    1              0.000010   if !hasmapto('<Plug>GitGutterTextObjectInnerVisual') && maparg('ic', 'x') ==# ''
    1              0.000006     xmap <buffer> ic <Plug>GitGutterTextObjectInnerVisual
    1              0.000000   endif
    1              0.000009   if !hasmapto('<Plug>GitGutterTextObjectOuterVisual') && maparg('ac', 'x') ==# ''
    1              0.000005     xmap <buffer> ac <Plug>GitGutterTextObjectOuterVisual
    1              0.000000   endif

FUNCTION  deoplete#custom#_init_buffer()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000003   let b:custom = {}
    1              0.000002   let b:custom.option = {}
    1              0.000001   let b:custom.source_vars = {}

FUNCTION  airline#statusline()
Called 3068 times
Total time:   0.097180
 Self time:   0.097180

count  total (s)   self (s)
 3068              0.040579   if has_key(s:contexts, a:winnr)
 3068              0.048024     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  <SNR>111_reset_tick()
Called 1 time
Total time:   0.000022
 Self time:   0.000006

count  total (s)   self (s)
    1   0.000021   0.000006   call gitgutter#utility#setbufvar(a:bufnr, 'tick', 0)

FUNCTION  gitgutter#sign#remove_dummy_sign()
Called 1 time
Total time:   0.000026
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000010   0.000004   if gitgutter#utility#getbufvar(a:bufnr, 'dummy_sign') && (a:force || !g:gitgutter_sign_column_always)
    1              0.000004     execute "sign unplace" s:dummy_sign_id "buffer=" . a:bufnr
    1   0.000011   0.000003     call gitgutter#utility#setbufvar(a:bufnr, 'dummy_sign', 0)
    1              0.000000   endif

FUNCTION  <SNR>112_on_exit_nvim()
Called 19 times
Total time:   0.115196
 Self time:   0.000849

count  total (s)   self (s)
   19              0.000094   if !a:exit_code
   19   0.115044   0.000697     call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
   19              0.000022   endif

FUNCTION  neomake#utils#load_ft_makers()
Called 2 times
Total time:   0.000111
 Self time:   0.000111

count  total (s)   self (s)
                                " Load ft maker, but only once (for performance reasons and to allow for
                                " monkeypatching it in tests).
    2              0.000053     if index(s:loaded_ft_maker_runtime, a:ft) == -1
                                    if !exists('*neomake#makers#ft#'.a:ft.'#EnabledMakers')
                                        silent exe 'runtime! autoload/neomake/makers/ft/'.a:ft.'.vim'
                                    endif
                                    call add(s:loaded_ft_maker_runtime, a:ft)
                                endif

FUNCTION  neomake#map_makers()
Called 1 time
Total time:   0.012088
 Self time:   0.000115

count  total (s)   self (s)
    1              0.000004     let makers = []
    1              0.000002     let errors = []
    1              0.000006     let get_args = a:ft is# -1 ? [] : [a:ft]
    2              0.000006     for maker in a:makers
    1              0.000003         try
    1   0.012005   0.000032             let m = call('neomake#GetMaker', [maker] + get_args)
    1              0.000002         catch /^Neomake: /
                                        call add(errors, substitute(v:exception, '^Neomake: ', '', '').'.')
                                        continue
                                    endtry
    1              0.000002         call add(makers, m)
    1              0.000001     endfor
    1              0.000002     if !empty(errors)
                                    let log_context = get(get(s:make_info, s:make_id, {}), 'options', {})
                                    for error in errors
                                        if a:auto_enabled
                                            call neomake#log#debug(error, log_context)
                                        else
                                            call neomake#log#error(error, log_context)
                                        endif
                                    endfor
                                endif
    1              0.000002     return makers

FUNCTION  <SNR>19_get_position_context()
Called 202 times
Total time:   0.009248
 Self time:   0.005841

count  total (s)   self (s)
  202              0.002345     let w = exists('*win_getid') ? win_getid() : winnr()
  202   0.006607   0.003200     return [w, getpos('.'), neomake#compat#get_mode()]

FUNCTION  <SNR>103_hl_group_exists()
Called 1873 times
Total time:   0.028246
 Self time:   0.028246

count  total (s)   self (s)
 1873              0.009054   if !hlexists(a:group)
                                return 0
                              elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
                              endif
 1873              0.001599   return 1

FUNCTION  <SNR>54_Highlight_Matching_Pair()
Called 646 times
Total time:   0.330264
 Self time:   0.330264

count  total (s)   self (s)
                              " Remove any previous match.
  646              0.005553   if exists('w:paren_hl_on') && w:paren_hl_on
  187              0.001837     silent! call matchdelete(3)
  187              0.000905     let w:paren_hl_on = 0
  187              0.000418   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  646              0.005650   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  646              0.003581   let c_lnum = line('.')
  646              0.003321   let c_col = col('.')
  646              0.001915   let before = 0
                            
  646              0.004166   let text = getline(c_lnum)
  646              0.028392   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  646              0.003618   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
  646              0.006518     let [c_before, c] = matches[1:2]
  646              0.001045   endif
  646              0.022850   let plist = split(&matchpairs, '.\zs[:,]')
  646              0.005414   let i = index(plist, c)
  646              0.001847   if i < 0
                                " not found, in Insert mode try character before the cursor
  441              0.003758     if c_col > 1 && (mode() == 'i' || mode() == 'R')
  212              0.001151       let before = strlen(c_before)
  212              0.000629       let c = c_before
  212              0.000892       let i = index(plist, c)
  212              0.000325     endif
  441              0.000965     if i < 0
                                  " not found, nothing to do
  423              0.000952       return
                                endif
   18              0.000020   endif
                            
                              " Figure out the arguments for searchpairpos().
  223              0.000672   if i % 2 == 0
   29              0.000102     let s_flags = 'nW'
   29              0.000163     let c2 = plist[i + 1]
   29              0.000042   else
  194              0.000681     let s_flags = 'nbW'
  194              0.000674     let c2 = c
  194              0.001018     let c = plist[i - 1]
  194              0.000275   endif
  223              0.000582   if c == '['
   48              0.000103     let c = '\['
   48              0.000107     let c2 = '\]'
   48              0.000053   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
  223              0.000528   if before > 0
   18              0.000157     let has_getcurpos = exists("*getcurpos")
   18              0.000049     if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
   18              0.000135       let save_cursor = getcurpos()
   18              0.000030     else
                                  let save_cursor = winsaveview()
                                endif
   18              0.000152     call cursor(c_lnum, c_col - before)
   18              0.000025   endif
                            
  223              0.002922   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
  223              0.002163     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
  223              0.000729     try
  223              0.053415       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
  223              0.000758     catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
  223              0.000269   endif
                            
                              " Limit the search to lines visible in the window.
  223              0.001626   let stoplinebottom = line('w$')
  223              0.001216   let stoplinetop = line('w0')
  223              0.000734   if i % 2 == 0
   29              0.000131     let stopline = stoplinebottom
   29              0.000033   else
  194              0.000892     let stopline = stoplinetop
  194              0.000213   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
  223              0.001440   if mode() == 'i' || mode() == 'R'
  118              0.001270     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
  118              0.000144   else
  105              0.001047     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
  105              0.000148   endif
  223              0.000553   try
  223              0.065921     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
  223              0.000777   catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
  223              0.000663   if before > 0
   18              0.000041     if has_getcurpos
   18              0.000131       call setpos('.', save_cursor)
   18              0.000023     else
                                  call winrestview(save_cursor)
                                endif
   18              0.000019   endif
                            
                              " If a match is found setup match highlighting.
  223              0.001407   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
  186              0.001023     if exists('*matchaddpos')
  186              0.008425       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
  186              0.000355     else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
  186              0.000863     let w:paren_hl_on = 1
  186              0.000232   endif

FUNCTION  <SNR>32_is_excluded_ft()
Called 30 times
Total time:   0.000396
 Self time:   0.000396

count  total (s)   self (s)
   30              0.000256   if !exists("g:delimitMate_excluded_ft")
   30              0.000078     return 0
                              endif
                              return index(split(g:delimitMate_excluded_ft, ','), a:ft, 0, 1) >= 0

FUNCTION  gitgutter#utility#is_active()
Called 58 times
Total time:   0.756609
 Self time:   0.003413

count  total (s)   self (s)
   58   0.756498   0.003301   return g:gitgutter_enabled && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  <SNR>133_reset_summary()
Called 36 times
Total time:   0.001182
 Self time:   0.000409

count  total (s)   self (s)
   36   0.001141   0.000367   call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  airline#extensions#apply()
Called 25 times
Total time:   0.002398
 Self time:   0.001150

count  total (s)   self (s)
                            
   25   0.001408   0.000160   if s:is_excluded_window()
                                return -1
                              endif
                            
   25              0.000039   if &buftype == 'help'
                                call airline#extensions#apply_left_override('Help', '%f')
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
                              endif
                            
   25              0.000023   if &buftype == 'terminal'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                              endif
                            
   25              0.000033   if &previewwindow
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
                              endif
                            
   25              0.000186   if has_key(s:filetype_overrides, &ft)
                                let args = s:filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
                              endif
                            
   25              0.000130   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
                              endfor

FUNCTION  <SNR>110_map()
Called 2 times
Total time:   0.000296
 Self time:   0.000296

count  total (s)   self (s)
    2              0.000019   let flags = (a:0 ? a:1 : '') . (a:rhs =~# '<Plug>' ? '' : '<script>')
    2              0.000003   let head = a:lhs
    2              0.000001   let tail = ''
    2              0.000009   let keys = get(g:, a:mode.'remap', {})
    2              0.000007   if type(keys) == type([])
                                return
                              endif
    6              0.000009   while !empty(head)
    4              0.000005     if has_key(keys, head)
                                  let head = keys[head]
                                  if empty(head)
                                    return
                                  endif
                                  break
                                endif
    4              0.000040     let tail = matchstr(head, '<[^<>]*>$\|.$') . tail
    4              0.000022     let head = substitute(head, '<[^<>]*>$\|.$', '', '')
    4              0.000004   endwhile
    2              0.000009   if flags !~# '<unique>' || empty(mapcheck(head.tail, a:mode))
    2              0.000117     exe a:mode.'map <buffer>' flags head.tail a:rhs
    2              0.000005     if a:0 > 1
                                  let b:undo_ftplugin = get(b:, 'undo_ftplugin', 'exe') . '|sil! exe "' . a:mode . 'unmap <buffer> ' . head.tail . '"'
                                endif
    2              0.000001   endif

FUNCTION  <SNR>65_checkForBrowse()
Called 1 time
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
    1              0.000073     if a:dir != '' && isdirectory(a:dir)
                                    call s:initNerdTreeInPlace(a:dir)
                                endif

FUNCTION  airline#util#has_lawrencium()
Called 3068 times
Total time:   0.030011
 Self time:   0.030011

count  total (s)   self (s)
 3068              0.026609   return exists('*lawrencium#statusline')

FUNCTION  neomake#EchoCurrentError()
Called 49 times
Total time:   0.010225
 Self time:   0.003165

count  total (s)   self (s)
   49              0.000466     if !get(g:, 'neomake_echo_current_error', 1)
                                    return
                                endif
                                " a:1 might be a timer from the VimResized event.
   49              0.000422     let force = a:0 ? a:1 : 0
                            
   49   0.007802   0.000742     let message = neomake#GetCurrentErrorMsg()
   49              0.000230     if empty(message)
   49              0.000308         if exists('s:neomake_last_echoed_error')
                                        echon ''
                                        unlet s:neomake_last_echoed_error
                                    endif
   49              0.000075         return
                                endif
                                if !force && exists('s:neomake_last_echoed_error') && s:neomake_last_echoed_error == message
                                    return
                                endif
                                let s:neomake_last_echoed_error = message
                                call neomake#utils#WideMessage(message)

FUNCTION  deoplete#util#has_yarp()
Called 226 times
Total time:   0.024245
 Self time:   0.006748

count  total (s)   self (s)
  226   0.024000   0.006503   return !has('nvim') || deoplete#custom#_get_option('yarp')

FUNCTION  airline#util#shorten()
Called 6138 times
Total time:   0.204966
 Self time:   0.204966

count  total (s)   self (s)
 6138              0.064395   if winwidth(0) < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                endif
                              else
 6138              0.016645     return a:text
                              endif

FUNCTION  neomake#highlights#ResetFile()
Called 11 times
Total time:   0.000154
 Self time:   0.000047

count  total (s)   self (s)
   11   0.000150   0.000043     call s:reset('file', a:buf)

FUNCTION  <SNR>114_is_modified_and_added()
Called 17 times
Total time:   0.000148
 Self time:   0.000148

count  total (s)   self (s)
   17              0.000110   return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count

FUNCTION  <SNR>31_option_init()
Called 46 times
Total time:   0.002432
 Self time:   0.000888

count  total (s)   self (s)
   46              0.000194   let b = exists("b:delimitMate_" . a:name)
   46              0.000129   let g = exists("g:delimitMate_" . a:name)
                              " Find value to use.
   46              0.000049   if !b && !g
   45              0.000059     let value = a:default
   45              0.000030   elseif b
    1              0.000004     exec "let value = b:delimitMate_" . a:name
    1              0.000001   else
                                exec "let value = g:delimitMate_" . a:name
                              endif
   46   0.001777   0.000234   call s:set(a:name, value)

FUNCTION  <SNR>19_maybe_reconfigure_buffer()
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000014     if has_key(s:configured_buffers, a:bufnr) && !s:configured_buffers[a:bufnr].custom
                                    call s:configure_buffer(a:bufnr)
                                endif

FUNCTION  <SNR>114_process_added()
Called 24 times
Total time:   0.002335
 Self time:   0.002335

count  total (s)   self (s)
   24              0.000059   let offset = 0
  353              0.000378   while offset < a:to_count
  329              0.000385     let line_number = a:to_line + offset
  329              0.000758     call add(a:modifications, [line_number, 'added'])
  329              0.000307     let offset += 1
  329              0.000158   endwhile

FUNCTION  <SNR>32_is_forbidden()
Called 30 times
Total time:   0.011405
 Self time:   0.002167

count  total (s)   self (s)
   30   0.000789   0.000393   if s:is_excluded_ft(&filetype)
                                return 1
                              endif
   30   0.001831   0.000363   if !s:get('excluded_regions_enabled')
                                return 0
                              endif
   30   0.006578   0.000498   let region = s:get_syn_name()
   30   0.001877   0.000582   return index(s:get('excluded_regions_list'), region) >= 0

FUNCTION  <SNR>90_init_buffer()
Called 1 time
Total time:   0.000077
 Self time:   0.000077

count  total (s)   self (s)
    1              0.000006   let b:buffer_vcs_config = {}
    3              0.000012   for vcs in keys(s:vcs_config)
    2              0.000021     let b:buffer_vcs_config[vcs] = {     'branch': '',     'untracked': '',   }
    2              0.000004   endfor
    1              0.000005   unlet! b:airline_head

FUNCTION  <SNR>118_OnBlankLine()
Called 158 times
Total time:   0.219002
 Self time:   0.001959

count  total (s)   self (s)
  158   0.218830   0.001786   return s:Pyeval( 'not vim.current.line or vim.current.line.isspace()' )

FUNCTION  <SNR>118_OnTextChangedNormalMode()
Called 1 time
Total time:   0.002797
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000036   0.000003   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
    1   0.002760   0.000005   call s:OnFileReadyToParse()

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 30 times
Total time:   0.019739
 Self time:   0.002253

count  total (s)   self (s)
   30              0.000283   if getbufvar(a:bufnr, '&modified')
   10              0.000253     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
   10              0.000018   else
   20              0.000416     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
   20              0.000035   endif
                            
   30              0.000124   if !empty(colors)
   30   0.018093   0.000607     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
   30              0.000041   endif

FUNCTION  deoplete#mapping#_dummy_complete()
Called 21 times
Total time:   0.000225
 Self time:   0.000225

count  total (s)   self (s)
   21              0.000196   return "\<C-r>=deoplete#mapping#_complete()\<CR>"

FUNCTION  <SNR>118_Pyeval()
Called 769 times
Total time:   0.997289
 Self time:   0.997289

count  total (s)   self (s)
  769              0.002622   if s:using_python3
  769              0.992933     return py3eval( a:eval_string )
                              endif
                              return pyeval( a:eval_string )

FUNCTION  airline#extensions#branch#get_head()
Called 3068 times
Total time: 327.754694
 Self time:   0.144471

count  total (s)   self (s)
 3068 327.646119   0.035895   let head = airline#extensions#branch#head()
 3068              0.029385   let empty_message = get(g:, 'airline#extensions#branch#empty_message', '')
 3068              0.025219   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
 3068              0.047436   return empty(head) ? empty_message : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  neomake#action_queue#clean()
Called 62 times
Total time:   0.001375
 Self time:   0.001375

count  total (s)   self (s)
   62              0.000262     let len_before = len(s:action_queue)
   62              0.000234     call filter(s:action_queue, 'v:val[1][1][0] != a:job_or_make_info')
   62              0.000233     let removed = len_before - len(s:action_queue)
   62              0.000071     if removed
                                    call s:clean_action_queue_events()
                                    call neomake#log#debug(printf( 'Removed %d action queue entries.', removed), a:job_or_make_info)
                                endif

FUNCTION  <SNR>114_process_modified_and_added()
Called 17 times
Total time:   0.002989
 Self time:   0.002989

count  total (s)   self (s)
   17              0.000082   let offset = 0
   46              0.000145   while offset < a:from_count
   29              0.000089     let line_number = a:to_line + offset
   29              0.000193     call add(a:modifications, [line_number, 'modified'])
   29              0.000076     let offset += 1
   29              0.000050   endwhile
   90              0.000374   while offset < a:to_count
   73              0.000386     let line_number = a:to_line + offset
   73              0.000704     call add(a:modifications, [line_number, 'added'])
   73              0.000299     let offset += 1
   73              0.000156   endwhile

FUNCTION  <SNR>31_set()
Called 46 times
Total time:   0.001543
 Self time:   0.000273

count  total (s)   self (s)
   46   0.001526   0.000256   return call('delimitMate#Set', a:000)

FUNCTION  <SNR>4_AutoIndent()
Called 2 times
Total time:   0.017757
 Self time:   0.000921

count  total (s)   self (s)
    2              0.000016 	if &modifiable
    2              0.000043 		if &ft=='text' || &ft=='sql' || &ft=='html'
                            		else
    2              0.000017 			let l = line(".")
    2              0.000008 			let c = col(".")
    2   0.017644   0.000808 			normal! gg=G
    2              0.000012 			call cursor(l, c)
    2              0.000001 		endif
    2              0.000001 	endif

FUNCTION  <SNR>106_section_is_empty()
Called 267 times
Total time:   0.003134
 Self time:   0.003134

count  total (s)   self (s)
  267              0.000458   let start=1
                            
                              " do not check for inactive windows or the tabline
  267              0.000415   if a:self._context.active == 0
                                return 0
                              elseif get(a:self._context, 'tabline', 0)
   42              0.000068     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
  225              0.000391   if get(g:, 'airline_skip_empty_sections', 0) == 0
  225              0.000122     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  airline#themes#generate_color_map()
Called 60 times
Total time:   0.005832
 Self time:   0.005832

count  total (s)   self (s)
   60              0.001994   let palette = { 'airline_a': [ a:sect1[0] , a:sect1[1] , a:sect1[2] , a:sect1[3] , get(a:sect1 , 4 , '') ] , 'airline_b': [ a:sect2[0] , a:sect2[1] , a:sect2[2] , a:sect2[3] , get(a:sect2 , 4 , '') ] , 'airline_c': [ a:sect3[0] , a:sect3[1] , a:sect3[2] , a:sect3[3] , get(a:sect3 , 4 , '') ] , }
                            
   60              0.000183   if a:0 > 0
                                call extend(palette, { 'airline_x': [ a:1[0] , a:1[1] , a:1[2] , a:1[3] , get(a:1 , 4 , '' ) ] , 'airline_y': [ a:2[0] , a:2[1] , a:2[2] , a:2[3] , get(a:2 , 4 , '' ) ] , 'airline_z': [ a:3[0] , a:3[1] , a:3[2] , a:3[3] , get(a:3 , 4 , '' ) ] , })
                              else
   60              0.002023     call extend(palette, { 'airline_x': [ a:sect3[0] , a:sect3[1] , a:sect3[2] , a:sect3[3] , '' ] , 'airline_y': [ a:sect2[0] , a:sect2[1] , a:sect2[2] , a:sect2[3] , '' ] , 'airline_z': [ a:sect1[0] , a:sect1[1] , a:sect1[2] , a:sect1[3] , '' ] , })
   60              0.000102   endif
                            
   60              0.000146   return palette

FUNCTION  airline#extensions#hunks#get_hunks()
Called 3068 times
Total time:   1.024777
 Self time:   0.542974

count  total (s)   self (s)
 3068              0.019925   if !get(w:, 'airline_active', 0)
                                return ''
                              endif
                              " Cache values, so that it isn't called too often
 3068              0.092602   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && winwidth(0) == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes'
                                return b:airline_hunks
                              endif
 3068   0.520131   0.038328   let hunks = s:get_hunks()
 3068              0.009870   let string = ''
 3068              0.012785   if !empty(hunks)
12264              0.041177     for i in [0, 1, 2]
 9198              0.056234       if (s:non_zero_only == 0 && winwidth(0) > 100) || hunks[i] > 0
 9198              0.100062         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
 9198              0.013654       endif
 9198              0.018080     endfor
 3066              0.004760   endif
 3068              0.013783   let b:airline_hunks = string
 3068              0.014113   let b:airline_changenr = b:changedtick
 3068              0.013195   let s:airline_winwidth = winwidth(0)
 3068              0.007953   return string

FUNCTION  deoplete#custom#_get_source()
Called 321 times
Total time:   0.015014
 Self time:   0.009107

count  total (s)   self (s)
  321   0.009232   0.003326   let custom = deoplete#custom#_get().source
                            
  321              0.001806   if !has_key(custom, a:source_name)
    4              0.000018     let custom[a:source_name] = {}
    4              0.000004   endif
                            
  321              0.001514   return custom[a:source_name]

FUNCTION  <SNR>110_buffer_type()
Called 2 times
Total time:   0.001016
 Self time:   0.000367

count  total (s)   self (s)
    2   0.000022   0.000014   if !empty(self.getvar('fugitive_type'))
                                let type = self.getvar('fugitive_type')
                              elseif fnamemodify(self.spec(),':p') =~# '\.git/refs/\|\.git/\w*HEAD$'
                                let type = 'head'
                              elseif self.getline(1) =~ '^tree \x\{40\}$' && self.getline(2) == ''
                                let type = 'tree'
                              elseif self.getline(1) =~ '^\d\{6\} \w\{4\} \x\{40\}\>\t'
                                let type = 'tree'
                              elseif self.getline(1) =~ '^\d\{6\} \x\{40\}\> \d\t'
                                let type = 'index'
                              elseif isdirectory(self.spec())
                                let type = 'directory'
                              elseif self.spec() == ''
                                let type = 'null'
                              else
    2              0.000002     let type = 'file'
    2              0.000001   endif
    2              0.000001   if a:0
    2              0.000019     return !empty(filter(copy(a:000),'v:val ==# type'))
                              else
                                return type
                              endif

FUNCTION  <SNR>82_clean_make_info()
Called 72 times
Total time:   0.104275
 Self time:   0.004980

count  total (s)   self (s)
   72              0.000208     let make_id = a:make_info.options.make_id
   72              0.000150     let bang = a:0 ? a:1 : 0
   72              0.000178     if !bang && !empty(a:make_info.active_jobs)
   31   0.003870   0.000867         call neomake#log#debug(printf( 'Skipping cleaning of make info: %d active jobs: %s.', len(a:make_info.active_jobs), string(map(copy(a:make_info.active_jobs), 'v:val.as_string()'))), a:make_info.options)
   31              0.000025         return
                                endif
                            
                                " Queue cleanup in case of queued actions, e.g. NeomakeJobFinished hook.
   41              0.000067     let queued = []
   41              0.000124     for [_, v] in g:neomake#action_queue#_s.action_queue
                                    if has_key(v[1][0], 'make_id')
                                        let jobinfo = v[1][0]
                                        if jobinfo.make_id == make_id
                                            let queued += ['job '.jobinfo.id]
                                        endif
                                    else
                                        if v[1][0] == a:make_info
                                            let queued += ['make '.make_id]
                                        endif
                                    endif
                                endfor
   41              0.000062     if !empty(queued)
                                    call neomake#log#debug(printf('Queueing clean_make_info for already queued actions: %s', string(queued)))
                                    return neomake#action_queue#add( g:neomake#action_queue#any_event, [s:function('s:clean_make_info'), [a:make_info]])
                                endif
                            
   41              0.000122     if exists('*neomake#statusline#make_finished')
   41   0.087805   0.000257         call neomake#statusline#make_finished(a:make_info)
   41              0.000037     endif
                            
   41              0.000121     if !empty(a:make_info.finished_jobs)
                                    " Clean old signs after all jobs have finished, so that they can be
                                    " reused, avoiding flicker and keeping them for longer in general.
   11              0.000011         if g:neomake_place_signs
   11              0.000011             if a:make_info.options.file_mode
   11   0.000468   0.000083                 call neomake#signs#CleanOldSigns(a:make_info.options.bufnr, 'file')
   11              0.000005             else
                                            call neomake#signs#CleanAllOldSigns('project')
                                        endif
   11              0.000004         endif
   11   0.000063   0.000035         call s:clean_for_new_make(a:make_info)
   11   0.000551   0.000030         call neomake#EchoCurrentError(1)
   11              0.000015         if get(a:make_info, 'canceled', 0)
                                        call neomake#log#debug('Skipping final processing for canceled make.', a:make_info)
                                        call s:do_clean_make_info(a:make_info)
                                    else
   11   0.002314   0.000066             call s:handle_locqf_list_for_finished_jobs(a:make_info)
   11              0.000005         endif
   11              0.000004     else
   30   0.005904   0.000340         call s:do_clean_make_info(a:make_info)
   30              0.000018     endif
   41              0.000078     return g:neomake#action_queue#processed

FUNCTION  <SNR>18_LoadIndent()
Called 1 time
Total time:   0.000968
 Self time:   0.000679

count  total (s)   self (s)
    1              0.000008     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
    1              0.000010     let s = expand("<amatch>")
    1              0.000004     if s != ""
    1              0.000005       if exists("b:did_indent")
                            	unlet b:did_indent
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    2              0.000020       for name in split(s, '\.')
    1   0.000891   0.000602 	exe 'runtime! indent/' . name . '.vim'
    1              0.000004       endfor
    1              0.000002     endif

FUNCTION  <SNR>86_invoke_funcrefs()
Called 25 times
Total time:   0.168148
 Self time:   0.001649

count  total (s)   self (s)
   25   0.000966   0.000148   let builder = airline#builder#new(a:context)
   25   0.024295   0.000360   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
   25              0.000031   if err == 1
   25   0.142097   0.000352     let a:context.line = builder.build()
   25              0.000211     let s:contexts[a:context.winnr] = a:context
   25              0.000450     call setwinvar(a:context.winnr, '&statusline', '%!airline#statusline('.a:context.winnr.')')
   25              0.000026   endif

FUNCTION  <SNR>114_save_last_seen_change()
Called 18 times
Total time:   0.000779
 Self time:   0.000278

count  total (s)   self (s)
   18   0.000761   0.000259   call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))

FUNCTION  neomake#utils#get_config_fts()
Called 821 times
Total time:   0.058791
 Self time:   0.058791

count  total (s)   self (s)
  821              0.003938     let delim = a:0 ? a:1 : '_'
  821              0.004114     let cache_key = a:ft . delim
  821              0.004687     if !has_key(s:cache_config_fts, cache_key)
                                    let r = []
                                    let fts = split(a:ft, '\.')
                                    for ft in fts
                                        call add(r, ft)
                                        let super_ft = neomake#utils#GetSupersetOf(ft)
                                        while !empty(super_ft)
                                            if index(fts, super_ft) == -1
                                                call add(r, super_ft)
                                            endif
                                            let super_ft = neomake#utils#GetSupersetOf(super_ft)
                                        endwhile
                                    endfor
                                    if len(fts) > 1
                                        call insert(r, a:ft, 0)
                                    endif
                                    let s:cache_config_fts[cache_key] = map(r, 'neomake#utils#get_ft_confname(v:val, delim)')
                                endif
  821              0.004020     return s:cache_config_fts[cache_key]

FUNCTION  gitgutter#utility#getbufvar()
Called 3325 times
Total time:   0.090337
 Self time:   0.090337

count  total (s)   self (s)
 3325              0.047983   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
 3325              0.020037   if has_key(dict, a:varname)
 3322              0.014629     return dict[a:varname]
                              else
    3              0.000002     if a:0
    1              0.000001       return a:1
                                endif
    2              0.000001   endif

FUNCTION  <SNR>82_clean_for_new_make()
Called 22 times
Total time:   0.000893
 Self time:   0.000393

count  total (s)   self (s)
   22              0.000038     if get(a:make_info, 'cleaned_for_make', 0)
   11              0.000005         return
                                endif
   11              0.000015     let file_mode = a:make_info.options.file_mode
                                " XXX: needs to handle buffers for list entries?!
                                " See "get_list_entries: minimal example (from doc)" in
                                " tests/makers.vader.
   11              0.000007     if file_mode
   11              0.000014         let bufnr = a:make_info.options.bufnr
   11              0.000025         if has_key(s:current_errors['file'], bufnr)
    1              0.000037             unlet s:current_errors['file'][bufnr]
    1              0.000002         endif
   11   0.000205   0.000051         call neomake#highlights#ResetFile(bufnr)
   11   0.000409   0.000064         call neomake#log#debug('File-level errors cleaned.', {'make_id': a:make_info.options.make_id, 'bufnr': bufnr})
   11              0.000006     else
                                    " TODO: test
                                    for buf in keys(s:current_errors.project)
                                        unlet s:current_errors['project'][buf]
                                        call neomake#highlights#ResetProject(+buf)
                                    endfor
                                endif
   11              0.000016     let a:make_info.cleaned_for_make = 1

FUNCTION  <SNR>19_do_postponed_automake()
Called 32 times
Total time:   0.005554
 Self time:   0.002993

count  total (s)   self (s)
   32              0.000301     if exists('b:_neomake_postponed_automake_context')
   32              0.000238         let context = b:_neomake_postponed_automake_context
                            
   32              0.000213         if context[0] == a:step - 1
   17              0.000046             if a:step == 2
    1   0.000142   0.000012                 call s:debug_log('re-starting postponed automake')
    1   0.000069   0.000017                 let context[1].pos = s:get_position_context()
    1   0.000383   0.000013                 call s:neomake_do_automake(context[1])
    1              0.000002             else
   16              0.000092                 let context[0] = a:step
   16              0.000034                 return
                                        endif
    1              0.000001         else
   15   0.002296   0.000286             call s:debug_log('postponed automake: unexpected step '.a:step.', cleaning up')
   15              0.000025         endif
                            
                                    " Cleanup.
   16              0.000156         augroup neomake_automake_retry
   16              0.000184           autocmd! CompleteDone <buffer>
   16              0.000136           autocmd! InsertLeave <buffer>
   16              0.000033         augroup END
   16              0.000136         unlet b:_neomake_postponed_automake_context
   16              0.000025     endif

FUNCTION  LSP#visible_line_end()
Called 322 times
Total time:   0.004174
 Self time:   0.004174

count  total (s)   self (s)
  322              0.003934     return line('w$') - 1

FUNCTION  airline#highlighter#reset_hlcache()
Called 12 times
Total time:   0.005722
 Self time:   0.005722

count  total (s)   self (s)
   12              0.005678   let s:hl_groups = {}

FUNCTION  airline#util#prepend()
Called 6136 times
Total time:   0.089130
 Self time:   0.089130

count  total (s)   self (s)
 6136              0.026598   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
 6136              0.039997   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  LSP#visible_line_start()
Called 322 times
Total time:   0.009232
 Self time:   0.009232

count  total (s)   self (s)
  322              0.008673     return line('w0') - 1

FUNCTION  <SNR>128_evaluate_tabline()
Called 18 times
Total time:   0.040225
 Self time:   0.001967

count  total (s)   self (s)
   18              0.000060   let tabline = a:tabline
   18   0.038803   0.000545   let tabline = substitute(tabline, '%{\([^}]\+\)}', '\=eval(submatch(1))', 'g')
   18              0.000312   let tabline = substitute(tabline, '%#[^#]\+#', '', 'g')
   18              0.000267   let tabline = substitute(tabline, '%(\([^)]\+\)%)', '\1', 'g')
   18              0.000160   let tabline = substitute(tabline, '%\d\+[TX]', '', 'g')
   18              0.000135   let tabline = substitute(tabline, '%=', '', 'g')
   18              0.000120   let tabline = substitute(tabline, '%\d*\*', '', 'g')
   18              0.000127   if has('tablineat')
   18              0.000118     let tabline = substitute(tabline, '%@[^@]\+@', '', 'g')
   18              0.000027   endif
   18              0.000037   return tabline

FUNCTION  neomake#compat#json_decode()
Called 435 times
Total time:   0.004604
 Self time:   0.004604

count  total (s)   self (s)
  435              0.000486           if a:json is# ''
                                          " Prevent Neovim from throwing E474: Attempt to decode a blank string.
                                          return g:neomake#compat#json_none
                                      endif
  435              0.003373           return json_decode(a:json)

FUNCTION  <SNR>115_clear_cache()
Called 90 times
Total time:   0.000887
 Self time:   0.000887

count  total (s)   self (s)
   90              0.000474     if has_key(s:cache, a:bufnr)
                                    unlet s:cache[a:bufnr]
                                endif

FUNCTION  delimitMate#QuoteDelim()
Called 8 times
Total time:   0.009256
 Self time:   0.002067

count  total (s)   self (s)
    8   0.003698   0.000209   if s:is_forbidden(a:char)
                                return a:char
                              endif
    8   0.000732   0.000197   let char_at = s:get_char(0)
    8   0.000824   0.000138   let char_before = s:get_char(-1)
    8   0.000620   0.000192   let nesting_on = index(s:get('nesting_quotes'), a:char) > -1
    8              0.000080   let left_q = nesting_on ? s:lquote(a:char) : 0
    8              0.000034   if nesting_on && left_q > 1
                                " Nesting quotes.
                                let right_q =  s:rquote(a:char)
                                let quotes = right_q > left_q + 1 ? 0 : left_q - right_q + 2
                                let lefts = quotes - 1
                                return repeat(a:char, quotes) . repeat(s:joinUndo() . "\<Left>", lefts)
                              elseif char_at == a:char
                                " Inside an empty pair, jump out
    3              0.000030     return a:char . "\<Del>"
                              elseif a:char == '"' && index(split(&ft, '\.'), "vim") != -1 && getline('.') =~ '^\s*$'
                                " If we are in a vim file and it looks like we're starting a comment, do
                                " not add a closing char.
                                return a:char
                              elseif s:is_smart_quote(a:char)
                                " Seems like a smart quote, insert a single char.
                                return a:char
                              elseif (char_before == a:char && char_at != a:char) && !empty(s:get('smart_quotes'))
                                " Seems like we have an unbalanced quote, insert one quotation
                                " mark and jump to the middle.
    1   0.000063   0.000031     return a:char . s:joinUndo() . "\<Left>"
                              else
                                " Insert a pair and jump to the middle.
    4              0.000017     let sufix = ''
    4   0.000311   0.000130     if !empty(s:get('eol_marker')) && col('.') - 1 == len(getline('.'))
                                  let idx = len(s:get('eol_marker')) * -1
                                  let marker = getline('.')[idx : ]
                                  let has_marker = marker == s:get('eol_marker')
                                  let sufix = !has_marker ? s:get('eol_marker') : ''
                                endif
    4   0.000182   0.000083     return a:char . a:char . s:joinUndo() . "\<Left>"
                              endif

FUNCTION  <SNR>118_StartMessagePoll()
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000003   if s:pollers.receive_messages.id < 0
    1              0.000010     let s:pollers.receive_messages.id = timer_start( s:pollers.receive_messages.wait_milliseconds, function( 's:ReceiveMessages' ) )
    1              0.000001   endif

FUNCTION  delimitMate#Set()
Called 46 times
Total time:   0.001271
 Self time:   0.000235

count  total (s)   self (s)
   46   0.001257   0.000222   return call('s:set', a:000)

FUNCTION  <SNR>118_VisitedBufferRequiresReparse()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000006   if bufnr( '%' ) ==# s:previous_allowed_buffer_number
    1              0.000002     return 0
                              endif
                            
                              return s:AllowedToCompleteInCurrentBuffer()

FUNCTION  deoplete#mapping#_complete()
Called 21 times
Total time:   0.254448
 Self time:   0.207109

count  total (s)   self (s)
   21   0.254319   0.206981   call complete(g:deoplete#_context.complete_position + 1, g:deoplete#_context.candidates)
                            
   21              0.000066   return ''

FUNCTION  LanguageClient#handleTextChanged()
Called 254 times
Total time:   0.137882
 Self time:   0.015976

count  total (s)   self (s)
  254              0.002201     if &buftype !=# '' || &filetype ==# ''
                                    return
                                endif
                            
  254              0.000681     try
                                    " Note: do not add 'text' as it might be huge.
  254   0.130059   0.008154         call LanguageClient#Notify('languageClient/handleTextChanged', { 'filename': LSP#filename(), })
  254              0.000665     catch
                                    call s:Debug('LanguageClient caught exception: ' . string(v:exception))
                                endtry

FUNCTION  gitgutter#hunk#set_hunks()
Called 18 times
Total time:   0.001421
 Self time:   0.000399

count  total (s)   self (s)
   18   0.000676   0.000187   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
   18   0.000694   0.000161   call s:reset_summary(a:bufnr)

FUNCTION  <SNR>134_highlight_name_for_change()
Called 440 times
Total time:   0.002407
 Self time:   0.002407

count  total (s)   self (s)
  440              0.000901   if a:text ==# 'added'
  384              0.000521     return 'GitGutterLineAdded'
                              elseif a:text ==# 'removed'
                                return 'GitGutterLineRemoved'
                              elseif a:text ==# 'removed_first_line'
    8              0.000023     return 'GitGutterLineRemovedFirstLine'
                              elseif a:text ==# 'modified'
   48              0.000069     return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
                                return 'GitGutterLineModifiedRemoved'
                              endif

FUNCTION  deoplete#mapping#_set_completeopt()
Called 13 times
Total time:   0.001512
 Self time:   0.001228

count  total (s)   self (s)
   13              0.000089   if exists('g:deoplete#_saved_completeopt')
                                return
                              endif
   13              0.000184   let g:deoplete#_saved_completeopt = &completeopt
   13   0.000445   0.000260   set completeopt-=longest
   13   0.000137   0.000100   set completeopt+=menuone
   13   0.000114   0.000081   set completeopt-=menu
   13              0.000244   if &completeopt !~# 'noinsert\|noselect'
   13   0.000127   0.000097     set completeopt+=noselect
   13              0.000025   endif

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
 3068 327.754694   0.144471  airline#extensions#branch#get_head()
 3068 327.610224   0.164094  airline#extensions#branch#head()
 3068 214.086191   0.366005  <SNR>90_update_branch()
 3068 213.336901   0.182067  <SNR>90_update_git_branch()
 3068 213.127577   0.112596  FugitiveHead()
 3068 212.975832             fugitive#Head()
 6136 169.117362   0.350294  airline#extensions#languageclient#get()
 6136 168.767068             <SNR>92_diagnostics_for_buffer()
 3068 113.358902 113.254931  <SNR>90_update_untracked()
 3068  86.916006   0.040027  airline#extensions#languageclient#get_warning()
 3068  86.144278  86.143174  airline#extensions#fugitiveline#bufname()
 3068  82.279873   0.038490  airline#extensions#languageclient#get_error()
  324  12.785679   0.049229  LanguageClient#handleCursorMoved()
  578  12.761144             LSP#filename()
 1571   3.420591             provider#python3#Call()
   12   3.363077   0.920847  gitgutter#all()
   45   2.701159   0.006172  gitgutter#process_buffer()
  158   2.227197   0.447382  <SNR>118_OnTextChangedInsertMode()
   19   2.051025   0.017120  gitgutter#diff#run_diff()
   20   1.483217   1.481217  gitgutter#async#execute()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
 3068            212.975832  fugitive#Head()
 6136            168.767068  <SNR>92_diagnostics_for_buffer()
 3068 113.358902 113.254931  <SNR>90_update_untracked()
 3068  86.144278  86.143174  airline#extensions#fugitiveline#bufname()
  578             12.761144  LSP#filename()
 1571              3.420591  provider#python3#Call()
   20   1.483217   1.481217  gitgutter#async#execute()
  176              1.166730  <SNR>47_abs_path()
  769              0.997289  <SNR>118_Pyeval()
   12   3.363077   0.920847  gitgutter#all()
  148   1.035586   0.891918  <SNR>118_InvokeCompletion()
 3068   1.237755   0.731223  airline#check_mode()
  226   0.968761   0.727311  deoplete#init#_context()
 3068   0.801783   0.698102  airline#extensions#whitespace#check()
  324   0.737271   0.692426  <SNR>118_OnCursorMovedNormalMode()
 3068   1.024777   0.542974  airline#extensions#hunks#get_hunks()
  158   2.227197   0.447382  <SNR>118_OnTextChangedInsertMode()
21476              0.438004  airline#util#append()
  330   0.414647   0.399973  airline#extensions#tabline#formatters#default#format()
33748              0.369685  airline#util#wrap()

